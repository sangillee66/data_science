---
title: "웹 앱 개발: Shiny의 활용"
author: 이상일(서울대학교 지리교육과)
date-modified: last-modified
number-sections: true
format: 
  html: 
    toc: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
lightbox: true
editor: visual
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

## 개요 {.unnumbered}

여기서는 웹 앱 개발 도구로서의 [**Shiny**](https://shiny.posit.co/)에 대해 배운다. [**Shiny**](https://shiny.posit.co/)는 서버-기반의 웹 앱을 개발하기 위한 프레임워크를 제공한다. 원래 [R 패키지](https://rstudio.github.io/shiny/)로 개발되었으나 이제는 R과 Python 모두를 위한 웹 앱 개발 도구로 발전하고 있다.

-   [Shiny for R](https://shiny.posit.co/r/getstarted/shiny-basics/lesson1/)

-   [Shiny for Python](https://shiny.posit.co/py/)

[**Shiny**](https://shiny.posit.co/r/getstarted/shiny-basics/lesson1/)를 배우기 위한 다양한 리소스가 존재한다. 가장 중요한 리소스는 [Shiny for R](https://shiny.posit.co/r/getstarted/shiny-basics/lesson1/) 홈페이지이다. Get Started를 살펴본 후 Gallery의 다양한 예제를 살펴보는 것으로 시작하는 것이 좋다. 이 홈페이지의 내용만으로도 Shiny의 기본 구조와 문법을 익히기에 충분하다.

좀 더 종합적으로 Shiny을 이해하려면 다음의 웹 북을 활용할 수 있다. 첫 번째가 바이블이라고 할 수 있다.

-   [*Mastering Shiny*](https://mastering-shiny.org/) by [Hadley Wickham](https://hadley.nz/)

-   [*Outstanding User Interfaces with Shiny*](https://unleash-shiny.rinterface.com/)

-   [*Engineering Production-Grade Shiny Apps*](https://engineering-shiny.org/)

-   [*Interactive Web-Based Data Visualization with R, plotly, and shiny*](https://plotly-r.com/)

-   [*R Shiny Applications in Finance, Medicine Pharama and Education Industry*](https://bookdown.org/loankimrobinson/rshinybook/)

-   [*Introduction to Data Science*: 25 Shiny Applications](https://bookdown.org/hneth/i2ds/shiny.html)

-   [데이터 사이언스를 위한 R 프로그래밍: 14 shiny](https://greendaygh.github.io/Rprog2021/shiny.html)

## 기본 동작

### 기본 구조

Shiny는 크게 세 부분으로 나뉘어 진다(@fig-structure).

첫째, **UI**(혹은 UX) 부분이다. 프론트엔트(front-end) 부분으로 **입력을 받고**, Server에서 산출된 **출력을 표출**하는 부분이다.

둘째, **Server** 부분이다. 백엔드(back-end) 부분으로 UI에서 받은 입력에 기반하여 **출력을 산출**하는 부분이다.

셋째, **결합 및 실행** 부분이다. UI와 Server 부분을 결합해 웹 앱을 실행하는 부분이다. 결합 및 실행은 단일 파일 속에 UI와 Server를 함께 다루는 방식과, 두 개의 파일로 분할하여 다루는 방식으로 나뉜다. 여기서는 전자를 중심으로 설명한다.

![Shiny의 구조(<https://bookdown.org/hneth/i2ds/shiny.html>)](https://bookdown.org/hneth/i2ds/images/Shiny_ui_server.png "Shiny의 구조"){#fig-structure}

### Shiny 프로젝트의 생성

여기서는 RStudio에서 Shiny 프로젝트를 생성하는 방법에 대해 배운다. New Project \> New Directory \> Shiny Application을 선택한다. @fig-create 에서 Directory name과 Subdirectory의 위치를 설정한다.

![Shiny 프로젝트의 생성](images/clipboard-1356184653.png){#fig-create}

이렇게 하면 Shiny 프로젝트가 생성되고, 자동적으로 app.R이라는 스크립트 파일이 생성된다.

### 웹 앱의 생성

app.R에서 스크립트 윈도우 오른쪽 상단에 위치한 Run App 버튼을 클릭하면 @fig-first 같은웹 앱이 새로운 윈도우에 생성된다. 왼쪽의 슬라이더바를 움직이면 오른쪽의 히스토그램이 변한다는 점을 확인한다. 즉 빈(bin)의 개수를 달리하면서 데이터 분포를 탐색해보기 위한 단순한 웹 앱이 만들어진 것이다.

![단순한 웹 앱](images/clipboard-295121675.png){#fig-first}

이 단순한 웹 앱을 살펴본다. 다음과 같은 점을 확인할 수 있다.

첫째, 크게 두 부분으로 구성되어 있는데, 왼편의 슬라이더바가 있는 부분과 오른편의 히스토그램이 있는 부분으로 나뉜다. 부차적으로 상단에 제목("Old Faithful Geyser Data")이 있는 부분도 존재한다. 이 모든 것이 UI를 구성한다. 위에서 UI는 입력을 받고 출력을 표출한다고 했다. 왼편의 슬라이더바가 입력을 받는 부분이고, 오른편의 플롯 영역이 출력을 표출하는 부분이다.

둘째, 사용자의 입력은 빈(bin)의 갯수이고, Server는 이 값을 바탕으로 히스토그램이라는 출력을 생성한다. 생성된 출력은 UI로 이동하여 표출된다. 사용자의 입력값이 바뀌면 이 과정이 반복되고 히스토그램이 바뀌게 된다.

## Shiny의 기본 문법 체계

이제 @fig-first 웹 앱을 생성한 코드를 살펴보도록 한다. 코드 속에는 다양한 설명이 포함되어 있는데 그것을 제거하고 코드만 남기면 결국 다음과 같다. 문법이 [**tidyverse**](https://tidyverse.org/)와는 많이 다르다는 점을 금방 인식할 수 있다. 따라서 [**shiny**](https://rstudio.github.io/shiny/)의 문법 체계는 따로 익힐 수 밖에 없다.

```{r}
#| eval: false
library(shiny)

ui <- fluidPage(
    titlePanel("Old Faithful Geyser Data"),
    sidebarLayout(
        sidebarPanel(
            sliderInput(inputId = "bins",
                        label = "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),
        mainPanel(
           plotOutput(outputId = "distPlot")
        )
    )
)

server <- function(input, output) {
    output$distPlot <- renderPlot({
        x    <- faithful[, 2]
        bins <- seq(min(x), max(x), length.out = input$bins + 1)
        hist(x, breaks = bins, col = 'darkgray', border = 'white',
             xlab = 'Waiting time to next eruption (in mins)',
             main = 'Histogram of waiting times')
    })
}

shinyApp(ui = ui, server = server)
```

코드를 자세히 살펴보자. 우선 [**shiny**](https://rstudio.github.io/shiny/)라는 R 패키지를 불러와야 한다. 코드가 ui, server, shinyApp의 세 부분으로 나뉘어져 있다는 것을 알 수 있고, 이것이 위에서 설명한 UI 부분, Server 부분, 결합 및 실행 부분을 담당한다는 점을 쉽게 이해할 수 있다.

### UI 부분

UI 부분은 다양한 함수들이 위계 구조를 이루고 있는데, 전체 구조를 결정하는 **레이아웃 함수**가 마치 컨테이너처럼 존재하고 그 속에 **입출력 함수**가 포함되어 있는 구조이다.

첫째, 레이아웃 함수가 위계 구조를 이루고 있다. 최상위 `fluidPage()` 함수는 `titlePanel()`과 `sidebarLayout()`로 구성되고, `sidebarLayout()`은 다시 `sidebarPanel()`과 `mainPanel()`로 구성된다. 하나씩 위계적으로 살펴보면 다음과 같다.

-   `fluidPage()` : UI의 최상위 컨테이너로서 전체 레이아웃을 관장하며, 브라우저 화면 크기에 따라 자동으로 늘어나고 줄어드는 반응형 레이아웃을 제공한다. 이러한 특성 때문에 ‘fluid’라는 이름이 붙었다. 고정 폭을 가진 레이아웃은 `fixedPage()`를 통해 정의할 수 있다. Shiny 앱에서는 기본적으로 `fluidPage()`를 사용한다고 생각하면 된다.

    -   `titlePanel()` : 제목이 들어가는 부분이다. 생략가능하다.

    -   `sidebarLayout()`: UI의 핵심 부분으로, 가장 전형적인 "사이드바 + 메인 영역" 레이아웃을 `fluidPage()` 내에 생성할 수 있게 해준다.

        -   `sidebarPanel()`: 입력을 받는 부분으로, 입력 함수 혹은 입력 위젯(widget)을 담는 컨테이너이다.

        -   `mainPanel()` : 출력을 표출하는 부분으로, 서버에서 생성된 출력 객체가 UI에 표시될 수 있도록 출력 표출(바인딩) 함수를 담는 컨테이너이다.

둘째, `sidebarPanel()` 내의 `sliderInput()`은 특정한 **입력 함수** 혹은 **입력 위젯 생성 함수**이다. 여기서는 슬라이더바 형태의 입력을 받기 때문에 `sliderInput()` 함수가 사용된 것이다. 입력의 형태에 따라 다양한 입력 함수가 존재하며, 일반적으로 `*Input()` 형식을 띤다. 뒤에서 자세히 다룬다. 개별 함수는 상호작용형 인터페이스 컴포넌트로 미리 만들어져 있기 때문에 위젯이라고 부른다. `sliderInput()`은 다양한 인수로 구성되어 있는데, 가장 중요한 것이 `inputId` 인수이다. 입력 함수는 위젯을 통해 입력값을 받고 그 입력값은 Server의 `input` 객체의 한 요소가 되는데 `inputId` 인수는 `input` 객체에서 해당 요소를 참조할 '이름'을 지정한다.

셋째, `mainPanel()` 내의 `plotOutput()`은 특정한 **출력 표출 함수** 혹은 **출력 바인딩(binding) 함수**이다. 이것은 Server에서 전달받은 출력 즉 `output` 객체의 요소를 표출한다. 바인딩 함수라고 부르는 것은 출력 요소와 브라우저의 특정 UI 영역을 '연결(바인드)'하기 때문이다. 출력의 형태가 플롯(plot)이기 때문에 `plotOutput()` 함수가 사용된 것이다. 출력의 형태에 따라 다양한 출력 표출 함수가 존재하며, 일반적으로 `*Output()`의 형식을 띤다. 뒤에서 자세히 다룬다. `plotOutput()` 함수의 가장 중요한 인수는 `outputId`로 표출할 `output` 객체의 요소의 '이름'을 지정한다. `plotOutput(outputId = "distPlot")`는 서버에서 만들어진 `"distPlot"`라는 이름의 플롯(`output` 객체의 한 요소)을 해당 위치에 표출한다는 의미이다.

> 결국 UI는 입력을 받고 출력을 표출하는 두 가지 일을 하는데, 전자는 `sliderInput()`과 같은 입력 함수를 통해 이루어지며, 후자는 `plotOutput()`과 같은 출력 표출 함수를 통해 이루어진다. 이들 함수는 출력과 입력의 형식에 따라 일반적으로 `*Input()`과 `*Output()`의 형태를 띤다.

### Server 부분

Server 부분은 다음과 같은 구조를 가지고 있다.

첫째, Server 부분은 반드시 **함수**로 정의되며, 일반적으로 `function(input, output){}` 혹은 `function(input, output, session){}`의 형식을 갖는다(`input`과 `output`은 필수이지만 `session`은 부가적으로 정의될 수 있다). 반드시 함수로 정의되어야 하는 것은 `input`과 `output`(부가적으로 session)을 인수로 받아, 입력 변화에 따라 반응형 출력이 생성 및 갱신되는 로직을 정의하기 때문입니다.

둘째, 출력물은 `renderPlot({})`과 같은 **출력 생성 함수(렌더링 함수)**를 통해 이루어진다. 이렇게 생성된 출력은 '이름'이 지정되어 Server의 `output` 객체의 한 원소로 저장된다. 예를 들어, 코드에서 `output$distPlot`은 생성된 출력에 `"distPlot"`이라는 이름을 부여하고 이를 `output` 객체에 저장함을 의미한다. 이 이름은 UI의 출력 표출 함수 `plotOutput(outputId = "distPlot")`에서 사용되며, 이를 통해 해당 출력이 UI에 표출된다.

셋째, 출력의 형태가 플롯이기 때문에 `renderPlot({})` 함수가 사용된 것이다. 출력의 형태에 따라 다양한 출력 생성 함수가 존재하며, 일반적으로 `render*({})`의 형식을 띤다. 뒤에서 자세히 다룬다.

넷째, 입력 함수로부터 전달되어 Server의 `input` 객체의 요소로 저장된 입력값은 출력 생성 함수 내부에서 사용된다. 예를 들어, `seq(min(x), max(x), length.out = input$bins + 1)`에서 `sliderInput()` 함수로부터 전달된 `bins`라는 입력값(즉, `input` 객체의 한 요소)이 `seq()` 함수 내부에서 사용된다. 입력값이 달라짐에 따라 히스토그램의 모양이 달라지는 이유가 여기에 있다.

> 결국 Server는 UI에서 전달된 입력에 기반하여 출력을 산출한다. 구체적으로, `input$*` 형식의 입력값을 Server 내부에서 사용하여 `renderPlot({})`와 같은 출력 생성 함수를 통해 출력을 생성하고, 그 결과를 `output$*` 형식으로 저장함으로써 UI에 표출될 수 있도록 한다.

### 결합 및 실행 부분

UI와 server 부분은 결합되어 하나의 Shiny 웹 앱을 구성하며, 이를 실행하기 위해 `shinyApp()` 함수가 사용된다. `shinyApp(ui = ui, server = server)`에서 볼 수 있듯이, `shinyApp()` 함수에 UI 부분과 Server 부분을 지정함으로써 Shiny 웹 앱이 생성되고 실행된다.

이것은 단일 파일 방식으로 결합 및 실행을 하는 것이다. 콘솔창에서 실행하고자 한다면 다음과 같이하면 된다. 파일명에 app.R과 같은 UI와 Server 부분이 모두 포함된 파일의 이름을 지정하면 된다.

```{r}
#| eval: false
runApp("파일명")
```

만일 UI와 Server 부분을 다른 파일로 구성하는 분리 파일 방식인 경우는 다음과 같이 진행한다. 우선 UI 부분의 파일을 따로 만든다. 예를 들어 ui.R이라는 스크립트 파일을 다음과 같이 생성한다. 단일 파일 방식과 달리 UI 부분을 ui 객체에 할당하지 않아도 된다.

```{r}
#| eval: false
library(shiny)

fluidPage(
    titlePanel("Old Faithful Geyser Data"),
    sidebarLayout(
        sidebarPanel(
            sliderInput(inputId = "bins",
                        label = "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),
        mainPanel(
           plotOutput(outputId = "distPlot")
        )
    )
)
```

마찬가지로 Server 부분의 파일을 따로 만든다. 예를 들어 server.R이라는 스크립트 파일을 다음과 같이 생성한다. 단일 파일 방식과 달리 Server 부분을 server라는 객체에 할당하지 않아도 된다.

```{r}
#| eval: false
library(shiny)

function(input, output) {
    output$distPlot <- renderPlot({
        x    <- faithful[, 2]
        bins <- seq(min(x), max(x), length.out = input$bins + 1)
        hist(x, breaks = bins, col = 'darkgray', border = 'white',
             xlab = 'Waiting time to next eruption (in mins)',
             main = 'Histogram of waiting times')
    })
}
```

콘솔 창에서 다음과 같이 실행한다. 이때 지정한 폴더에는 UI 부분을 정의한 파일(예: ui.R)과 server 부분을 정의한 파일(예: server.R)이 포함되어 있어야 한다. 이름은 반드시 ui.R과 server.R이어야 한다.

```{r}
#| eval: false

runApp("폴더명")
```

위의 두 가지 방식을 결합한 제3의 길도 있다. 우선 위의 분리 파일 방식과 같이 UI와 Server 부분에 대한 파일을 개별적을 생성한다. 차이점은 반드시 ui와 server 객체를 할당하는 방식으로 이러우져야 한다는 점이다. my_ui.R의 내용은 다음과 같다. 이 방식에서는 UI 부분의 파일 이름이 반드시 ui.R일 필요가 없다.

```{r}
#| eval: false

ui <- fluidPage(
    titlePanel("Old Faithful Geyser Data"),
    sidebarLayout(
        sidebarPanel(
            sliderInput(inputId = "bins",
                        label = "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),
        mainPanel(
           plotOutput(outputId = "distPlot")
        )
    )
)
```

my_server.R의 내용은 다음과 같다. 마찬가지로 Server 부분의 파일의 이름이 server.R일 필요가 없다.

```{r}
server <- function(input, output) {
    output$distPlot <- renderPlot({
        x    <- faithful[, 2]
        bins <- seq(min(x), max(x), length.out = input$bins + 1)
        hist(x, breaks = bins, col = 'darkgray', border = 'white',
             xlab = 'Waiting time to next eruption (in mins)',
             main = 'Histogram of waiting times')
    })
}
```

그리고 나서 단일 파일 방식과 같이 app.R 파일을 통해 결합한다. app.R 파일의 내용은 다음과 같다.

```{r}
#| eval: false
library(shiny)

source("my_ui.R")
source("my_server.R")

shinyApp(ui = ui, server = server)
```

UI 파일과 Server 파일을 분리하는 방식은 코드가 매우 복잡할 때 사용하는 것으로 보통은 단일 파일 방식을 사용한다.

## 입출력 함수의 종류

### 입력 함수

앞에서 언급한 것처럼, 입력 함수 혹은 입력 위젯 생성 함수의 종류는 다양하다. [R Shiny Components](https://shiny.posit.co/r/components/) 웹페이지 기준으로 대략 25개 정도이다. @fig-widget 은 그 중 일부를 보여주고 있다.

![입력 위젯의 종류(<https://shiny.posit.co/r/getstarted/build-an-app/reactive-flow/ui-inputs.html>)](https://shiny.posit.co/r/getstarted/build-an-app/images/cheatsheet-inputs.png){#fig-widget}

몇 가지 주목할 사항이 있다.

첫째, 모든 함수의 이름이 `*Input()` 형식인 것은 아니다. 특히 버튼 형식의 경우 `*Button()` 혹은 `*Buttons()` 형식을 띤다. 이 외에 `*Link()`, `*switch()`로 끝나는 함수도 있다.

둘째, 입력 함수의 인수에 주목할 필요가 있다. 이름을 부여하는 `inputID` 인수와 입력 위젯의 설명 글귀를 지정하는 `label` 인수는 공통이다. 그러나 나머지 인수는 입력 함수에 따라 달라진다. 위의 예에서 `sliderInput()` 입력 함수는 `min`, `max`, `value`라는 추가적인 인수를 갖는데, `min`과 `max`는 슬라이더의 최대 및 최소값을, `value`는 위젯에 기본값을 지정하는 인수이다. 입력 함수별 인수에 대한 자세한 사항은 [R Shiny Components](https://shiny.posit.co/r/components/) 웹페이지를 참조한다.

### 출력 함수: 출력 표출 함수와 출력 생성 함수

출력 함수는 서버에서 생성된 출력을 UI에서 표출해주는 출력 표출(바인딩) 함수와 서버에서 실질적으로 출력을 창출하는 출력 생성 함수(렌더링 함수)로 구분된다. 출력 함수의 종류는 출력의 형식(플롯, 테이블, 텍스트, 이미지 등)에 의해 결정되기 때문에 기본적인 출력의 종류에 따라 출력 표출 함수와 출력 생성 함수가 쌍을 이룰 수 밖에 없다.

다음은 다섯 가지 기본 출력 함수의 쌍을 보여준다. 출력 표출 함수는 `*Output()`의 형식을, 출력 생성 함수는 `render*({})`의 형식을 취한다.

| 형식               | 출력 표출 함수                       | 출력 생성 함수  |
|-------------------|----------------------------------|-------------------|
| 플롯               | `plotOutput(outputID = "")`          | `renderPlot()`  |
| 테이블             | `tableOutput(outputID = "")`         | `renderTable()` |
| 일반 텍스트        | `textOutput(outputID = "")`          | `renderText()`  |
| 사전 포맷된 텍스트 | `verbatimeTextOutput(outputID = "")` | `renderPrint()` |
| 이미지             | `imageOutput(outputID = "")`         | `renderImage()` |

그런데 특히 주요 시각화 패키지들은 Shiny 웹 앱 구축을 염두에 두고 개별적인 출력 표출 함수와 출력 생성 함수를 제공하고 있다. 중요한 패키지에 대해 이를 정리하면 다음과 같다. 모두 `패키지명Output()`형식과 `render패키지명({})`의 형식을 띤다.

| 패키지 | 출력 표출 함수 | 출력 생성 함수 |
|------------------|-------------------------------|-----------------------|
| [**DT**](https://rstudio.github.io/DT/) | `DTOutput(outputID = "")` | `renderDT({})` |
| [**reactable**](https://glin.github.io/reactable/) | `reactableOutput(outputID = "")` | `renderReactable({})` |
| [**plotly**](https://plotly.com/r/) | `plotlyOutput(outputID = "")` | `renderPlotyl({})` |
| [**echarts4r**](https://echarts4r.john-coene.com/) | `echarts4rOutput(outputID = "")` | `renderEcharts4r({})` |
| [**leaflet**](https://rstudio.github.io/leaflet/) | `leafletOutput(outputID = "")` | `renderLeaflet({})` |
| [**tmap**](https://r-tmap.github.io/tmap/) | `tmapOutput(outputID = "")` | `renderTmap({})` |

Shiny 웹 앱에서의 활용을 염두에 둔 패키지들은 모두 이러한 출력 함수의 쌍을 제공하고 있다. 따라서 출력 함수는 굉장히 많을 수 있다. [R Shiny Components](https://shiny.posit.co/r/components/) 웹페이지는 기본 5개의 함수쌍에 주요 패키지를 포함하는 12개 정도의 출력 함수쌍을 예시로 제시하고 있다.

## 반응성 함수

### 정의

Shiny의 반응성(reactivity)이란, 입력값의 변화에 따라 관련된 계산과 출력이 자동으로 재실행ㆍ갱신되는 메커니즘을 의미한다. 좀 더 기술적으로 표현하면 반응성은 입력(`input`)의 변화가 의존 관계(dependency)를 따라 전파되어, 반응형 표현식과 출력이 자동으로 갱신되는 실행 모델이다.

반응성 함수란, 입력값에 대한 의존성을 추적하고 입력 변화 시 자동으로 재실행되는 함수를 말한다. 따라서 Shiny에서 반응성 함수는 공통적으로 다음 특징을 갖는다.

-   `input$*`에 의존

-   입력이 바뀌면 자동으로 재실행

-   사용자가 직접 호출하지 않음

-   Shiny의 반응성 그래프(dependency graph)에 의해 관리됨

### 종류

Shiny의 반응성 함수는 **역할에 따라 크게 세 부류**로 나눌 수 있다.

#### 출력 생성 함수: `render*` 계열

출력 생성 함수는 반응형 계산을 통해 출력물을 생성하고, 그 결과를 `output` 객체의 요소로 저장하는 함수이다. 일반 형식은 다음과 같다.

```{r}
#| eval: false
render*({
  # 반응형 코드
})
```

반드시 `output$이름 <- render*({ ... })` 형태로 사용되며, **출력의 “최종 종착점”이며,** UI의 `*Output()`과 1:1로 대응된다. 예시는 다음과 같다.

```{r}
#| eval: false
output$distPlot <- renderPlot({
  hist(x, breaks = input$bins)
})
```

#### 반응형 표현식 함수: `reactive({})`

`reactive({})`는 입력값에 따라 달라지는 계산 결과를 반응형 객체로 생성하는 함수이다. 입력을 받아 '반응성 표현식(reactive expression)'을 생성한다. 여기서 반응성 표현식이란 단순히 최종 산출물(값이나 객체)만을 의미하지 않고, 그 산출물을 관리하는 메커니즘(종속성 추적, 지연 실행, 캐싱 등) 포함하는 동적인 객체를 의미한다. 따라서 반드시 함수 형태로 표기한다.

하나의 입력이 여러 개의 출력 함수(출력 생성 함수)와 결부되는 경우에 주로 사용되는데 동일한 입력의 중복 사용을 회피하기 위해 해당 입력을 반응성 표현식으로 전환하여 다수의 출력 생성 함수에 입력으로 투입할 수 있다.

일반 형식은 다음과 같다.

```{r}
#| eval: false
r <- reactive({
  # 반응형 계산
})
```

출력이 아니라 중간 계산 결과를 생성하며, 반환값은 반응형 객체가 되고, 값에 접근할 때는 함수 형식으로 반드시 `()` 를 사용해야 한다. 예시는 다음과 같다.

```{r}
#| eval: false
bins <- reactive({
  seq(min(x), max(x), length.out = input$bins + 1)
})

output$distPlot <- renderPlot({
  hist(x, breaks = bins())
})
```

입력 함수를 통해 받은 `input$bins`를 읽어 `bins`라는 새로운 반응형 객체를 생성하고, 그것을 출력 생성 함수에서 투입하는 방식을 보여주고 있다. 반응형 객체는 반드시 bins()처럼 함수 형식으로 호출해야만 한다.

그런데, 여기서는 사실 `reactive({})` 함수가 반드시 필요한 것은 아니다. 즉, 다음과 같이 해도 무방하다.

```{r}
#| eval: false
bins <- seq(min(x), max(x), length.out = input$bins + 1)

output$distPlot <- renderPlot({
  hist(x, breaks = bins)
})
```

그러나 출력 생성 함수가 여러 개 사용되고 거기에 bins가 여러 번 사용된다면 위와 같이 하는 것이 훨씬 효율적이다.

#### 반응형 관찰자 함수: `observe*()` 계열

반응형 관찰자 함수는 입력 변화에 반응하여 특정 동작(side effect)을 수행하는 함수이다. 대표적인 함수는 다음과 같다.

-   `observe()`

-   `observeEvent()`

-   `eventReactive()` (중간적 성격)

특징은 값을 반화하지 않고, 출력 생성이 목적도 아니다. 주로 상태 변경, 메시지 출력, UI 업데이트에 사용된다. 다음에 예시가 있다.

```{r}
#| eval: false
observeEvent(input$go, {
  cat("버튼이 눌렸습니다\n")
})
```

입력 함수 `actionButton(inputID = "go", ...)`로부터 버튼을 누를 때 마다 `"go"`라는 입력 요소의 값(`input$go`)이 1씩 증가하고, `input$go`값이 변할 때마다(즉, 버튼이 눌릴 때마다) Server에서 `{ }` 속의 내용을 실행한다. 위의 예시의 경우 버튼을 클리할 때마다 콘솔에 "버튼이 눌렸습니다"가 출력된다.

좀 더 현실적인 예시를 제시하면 다음과 같다. 버튼 클릭시 계산을 실행하게 할 수 있다.

```{r}
#| eval: false
observeEvent(input$go, {
  result <- heavy_calculation()
  print(result)
})
```

UI 요소를 업데이트하게 할 수 있다.

```{r}
#| eval: false
observeEvent(input$go, {
  updateSliderInput(session, "bins", value = 20)
})
```

파일을 저장하게 할 수 있다.

```{r}
#| eval: false
observeEvent(input$save, {
  write.csv(data, "result.csv")
})
```

사실 observeEvent() 함수는 observe() 함수와 매우 유사하다. 아래는 동일하게 작동한다.

```{r}
#| eval: false
observe({
  input$go
  cat("버튼이 눌렸습니다\n")
})
```

그러나 `observeEvent()`는 이벤트 중심이고, 의존성을 명확히 분리하며, 가독성과 안전성을 높이는 장점이 있다. 따라서 버튼 처리에는 `observeEvent()`가 권장된다.

## [**bslib**](https://rstudio.github.io/bslib/) 패키지의 활용

## 웹 앱의 공유

### 웹 앱 배포(deployment)

웹 앱을 배포하는 방법은 다양할 수 있지만 여기서는 [shinyapp.io](https://www.shinyapps.io/)를 이용하는 방법에 대해 배운다.

첫째, 해당 홈페이지(<https://www.shinyapps.io/>)에 접속한다.

둘째, 계정을 생성한다.

-   로그인 후 상단 오른쪽 끝 메뉴 “Tokens” 페이지로 이동

-   페이지에서 Show를 통해 인증 토큰(Token)과 Secret 확보: Show secret를 클릭하여 secret까지 보이게 한 후 복사하기

셋째, RStudio에 토큰을 설정한다. 단 한 번만 하면 된다.

-   R 콘솔에 위에서 복사한 내용 붙여넣기 및 실행

넷째, Publish 버튼 클릭

-   스크립트 윈도우의 오른쪽 상단에 있는 Publish 버튼 클릭

-   배포를 원하는 R 파일만 선택

다섯째, URL을 얻는다. 다음의 형식으로 생성된다.

-   https://userid.shinyapps.io/project_name/

### Quarto와 Shiny의 결합

-   상황: Quarto 대시보드의 일부 영역에서 Shiny 사용

-   두 가지 접근

    -   Shiny 중심 방식: Shiny 웹 앱의 생성

        -   Quarto 대시보드 내에서 Quarto 문법으로 Shiny 웹 앱 구축

        -   Quarto 대시보드 전체가 Shiny 웹 앱화: shinyapps.io를 통해 배포

        -   사례: <https://sangillee.shinyapps.io/Dashboard_Example/>

    -   Quarto 중심 방식: Quarto 대시보드의 유지

        -   Quarto 대시보드 속에 독립적으로 구축된 Shiny 웹 앱 임베딩

        -   여전히 Quarto 대시보드: Quarto Pub을 통해 배포

        -   사례: <https://sangillee.snu.ac.kr/dashboard_examples/>

#### Shiny 중심 방식

-   옵션 1: Quarto를 Shiny 웹 앱의 레이아웃 설정 도구로 사용

    -   **shiny** 패키지: [`fluidPage()`](https://rdrr.io/pkg/shiny/man/fluidPage.html)

        -   [`titlePanel()`](https://rdrr.io/pkg/shiny/man/titlePanel.html), `SidebarLayout()`, [`sidebarPanel()`](https://rdrr.io/pkg/shiny/man/sidebarLayout.html), [`mainPanel()`](https://rdrr.io/pkg/shiny/man/sidebarLayout.html)

    -   **bslib** 패키지: [`page_sidebar()`](https://rstudio.github.io/bslib/reference/page_sidebar.html)

        -   `sidebar = sidebar()`, [`card()`](https://rstudio.github.io/bslib/reference/card.html)

-   옵션 2: Quarto 대시보드 내에서 Shiny 웹 앱 구축

-   <https://quarto.org/docs/dashboards/interactivity/shiny-r.html>

-   YAML 헤더에 다음 첨가: `server: shiny`

-   ui 부분: 기본적으로는 `r` 코드 청크 속에 포함, 사이드바와 메인 병렬

    -   사이드바: 레이아웃 구성요소에 넣고 `{.sidebar}` CSS 클래스 지정 가능

    -   메인: 사이드바와 다른 레이아웃 구성요소에 넣기 가능

-   server 부분: `r` 코드 청크 속에 포함, 다음 지정

    -   `#| context: server` 지정

-   기타(패키지, 데이터 등) 부분: `r` 코드 청크 속에 포함, 다음 지정

    -   `#| context: setup`

    -   `#| include: false`

#### Quarto 중심 방식

-   보통 하나의 row에 임베딩

-   `src=""` 부분만 교체

```         
<iframe src="https://..." loading="lazy" style="width: 100%; height: 600px; border: 0px none;" allow="web-share; clipboard-write"></iframe>
```

## 고차 주제

### LLM-기반 ChatBot 웹 앱
