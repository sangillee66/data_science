{
  "hash": "a953d691fb1b749ab38f9b8c73700736",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"데이터 변형하기\"\nauthor: 이상일(서울대학교 지리교육과)\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\nlightbox: true\neditor: visual\nbibliography: references.bib\neditor_options: \n  chunk_output_type: console\n---\n\n\n## 실습 개요 {.unnumbered}\n\n이 실습은 R로 데이터사이언스를 하는 과정 중 데이터 변형하기(transforming)를 다룬다. 데이터 변형하기와 관련된 대부분의 함수는 [`tidyverse`](https://www.tidyverse.org/)의 핵심 패키지 중의 하나인 [`dplyr`](https://dplyr.tidyverse.org/) 에서 제공된다. 데이터 변형하기와 관련된 함수는 크게 네 개로 범주화된다.\n\n-   행 함수: 행(관측개체)에 작동하는 함수, 즉 행의 변화를 야기하는 함수\n\n-   열 함수: 열(변수)에 작동하는 함수, 즉 열의 변화를 야기하는 함수\n\n-   그룹 함수: 그룹에 작동하는 함수\n\n-   데이터 프레임 함수: 데이터 프레임 전체에 작동하는 함수\n\n이번 실습에서는 행 함수, 열 함수, 그룹 함수에 집중한다. 모든 실습의 시작은 [`tidyverse`](https://www.tidyverse.org/) 패키지를 불러오는 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n사용할 데이터는 World Bank가 [gapmider.org](https://www.gapminder.org/)를 통해 무료로 배포하는 것으로 [`gapmider`](https://cran.r-project.org/web/packages/gapminder/readme/README.html) 패키지에 포함되어 있다. [`gapmider`](https://cran.r-project.org/web/packages/gapminder/readme/README.html) 패키지를 인스톨하고 불러온다. 데이터가 어떻게 구성되어 있는지 살펴본다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gapminder)\ngapminder\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n## 단일 테이블 조작\n\n### 행 함수\n\n#### `filter()` 함수\n\n특정 열(변수)과 관련된 조건을 만족하는 행을 선정한다. 행의 길이가 준다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  filter(continent == \"Europe\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 360 × 6\n   country continent  year lifeExp     pop gdpPercap\n   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n 1 Albania Europe     1952    55.2 1282697     1601.\n 2 Albania Europe     1957    59.3 1476505     1942.\n 3 Albania Europe     1962    64.8 1728137     2313.\n 4 Albania Europe     1967    66.2 1984060     2760.\n 5 Albania Europe     1972    67.7 2263554     3313.\n 6 Albania Europe     1977    68.9 2509048     3533.\n 7 Albania Europe     1982    70.4 2780097     3631.\n 8 Albania Europe     1987    72   3075321     3739.\n 9 Albania Europe     1992    71.6 3326498     2497.\n10 Albania Europe     1997    73.0 3428038     3193.\n# ℹ 350 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  filter(pop > 50000000 & gdpPercap > 30000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 6\n  country        continent  year lifeExp       pop gdpPercap\n  <fct>          <fct>     <int>   <dbl>     <int>     <dbl>\n1 France         Europe     2007    80.7  61083916    30470.\n2 Germany        Europe     2002    78.7  82350671    30036.\n3 Germany        Europe     2007    79.4  82400996    32170.\n4 Japan          Asia       2007    82.6 127467972    31656.\n5 United Kingdom Europe     2007    79.4  60776238    33203.\n6 United States  Americas   1992    76.1 256894189    32004.\n7 United States  Americas   1997    76.8 272911760    35767.\n8 United States  Americas   2002    77.3 287675526    39097.\n9 United States  Americas   2007    78.2 301139947    42952.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  filter(year == 2007 & (lifeExp > 82 | gdpPercap > 40000))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  <fct>            <fct>     <int>   <dbl>     <int>     <dbl>\n1 Hong Kong, China Asia       2007    82.2   6980412    39725.\n2 Ireland          Europe     2007    78.9   4109086    40676.\n3 Japan            Asia       2007    82.6 127467972    31656.\n4 Kuwait           Asia       2007    77.6   2505559    47307.\n5 Norway           Europe     2007    80.2   4627926    49357.\n6 Singapore        Asia       2007    80.0   4553009    47143.\n7 United States    Americas   2007    78.2 301139947    42952.\n```\n\n\n:::\n:::\n\n\n#### `slice()` 함수\n\n`filter()` 함수와 마찬가지로 행의 숫자를 줄인다. `slice()` 함수 자체 보다는 `slice_head()`, `slice_tail()`, `slice_max()`, `slice_min()`과 같은 패밀리 함수가 더 널리 사용된다. 그런데 이 함수들은 작동 방식에 따라 두 가지로 구분된다.\n\n-   특정 열(변수)과 관계 없이, 행의 위치에 의거해 행을 선정: `slice()`, `slice_head()`, `slice_tail()`\n\n-   특정 열(변수)에 따른, 행의 위치에 의거해 행을 선정: `slice_max()`, `slice_min()`\n\n몇 번째에서 몇 번째 사이의 행만을 골라낸다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  slice(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n```\n\n\n:::\n:::\n\n\n가장 앞에 위치한 몇 개(`n`)의 행만을 골라낸다. 실질적으로 위와 동일하다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  slice_head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n```\n\n\n:::\n:::\n\n\n가장 뒤에 위치한 몇 개(`n`)의 행만을 골라낸다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  slice_tail(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  <fct>    <fct>     <int>   <dbl>    <int>     <dbl>\n1 Zimbabwe Africa     1987    62.4  9216418      706.\n2 Zimbabwe Africa     1992    60.4 10704340      693.\n3 Zimbabwe Africa     1997    46.8 11404948      792.\n4 Zimbabwe Africa     2002    40.0 11926563      672.\n5 Zimbabwe Africa     2007    43.5 12311143      470.\n```\n\n\n:::\n:::\n\n\n특정 열(변수)에 따라 값이 가장 큰 몇 개(`n`)의 행만을 골라낸다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  filter(year == 2007) |> \n  slice_max(gdpPercap, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  country       continent  year lifeExp       pop gdpPercap\n  <fct>         <fct>     <int>   <dbl>     <int>     <dbl>\n1 Norway        Europe     2007    80.2   4627926    49357.\n2 Kuwait        Asia       2007    77.6   2505559    47307.\n3 Singapore     Asia       2007    80.0   4553009    47143.\n4 United States Americas   2007    78.2 301139947    42952.\n5 Ireland       Europe     2007    78.9   4109086    40676.\n```\n\n\n:::\n:::\n\n\n특정 열(변수)에 따라 값이 가장 작은 것들 중 주어진 비중(`prop`) 만큼의 행만을 골라낸다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  filter(year == 2007 & continent == \"Asia\") |> \n  slice_min(lifeExp, prop = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       2007    43.8 31889923      975.\n2 Iraq        Asia       2007    59.5 27499638     4471.\n3 Cambodia    Asia       2007    59.7 14131858     1714.\n```\n\n\n:::\n:::\n\n\n::: callout-note\n`slice` 함수는 데이터 프레임이 적용되는 것으로 모두 데이터 프레임을 산출한다. 그런데 유사한 작업을 벡터에 적용하는 함수들이 존재한다. `slice_head()`, `slice_tail()`, `slice()`에 대응하는 `dplyr` 벡터 함수로 `first()`, `last()`, `nth()`가 있다. 그런데 후자의 함수를 벡터가 아닌 데이터 프레임이 적용하면 slice 함수와 동일한 결과가 산출된다.\n:::\n\n#### `arrange()` 함수\n\n특정 열(변수)과 관련된 조건에 의거해 행의 순서를 바꾼다. 행의 길이에는 변화가 없다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  arrange(lifeExp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country      continent  year lifeExp     pop gdpPercap\n   <fct>        <fct>     <int>   <dbl>   <int>     <dbl>\n 1 Rwanda       Africa     1992    23.6 7290203      737.\n 2 Afghanistan  Asia       1952    28.8 8425333      779.\n 3 Gambia       Africa     1952    30    284320      485.\n 4 Angola       Africa     1952    30.0 4232095     3521.\n 5 Sierra Leone Africa     1952    30.3 2143249      880.\n 6 Afghanistan  Asia       1957    30.3 9240934      821.\n 7 Cambodia     Asia       1977    31.2 6978607      525.\n 8 Mozambique   Africa     1952    31.3 6446316      469.\n 9 Sierra Leone Africa     1957    31.6 2295678     1004.\n10 Burkina Faso Africa     1952    32.0 4469979      543.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n`desc()` 보조 함수(helper function)는 내림차순으로 행을 배열한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  arrange(lifeExp, desc(year))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country      continent  year lifeExp     pop gdpPercap\n   <fct>        <fct>     <int>   <dbl>   <int>     <dbl>\n 1 Rwanda       Africa     1992    23.6 7290203      737.\n 2 Afghanistan  Asia       1952    28.8 8425333      779.\n 3 Gambia       Africa     1952    30    284320      485.\n 4 Angola       Africa     1952    30.0 4232095     3521.\n 5 Sierra Leone Africa     1952    30.3 2143249      880.\n 6 Afghanistan  Asia       1957    30.3 9240934      821.\n 7 Cambodia     Asia       1977    31.2 6978607      525.\n 8 Mozambique   Africa     1952    31.3 6446316      469.\n 9 Sierra Leone Africa     1957    31.6 2295678     1004.\n10 Burkina Faso Africa     1952    32.0 4469979      543.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n#### `distinct()` 함수\n\n특정 열(변수)에 의거해 중복이 없이 고유한 행만을 골라낸다. 행의 길이가 준다.\n\n`gapminder` 데이터와 관련하여 다음의 코드는 어떤 정보를 우리에게 주는지 생각해 본다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  distinct(country)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 142 × 1\n   country    \n   <fct>      \n 1 Afghanistan\n 2 Albania    \n 3 Algeria    \n 4 Angola     \n 5 Argentina  \n 6 Australia  \n 7 Austria    \n 8 Bahrain    \n 9 Bangladesh \n10 Belgium    \n# ℹ 132 more rows\n```\n\n\n:::\n:::\n\n\n`.keep_all` 아규먼트를 이용하면 나머지 열도 함께 나타낼 수 있다. 나머지 열의 값이 무엇인지 생각해 본다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  distinct(continent, .keep_all = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Albania     Europe     1952    55.2  1282697     1601.\n3 Algeria     Africa     1952    43.1  9279525     2449.\n4 Argentina   Americas   1952    62.5 17876956     5911.\n5 Australia   Oceania    1952    69.1  8691212    10040.\n```\n\n\n:::\n:::\n\n\n### 열 함수\n\n#### `select()` 함수\n\n열(변수)의 일부를 선택한다. 열의 길이가 준다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  select(year, country, gdpPercap)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 3\n    year country     gdpPercap\n   <int> <fct>           <dbl>\n 1  1952 Afghanistan      779.\n 2  1957 Afghanistan      821.\n 3  1962 Afghanistan      853.\n 4  1967 Afghanistan      836.\n 5  1972 Afghanistan      740.\n 6  1977 Afghanistan      786.\n 7  1982 Afghanistan      978.\n 8  1987 Afghanistan      852.\n 9  1992 Afghanistan      649.\n10  1997 Afghanistan      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n열(변수)의 일부를 선택하지 않는다. 역시 열의 길이가 준다. 실질적으로 위와 동일한 결과가 산출된다. `!` 부호 대신 `-` 부호를 사용할 수 있다. 전자가 선호된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  select(!c(lifeExp, continent, pop))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 3\n   country      year gdpPercap\n   <fct>       <int>     <dbl>\n 1 Afghanistan  1952      779.\n 2 Afghanistan  1957      821.\n 3 Afghanistan  1962      853.\n 4 Afghanistan  1967      836.\n 5 Afghanistan  1972      740.\n 6 Afghanistan  1977      786.\n 7 Afghanistan  1982      978.\n 8 Afghanistan  1987      852.\n 9 Afghanistan  1992      649.\n10 Afghanistan  1997      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n`starts_with()`, `ends_with()`, `contains()`와 같은 보조 함수를 잘 활용하면 효율적으로 필요한 변수만을 선정할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  select(starts_with(\"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 2\n   country     continent\n   <fct>       <fct>    \n 1 Afghanistan Asia     \n 2 Afghanistan Asia     \n 3 Afghanistan Asia     \n 4 Afghanistan Asia     \n 5 Afghanistan Asia     \n 6 Afghanistan Asia     \n 7 Afghanistan Asia     \n 8 Afghanistan Asia     \n 9 Afghanistan Asia     \n10 Afghanistan Asia     \n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n#### `mutate()` 함수\n\n기존의 열(변수)에 기반하여 새로운 변수를 생성한다. 열의 길이가 늘어난다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  mutate(\n    gdp_billion = gdpPercap * pop / 10^9\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap gdp_billion\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>       <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.        6.57\n 2 Afghanistan Asia       1957    30.3  9240934      821.        7.59\n 3 Afghanistan Asia       1962    32.0 10267083      853.        8.76\n 4 Afghanistan Asia       1967    34.0 11537966      836.        9.65\n 5 Afghanistan Asia       1972    36.1 13079460      740.        9.68\n 6 Afghanistan Asia       1977    38.4 14880372      786.       11.7 \n 7 Afghanistan Asia       1982    39.9 12881816      978.       12.6 \n 8 Afghanistan Asia       1987    40.8 13867957      852.       11.8 \n 9 Afghanistan Asia       1992    41.7 16317921      649.       10.6 \n10 Afghanistan Asia       1997    41.8 22227415      635.       14.1 \n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n여러개의 변수를 동시에 생성할 수 있다. `row_number()` 보조 함수는 값에 순위를 부여하는 것이고, `.keep = \"used\"`는 결과에 변수 생성에 동원된 변수만을 포함시키게 해 준다.\\\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  filter(year == 2007) |> \n  mutate(\n    gdpPercap_rank = row_number(gdpPercap),\n    lifeExp_highlow = lifeExp > 30000,\n    .keep = \"used\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 142 × 4\n   lifeExp gdpPercap gdpPercap_rank lifeExp_highlow\n     <dbl>     <dbl>          <int> <lgl>          \n 1    43.8      975.             19 FALSE          \n 2    76.4     5937.             70 FALSE          \n 3    72.3     6223.             72 FALSE          \n 4    42.7     4797.             64 FALSE          \n 5    75.3    12779.            101 FALSE          \n 6    81.2    34435.            130 FALSE          \n 7    79.8    36126.            132 FALSE          \n 8    75.6    29796.            122 FALSE          \n 9    64.1     1391.             30 FALSE          \n10    79.4    33693.            128 FALSE          \n# ℹ 132 more rows\n```\n\n\n:::\n:::\n\n\n::: callout-note\n`dplyr` 패키지는 데이터에 순위를 부여하는 다섯 가지 서로 다른 방식을 제공한다.\n\n-   `row_number()`: 동일값이라 하더라도 값의 등장 순서에 따라 서로 다른 순위를 부여한다. 이런 이유로 일련번호로 새로운 컬럼(변수)을 만들 때 사용되기도 한다.\n\n-   `min_rank()`: 동일값에 동순위를 부여하고, 그 다음 값에는 동순위 갯수를 감안한 그 다음 순위를 부여한다. 예를 들어, 두 번째로 작은 값이 두개인 경우 결과는 1, 2, 2, 4, 5\n\n-   `dense_rank()`: 동일값에 동순위를 부여하고, 그 다음 값에는 동순위 갯수에 상관없이 바로 그 다음 순위를 부여한다 예를 들어, 두 번째로 작은 값이 두개인 경우 결과는 1, 2, 2, 3, 4\n\n-   `percent_rank()`: 백분위수(percentile)을 계산해 주는데, 해당 값보다 작은 값의 개수를 전체 개수에서 1을 뺀 값으로 나눈값을 산출한다.\n\n-   cumu_dist(): 백분위수(percentile)을 계산해 주는데, 해당 값보다 작거나 같은 값의 개수를 전체 개수로 나눈값을 산출한다.\n:::\n\n#### `rename()` 함수\n\n변수의 이름을 바꾼다. 열의 길이에는 변화가 없다. `=` 부호의 왼쪽에 있는 것이 새로운 변수명이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  rename(\n    gdp_percap = gdpPercap,\n    left_exp = lifeExp\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year left_exp      pop gdp_percap\n   <fct>       <fct>     <int>    <dbl>    <int>      <dbl>\n 1 Afghanistan Asia       1952     28.8  8425333       779.\n 2 Afghanistan Asia       1957     30.3  9240934       821.\n 3 Afghanistan Asia       1962     32.0 10267083       853.\n 4 Afghanistan Asia       1967     34.0 11537966       836.\n 5 Afghanistan Asia       1972     36.1 13079460       740.\n 6 Afghanistan Asia       1977     38.4 14880372       786.\n 7 Afghanistan Asia       1982     39.9 12881816       978.\n 8 Afghanistan Asia       1987     40.8 13867957       852.\n 9 Afghanistan Asia       1992     41.7 16317921       649.\n10 Afghanistan Asia       1997     41.8 22227415       635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n패밀리 함수인 `rename_with()`를 이용하면 다른 것도 가능하다. `tolower`은 변수명을 소문자로 바꾸는 보조 함수이고, `toupper`은 대문자로 바꾸는 보조 함수이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  rename_with(\n    tolower, starts_with(\"l\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeexp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n#### `relocate()` 함수\n\n변수의 위치를 바꾼다. 열의 길이에는 변화가 없다. 기입한 변수들이 맨 앞으로 이동한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  relocate(year, continent)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n    year continent country     lifeExp      pop gdpPercap\n   <int> <fct>     <fct>         <dbl>    <int>     <dbl>\n 1  1952 Asia      Afghanistan    28.8  8425333      779.\n 2  1957 Asia      Afghanistan    30.3  9240934      821.\n 3  1962 Asia      Afghanistan    32.0 10267083      853.\n 4  1967 Asia      Afghanistan    34.0 11537966      836.\n 5  1972 Asia      Afghanistan    36.1 13079460      740.\n 6  1977 Asia      Afghanistan    38.4 14880372      786.\n 7  1982 Asia      Afghanistan    39.9 12881816      978.\n 8  1987 Asia      Afghanistan    40.8 13867957      852.\n 9  1992 Asia      Afghanistan    41.7 16317921      649.\n10  1997 Asia      Afghanistan    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n`.before`나 `.after` 아규먼트를 사용하여 해당 변수를 어떤 변수의 앞이나 뒤로 보낼 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  relocate(pop, .before = lifeExp )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year      pop lifeExp gdpPercap\n   <fct>       <fct>     <int>    <int>   <dbl>     <dbl>\n 1 Afghanistan Asia       1952  8425333    28.8      779.\n 2 Afghanistan Asia       1957  9240934    30.3      821.\n 3 Afghanistan Asia       1962 10267083    32.0      853.\n 4 Afghanistan Asia       1967 11537966    34.0      836.\n 5 Afghanistan Asia       1972 13079460    36.1      740.\n 6 Afghanistan Asia       1977 14880372    38.4      786.\n 7 Afghanistan Asia       1982 12881816    39.9      978.\n 8 Afghanistan Asia       1987 13867957    40.8      852.\n 9 Afghanistan Asia       1992 16317921    41.7      649.\n10 Afghanistan Asia       1997 22227415    41.8      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n#### `pull()` 함수\n\n데이터 프레임의 한 컬럼을 벡터로 추출한다.\n\n### 그룹 함수\n\n#### `group_by()` 함수\n\n특정 범주 열(변수)에 의거해 행을 분할한다. 행의 길이는 변하지 않는다.\n\n우선 하나의 범주 변수에 의거해 그룹화한다. 산출물을 보면 `year`에 의거해 행이 12개의 그룹으로 나누어졌음을 알 수 있다(두 번째 줄: Group: year \\[12\\]).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  group_by(year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n# Groups:   year [12]\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n두 개 이상의 범주 변수에 의거해 그룹화할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  group_by(year, continent)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n# Groups:   year, continent [60]\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n#### `summarize()` 함수\n\n주어진 열(변수)에 대한 통계 요약값을 계산하고 그것으로 이루어진 새로운 데이터 프레임을 생성한다. 엄밀히 말해 기존 열(변수)을 변형한다기 보다는 기존 데이터 프레임으로부터 새로운 데이터 프레임을 생성한다고 볼 수 있다. `summarize()` 함수는 대부분의 경우 `group_by()` 함수와 함께 사용된다. 다음의 둘을 비교해 보라.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  filter(year == 2007) |> \n  summarize(\n    mean_gdpPercap = mean(gdpPercap)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  mean_gdpPercap\n           <dbl>\n1         11680.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  filter(year == 2007) |> \n  group_by(continent) |> \n  summarize(\n    mean_gdpPercap = mean(gdpPercap)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  continent mean_gdpPercap\n  <fct>              <dbl>\n1 Africa             3089.\n2 Americas          11003.\n3 Asia              12473.\n4 Europe            25054.\n5 Oceania           29810.\n```\n\n\n:::\n:::\n\n\n좀 더 복잡한 확장이 가능하다. 마지막의 `n()`은 특별한 요약 함수로, 어떤 아규먼트도 없이 단독으로 사용되며 \"현재(current)\" 그룹의 빈도값을 산출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n    group_by(continent, year) |> \n    summarize(\n      mean_gdpPercap = mean(gdpPercap),\n      sd_gdpPercap = sd(gdpPercap),\n      mean_pop = mean(pop),\n      sd_pop = sd(pop),\n      n = n()\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 7\n# Groups:   continent [5]\n   continent  year mean_gdpPercap sd_gdpPercap  mean_pop    sd_pop     n\n   <fct>     <int>          <dbl>        <dbl>     <dbl>     <dbl> <int>\n 1 Africa     1952          1253.         983.  4570010.  6317450.    52\n 2 Africa     1957          1385.        1135.  5093033.  7076042.    52\n 3 Africa     1962          1598.        1462.  5702247.  7957545.    52\n 4 Africa     1967          2050.        2848.  6447875.  8985505.    52\n 5 Africa     1972          2340.        3287.  7305376. 10130833.    52\n 6 Africa     1977          2586.        4142.  8328097. 11585184.    52\n 7 Africa     1982          2482.        3243.  9602857. 13456243.    52\n 8 Africa     1987          2283.        2567. 11054502. 15277484.    52\n 9 Africa     1992          2282.        2644. 12674645. 17562719.    52\n10 Africa     1997          2379.        2821. 14304480. 19873013.    52\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n`group_by()`와 `arrange()`를 결합하는 경우, `.by_group = TRUE`를 하면 그룹별로 행을 배열할 수 있다(그렇지 않으면 그룹 설정을 무시한 채 행을 배열한다.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  group_by(year, continent) |> \n  arrange(desc(gdpPercap), .by_group = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n# Groups:   year, continent [60]\n   country      continent  year lifeExp      pop gdpPercap\n   <fct>        <fct>     <int>   <dbl>    <int>     <dbl>\n 1 South Africa Africa     1952    45.0 14264935     4725.\n 2 Gabon        Africa     1952    37.0   420702     4293.\n 3 Angola       Africa     1952    30.0  4232095     3521.\n 4 Reunion      Africa     1952    52.7   257700     2719.\n 5 Djibouti     Africa     1952    34.8    63149     2670.\n 6 Algeria      Africa     1952    43.1  9279525     2449.\n 7 Namibia      Africa     1952    41.7   485831     2424.\n 8 Libya        Africa     1952    42.7  1019729     2388.\n 9 Congo, Rep.  Africa     1952    42.1   854885     2126.\n10 Mauritius    Africa     1952    51.0   516556     1968.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n아래는 연도별/대륙별로 일인당 GDP가 가장 높은 국가를 추출한 것이다. 코드를 생각해 보라.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 6\n# Groups:   year, continent [60]\n   country       continent  year lifeExp       pop gdpPercap\n   <fct>         <fct>     <int>   <dbl>     <int>     <dbl>\n 1 South Africa  Africa     1952    45.0  14264935     4725.\n 2 United States Americas   1952    68.4 157553000    13990.\n 3 Kuwait        Asia       1952    55.6    160000   108382.\n 4 Switzerland   Europe     1952    69.6   4815000    14734.\n 5 New Zealand   Oceania    1952    69.4   1994794    10557.\n 6 South Africa  Africa     1957    48.0  16151549     5487.\n 7 United States Americas   1957    69.5 171984000    14847.\n 8 Kuwait        Asia       1957    58.0    212846   113523.\n 9 Switzerland   Europe     1957    70.6   5126000    17909.\n10 New Zealand   Oceania    1957    70.3   2229407    12247.\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n`group_by()` 함수가 한 번 적용되면, 그 뒤의 모든 오퍼레이션에 그룹 분할이 적용되기 때문에 예기치 못한 일이 발생할 수 있다. 이것을 회피하기 위해 두 가지 옵션이 있다. 첫번째 방법은 마지막에 `upgroup()` 함수를 첨가하는 것이다. 아래에 위 질문에 대한 정답이 나타나 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  group_by(year, continent) |> \n  slice_max(gdpPercap) |> \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 6\n   country       continent  year lifeExp       pop gdpPercap\n   <fct>         <fct>     <int>   <dbl>     <int>     <dbl>\n 1 South Africa  Africa     1952    45.0  14264935     4725.\n 2 United States Americas   1952    68.4 157553000    13990.\n 3 Kuwait        Asia       1952    55.6    160000   108382.\n 4 Switzerland   Europe     1952    69.6   4815000    14734.\n 5 New Zealand   Oceania    1952    69.4   1994794    10557.\n 6 South Africa  Africa     1957    48.0  16151549     5487.\n 7 United States Americas   1957    69.5 171984000    14847.\n 8 Kuwait        Asia       1957    58.0    212846   113523.\n 9 Switzerland   Europe     1957    70.6   5126000    17909.\n10 New Zealand   Oceania    1957    70.3   2229407    12247.\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n두 번째 방법은 `group_by()` 함수 대신 `by` 아규먼트를 사용하는 것이다. 결과가 달라보이겠지만 정렬의 차이일 뿐 동일하다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  slice_max(\n    gdpPercap, \n    by = c(year, continent)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 6\n   country      continent  year lifeExp      pop gdpPercap\n   <fct>        <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Kuwait       Asia       1952    55.6   160000   108382.\n 2 Kuwait       Asia       1957    58.0   212846   113523.\n 3 Kuwait       Asia       1962    60.5   358266    95458.\n 4 Kuwait       Asia       1967    64.6   575003    80895.\n 5 Kuwait       Asia       1972    67.7   841934   109348.\n 6 Kuwait       Asia       1977    69.3  1140357    59265.\n 7 Saudi Arabia Asia       1982    63.0 11254672    33693.\n 8 Kuwait       Asia       1987    74.2  1891487    28118.\n 9 Kuwait       Asia       1992    75.2  1418095    34933.\n10 Kuwait       Asia       1997    76.2  1765345    40301.\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n#### `count()` 함수\n\n특정 범주 열(변수)에 의거한 빈도를 빠르게 계산해 준다. 빈도는 자동적으로 `n`이라는 이럼의 컬럼에 저장된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  count(year, continent)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 3\n    year continent     n\n   <int> <fct>     <int>\n 1  1952 Africa       52\n 2  1952 Americas     25\n 3  1952 Asia         33\n 4  1952 Europe       30\n 5  1952 Oceania       2\n 6  1957 Africa       52\n 7  1957 Americas     25\n 8  1957 Asia         33\n 9  1957 Europe       30\n10  1957 Oceania       2\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n`wt` 아규먼트를 사용하면 빈도가 아니라 범주별 특정 변수의 합산값을 구할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  count(year, continent, wt = pop)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 3\n    year continent          n\n   <int> <fct>          <dbl>\n 1  1952 Africa     237640501\n 2  1952 Americas   345152446\n 3  1952 Asia      1395357351\n 4  1952 Europe     418120846\n 5  1952 Oceania     10686006\n 6  1957 Africa     264837738\n 7  1957 Americas   386953916\n 8  1957 Asia      1562780599\n 9  1957 Europe     437890351\n10  1957 Oceania     11941976\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n위의 두 개는 사실 아래와 동일하다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  group_by(year, continent) |> \n  summarize(\n    n = n(),\n    sum_pop = sum(pop)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent     n    sum_pop\n   <int> <fct>     <int>      <dbl>\n 1  1952 Africa       52  237640501\n 2  1952 Americas     25  345152446\n 3  1952 Asia         33 1395357351\n 4  1952 Europe       30  418120846\n 5  1952 Oceania       2   10686006\n 6  1957 Africa       52  264837738\n 7  1957 Americas     25  386953916\n 8  1957 Asia         33 1562780599\n 9  1957 Europe       30  437890351\n10  1957 Oceania       2   11941976\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n#### `across()` 함수\n\n다수의 열(변수)에 동일한 함수를 적용할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  mutate(\n    across(c(lifeExp, gdpPercap), round)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952      29  8425333       779\n 2 Afghanistan Asia       1957      30  9240934       821\n 3 Afghanistan Asia       1962      32 10267083       853\n 4 Afghanistan Asia       1967      34 11537966       836\n 5 Afghanistan Asia       1972      36 13079460       740\n 6 Afghanistan Asia       1977      38 14880372       786\n 7 Afghanistan Asia       1982      40 12881816       978\n 8 Afghanistan Asia       1987      41 13867957       852\n 9 Afghanistan Asia       1992      42 16317921       649\n10 Afghanistan Asia       1997      42 22227415       635\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n이것은 다음과 동일하다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  mutate(\n    lifeExp = round(lifeExp),\n    gdpPercap = round(gdpPercap)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952      29  8425333       779\n 2 Afghanistan Asia       1957      30  9240934       821\n 3 Afghanistan Asia       1962      32 10267083       853\n 4 Afghanistan Asia       1967      34 11537966       836\n 5 Afghanistan Asia       1972      36 13079460       740\n 6 Afghanistan Asia       1977      38 14880372       786\n 7 Afghanistan Asia       1982      40 12881816       978\n 8 Afghanistan Asia       1987      41 13867957       852\n 9 Afghanistan Asia       1992      42 16317921       649\n10 Afghanistan Asia       1997      42 22227415       635\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n`summarize()` 함수와 결합하여 선택된 변수에 특정 함수를 적용하고 그 결과의 이름을 변수명과 함수명을 사용하여 부여할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  group_by(year, continent) |> \n  summarize(\n    across(\n      c(lifeExp, gdpPercap), \n      mean, \n      .names = \"mean_{.col}\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent mean_lifeExp mean_gdpPercap\n   <int> <fct>            <dbl>          <dbl>\n 1  1952 Africa            39.1          1253.\n 2  1952 Americas          53.3          4079.\n 3  1952 Asia              46.3          5195.\n 4  1952 Europe            64.4          5661.\n 5  1952 Oceania           69.3         10298.\n 6  1957 Africa            41.3          1385.\n 7  1957 Americas          56.0          4616.\n 8  1957 Asia              49.3          5788.\n 9  1957 Europe            66.7          6963.\n10  1957 Oceania           70.3         11599.\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n`across()` 함수에서 중요한 것은 함수 아규먼트에 함수명 그 자체만 쓸 수 있을 뿐(즉, `mean`), 함수명 뒤에 `()`가 붙을 수 없다. 예를 들어 mean() 함수의 매우 중요한 아규먼트인 na.rm을 사용할 수 없다. 위의 예에서 두 변수 중 어느 변수에라도 결측값이 포함되어 있었다면 에러가 발생했을 것이다. 이 문제는 다음과 같은 방식으로 해결할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  group_by(year, continent) |> \n  summarize(\n    across(\n      c(lifeExp, gdpPercap), \n      function(x) median(x, na.rm = TRUE)\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent lifeExp gdpPercap\n   <int> <fct>       <dbl>     <dbl>\n 1  1952 Africa       38.8      987.\n 2  1952 Americas     54.7     3048.\n 3  1952 Asia         44.9     1207.\n 4  1952 Europe       65.9     5142.\n 5  1952 Oceania      69.3    10298.\n 6  1957 Africa       40.6     1024.\n 7  1957 Americas     56.1     3781.\n 8  1957 Asia         48.3     1548.\n 9  1957 Europe       67.6     6067.\n10  1957 Oceania      70.3    11599.\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n혹은 보다 간단하게 `function()`을 `\\()`로 대체할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  group_by(year, continent) |> \n  summarize(\n    across(\n      c(lifeExp, gdpPercap), \n      \\(x) median(x, na.rm = TRUE)\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent lifeExp gdpPercap\n   <int> <fct>       <dbl>     <dbl>\n 1  1952 Africa       38.8      987.\n 2  1952 Americas     54.7     3048.\n 3  1952 Asia         44.9     1207.\n 4  1952 Europe       65.9     5142.\n 5  1952 Oceania      69.3    10298.\n 6  1957 Africa       40.6     1024.\n 7  1957 Americas     56.1     3781.\n 8  1957 Asia         48.3     1548.\n 9  1957 Europe       67.6     6067.\n10  1957 Oceania      70.3    11599.\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n만일 `across()` 함수 속에서 두 개 이상의 함수를 적용한다면 `list()`를 활용해야 한다. 결과에 새로 생성된 변수명이 원변수명_함수명(`{.col}_{.fn}`)의 형태를 띠고 있음에 주목하라. 사실 이것은 across() 함수 속에 `.names = \"{.col}_{.fn}\"`라고 지정한 것과 동일한 것으로, 만일 `.names = \"{.fn}_{.col}\"` 이라고 지정하면 다른 결과가 나타날 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  group_by(year, continent) |> \n  summarize(\n    across(\n      c(lifeExp, gdpPercap), \n      list(\n        mean = \\(x) mean(x, na.rm = TRUE),\n        median = \\(x) median(x, na.rm = TRUE)\n      )\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 6\n# Groups:   year [12]\n    year continent lifeExp_mean lifeExp_median gdpPercap_mean gdpPercap_median\n   <int> <fct>            <dbl>          <dbl>          <dbl>            <dbl>\n 1  1952 Africa            39.1           38.8          1253.             987.\n 2  1952 Americas          53.3           54.7          4079.            3048.\n 3  1952 Asia              46.3           44.9          5195.            1207.\n 4  1952 Europe            64.4           65.9          5661.            5142.\n 5  1952 Oceania           69.3           69.3         10298.           10298.\n 6  1957 Africa            41.3           40.6          1385.            1024.\n 7  1957 Americas          56.0           56.1          4616.            3781.\n 8  1957 Asia              49.3           48.3          5788.            1548.\n 9  1957 Europe            66.7           67.6          6963.            6067.\n10  1957 Oceania           70.3           70.3         11599.           11599.\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n`across()` 함수의 파생 함수로 `if_any()`와 `if_all()`이 있다. 두 함수 모두 매우 유용하지만 여기서는 다루지 않는다.\n\n#### `c_across()` 함수\n\n`group_by()` 함수와 `across()` 함수가 결합하는 것과 정반대로, `rowwise()` 함수와 `c_across()` 함수를 결합하며, 행별 통계값을 산출할 수 있다. 물론 여기서 `each_sd` 값은 아무런 의미가 없다. 행별로 수치형 변수(year, lifeExp, pop, gdpPercap)의 표준편차를 구한 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |> \n  rowwise() |> \n  mutate(\n    each_sd = sd(c_across(where(is.numeric)))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 7\n# Rowwise: \n   country     continent  year lifeExp      pop gdpPercap   each_sd\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.  4212207.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  4619999.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  5133067.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  5768510.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  6539272.\n 6 Afghanistan Asia       1977    38.4 14880372      786.  7439719.\n 7 Afghanistan Asia       1982    39.9 12881816      978.  6440408.\n 8 Afghanistan Asia       1987    40.8 13867957      852.  6933499.\n 9 Afghanistan Asia       1992    41.7 16317921      649.  8158513.\n10 Afghanistan Asia       1997    41.8 22227415      635. 11113262.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n## 데이터 결합하기\n\n### 테이블 조인\n\n여기서는 데이트 프레임을 결합하여 새로운 데이터 프레임을 생성하는 과정에 대해 살펴본다. `tidyverse` 패키지에 포함되어 있는 `dplyr` 패키지는 다양한 종류의 조인(join) 함수를 제공한다.\n\n-   `left_join()`: 첫 번째 변수는 그대로 둔 상태에서 두 번째 변수를 결합함으로써 두 번째 변수의 열을 가져옴\n\n-   `right_join()`: 두 번째 변수는 그대로 둔 상태에서 첫 번째 변수를 결합함으로써 첫 번째 변수의 열을 가져옴\n\n-   `inner_join()`: 두 변수 모두에 존재하는 열을 취함\n\n-   `full_join()`: 최소한 한 변수에 존재하는 열을 모두 취함\n\n-   `semi_join()`: 첫 번째 변수의 행 중 두 번째 변수에 대응하는 행이 있는 것만 취함\n\n-   `anti_join()`: 첫 번째 변수의 행 중 두 번째 변수에 대응하는 행이 없는 것만 취함\n\n이들 중 `left_join()`이 가장 많이 사용되기 때문에 그것에 집중한다.\n\n#### `left_join()` 함수의 활용\n\n실습을 위해 [`nycflights13`](https://github.com/tidyverse/nycflights13) 패키지의 데이터를 사용한다. 이 패키지에는 다섯 개의 데이터 프레임이 포함되어 있다. 지난 번에는 첫 번째 데이터만 사용했다.\n\n-   `flights`: 2013년 NYC를 출발한 모든 항공기\n\n-   `weather`: 공항별 시간별 기상 상황\n\n-   `planes`: 항공기별 건조 정보\n\n-   `airports`: 공항명과 위치\n\n-   `airlines`: 항공사\n\n그리고 이 6개의 데이터 프레임은 @fig-nycflights13-1 처럼 공통키(common key)를 통해 서로 연결되어 있다.\n\n![`nycflights13` 데이터(<https://github.com/tidyverse/nycflights13>)](https://r4ds.hadley.nz/diagrams/relational.png){#fig-nycflights13-1}\n\n`flights` 데이터의 변수가 너무 많기 때문에 조인을 위한 공통키를 중심으로 변수를 줄인다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 <- flights |> \n  select(year, time_hour, origin, dest, tailnum, carrier)\nflights2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 6\n    year time_hour           origin dest  tailnum carrier\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>  \n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     \n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     \n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     \n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     \n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     \n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6     \n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV     \n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6     \n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA     \n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n`flights2` 데이터를 중심으로 나머지 4개의 데이터와 조인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairlines\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   carrier name                       \n   <chr>   <chr>                      \n 1 9E      Endeavor Air Inc.          \n 2 AA      American Airlines Inc.     \n 3 AS      Alaska Airlines Inc.       \n 4 B6      JetBlue Airways            \n 5 DL      Delta Air Lines Inc.       \n 6 EV      ExpressJet Airlines Inc.   \n 7 F9      Frontier Airlines Inc.     \n 8 FL      AirTran Airways Corporation\n 9 HA      Hawaiian Airlines Inc.     \n10 MQ      Envoy Air                  \n11 OO      SkyWest Airlines Inc.      \n12 UA      United Air Lines Inc.      \n13 US      US Airways Inc.            \n14 VX      Virgin America             \n15 WN      Southwest Airlines Co.     \n16 YV      Mesa Airlines Inc.         \n```\n\n\n:::\n\n```{.r .cell-code}\nflights2 |>\n  left_join(airlines)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 7\n    year time_hour           origin dest  tailnum carrier name                  \n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>                 \n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines Inc. \n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines Inc. \n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines Inc.\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways       \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.  \n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines Inc. \n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      JetBlue Airways       \n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      ExpressJet Airlines I…\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      JetBlue Airways       \n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      American Airlines Inc.\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nweather\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 26,115 × 15\n   origin  year month   day  hour  temp  dewp humid wind_dir wind_speed\n   <chr>  <int> <int> <int> <int> <dbl> <dbl> <dbl>    <dbl>      <dbl>\n 1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4 \n 2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06\n 3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5 \n 4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7 \n 5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7 \n 6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5 \n 7 EWR     2013     1     1     7  39.0  28.0  64.4      240      15.0 \n 8 EWR     2013     1     1     8  39.9  28.0  62.2      250      10.4 \n 9 EWR     2013     1     1     9  39.9  28.0  62.2      260      15.0 \n10 EWR     2013     1     1    10  41    28.0  59.6      260      13.8 \n# ℹ 26,105 more rows\n# ℹ 5 more variables: wind_gust <dbl>, precip <dbl>, pressure <dbl>,\n#   visib <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\nflights2 |> \n  left_join(weather |> select(origin, time_hour, temp, wind_speed))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 8\n    year time_hour           origin dest  tailnum carrier  temp wind_speed\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <dbl>      <dbl>\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA       39.0       12.7\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA       39.9       15.0\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA       39.0       15.0\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6       39.0       15.0\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL       39.9       16.1\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA       39.0       12.7\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6       37.9       11.5\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV       39.9       16.1\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6       37.9       13.8\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA       39.9       16.1\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplanes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,322 × 9\n   tailnum  year type              manufacturer model engines seats speed engine\n   <chr>   <int> <chr>             <chr>        <chr>   <int> <int> <int> <chr> \n 1 N10156   2004 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 2 N102UW   1998 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 3 N103US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 4 N104UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 5 N10575   2002 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 6 N105UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 7 N107US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 8 N108UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 9 N109UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n10 N110UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n# ℹ 3,312 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nflights2 |> \n  left_join(planes |> select(tailnum, type, engines, seats))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 9\n    year time_hour           origin dest  tailnum carrier type     engines seats\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>      <int> <int>\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Fixed w…       2   149\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      Fixed w…       2   149\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Fixed w…       2   178\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      Fixed w…       2   200\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Fixed w…       2   178\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Fixed w…       2   191\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Fixed w…       2   200\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      Fixed w…       2    55\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      Fixed w…       2   200\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      <NA>          NA    NA\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nairports\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,458 × 8\n   faa   name                             lat    lon   alt    tz dst   tzone    \n   <chr> <chr>                          <dbl>  <dbl> <dbl> <dbl> <chr> <chr>    \n 1 04G   Lansdowne Airport               41.1  -80.6  1044    -5 A     America/…\n 2 06A   Moton Field Municipal Airport   32.5  -85.7   264    -6 A     America/…\n 3 06C   Schaumburg Regional             42.0  -88.1   801    -6 A     America/…\n 4 06N   Randall Airport                 41.4  -74.4   523    -5 A     America/…\n 5 09J   Jekyll Island Airport           31.1  -81.4    11    -5 A     America/…\n 6 0A9   Elizabethton Municipal Airport  36.4  -82.2  1593    -5 A     America/…\n 7 0G6   Williams County Airport         41.5  -84.5   730    -5 A     America/…\n 8 0G7   Finger Lakes Regional Airport   42.9  -76.8   492    -5 A     America/…\n 9 0P2   Shoestring Aviation Airfield    39.8  -76.6  1000    -5 U     America/…\n10 0S9   Jefferson County Intl           48.1 -123.    108    -8 A     America/…\n# ℹ 1,448 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nflights2 |> \n  left_join(airports, join_by(origin == faa))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 13\n    year time_hour           origin dest  tailnum carrier name         lat   lon\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>      <dbl> <dbl>\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Newark Li…  40.7 -74.2\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      La Guardia  40.8 -73.9\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      John F Ke…  40.6 -73.8\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      John F Ke…  40.6 -73.8\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      La Guardia  40.8 -73.9\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Newark Li…  40.7 -74.2\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Newark Li…  40.7 -74.2\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      La Guardia  40.8 -73.9\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      John F Ke…  40.6 -73.8\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      La Guardia  40.8 -73.9\n# ℹ 336,766 more rows\n# ℹ 4 more variables: alt <dbl>, tz <dbl>, dst <chr>, tzone <chr>\n```\n\n\n:::\n:::\n\n\n`airports`의 경우만 왜 `join_by()`라는 아규먼트가 사용되었는데, 이 경우에는 공통키의 이름이 동일하지 않기 때문이다. 즉, `flights2` 데이터의 origin 컬럼과 `airports` 데이터의 faa가 공통키임을 지정해 주어야 하는 것이다.\n\n### 테이블 결합\n\n여기에는 `bind_row()` 함수와 `bind_col()` 함수가 있다. 전자는 컬럼이 동일한 두 테이블을 상하로 연결하는 것이고, 후자는 행이 동일한 두 테이블을 좌우로 연결하는 것이다. `bind_row()`와 유사한 가능을 하는 파생 함수에 `intersect()`, `union()`, `setdiff()` 함수 등이 있다.\n\n#### `bind_row()` 함수\n\n#### `bind_col()` 함수\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}