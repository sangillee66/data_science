---
title: "Lab05: 변형하기"
author: 이상일ㆍ박서우(서울대학교 지리교육과)
date-modified: last-modified
number-sections: true
format: 
  html: 
    toc: true
    embed-resources: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
lightbox: true
editor: visual
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

## 개요 {.unnumbered}

여기서는 R로 데이터사이언스를 하는 과정 중 데이터 변형하기(transformation)를 다룬다. @fig-5-1 에서 볼 수 있는 것처럼, 데이터 변형하기는 데이터사이언스 프로세스의 핵심적인 분석 부분의 구성요소이다.

![데이터사이언스 프로세스와 변형하기(<https://r4ds.hadley.nz/transform.html>)](images/data_science_process_transform-01.png){#fig-5-1}

데이터 변형하기와 관련된 대부분의 함수는 [**tidyverse**](https://www.tidyverse.org/)의 핵심 패키지 중의 하나인 [**dplyr**](https://dplyr.tidyverse.org/) 에서 제공된다. 데이터 변형하기는 크게 다음의 두 가지 범주로 나뉜다.

-   단일 테이블 조작: 데이터 변형하기의 핵심 부분으로, 한 데이터 프레임의 데이터 구조를 조작한다.

-   다중 테이블 결합: 두 개 이상의 데이터 프레임을 결합하는 방식을 다룬다.

두 가지 모두 데이터 테이블이 입력되고, 데이터 테이블이 출력된다.

우선 [**tidyverse**](https://www.tidyverse.org/) 패키지를 불러온다.

```{r}
library(tidyverse)
```

## 단일 테이블 조작

단일 테이블 조작과 관련된 함수는 다시 네 가지로 범주화된다.

-   행 함수: 행(관측 개체)에 작동하는 함수, 즉 행의 변화를 야기하는 함수

-   열 함수: 열(변수)에 작동하는 함수, 즉 열의 변화를 야기하는 함수

-   그룹 함수: 그룹에 작동하는 함수

-   데이터 프레임 함수: 데이터 프레임 전체에 작동하는 함수

이번 실습에서는 행 함수, 열 함수, 그룹 함수에 집중한다. 사용할 데이터는 World Bank가 [gapmider.org](https://www.gapminder.org/)를 통해 무료로 배포하는 것으로 [`gapmider`](https://cran.r-project.org/web/packages/gapminder/readme/README.html) 패키지에 포함되어 있다. [`gapmider`](https://cran.r-project.org/web/packages/gapminder/readme/README.html) 패키지를 인스톨하고 불러온다. 데이터가 어떻게 구성되어 있는지 살펴본다.

```{r}
library(gapminder)
gapminder
```

### 행 함수

#### `filter()` 함수

특정 열(변수)과 관련된 조건을 만족하는 행을 선정한다. 행의 길이가 준다.

```{r}
gapminder |> 
  filter(continent == "Europe")
```

```{r}
gapminder |> 
  filter(pop > 50000000 & gdpPercap > 30000)
```

```{r}
gapminder |> 
  filter(year == 2007 & (lifeExp > 82 | gdpPercap > 40000))
```

#### `slice()` 함수

`filter()` 함수와 마찬가지로 행의 숫자를 줄인다. `slice()` 함수 자체 보다는 `slice_head()`, `slice_tail()`, `slice_max()`, `slice_min()`과 같은 패밀리 함수가 더 널리 사용된다. 그런데 이 함수들은 작동 방식에 따라 두 가지로 구분된다.

-   특정 열(변수)과 관계 없이, 행의 위치에 의거해 행을 선정: `slice()`, `slice_head()`, `slice_tail()`

-   특정 열(변수)에 따른, 행의 위치에 의거해 행을 선정: `slice_max()`, `slice_min()`

몇 번째에서 몇 번째 사이의 행만을 골라낸다.

```{r}
gapminder |> 
  slice(1:5)
```

가장 앞에 위치한 몇 개(`n`)의 행만을 골라낸다. 실질적으로 위와 동일하다.

```{r}
gapminder |> 
  slice_head(n = 5)
```

가장 뒤에 위치한 몇 개(`n`)의 행만을 골라낸다.

```{r}
gapminder |> 
  slice_tail(n = 5)
```

특정 열(변수)에 따라 값이 가장 큰 몇 개(`n`)의 행만을 골라낸다.

```{r}
gapminder |> 
  filter(year == 2007) |> 
  slice_max(gdpPercap, n = 5)
```

특정 열(변수)에 따라 값이 가장 작은 것들 중 주어진 비중(`prop`) 만큼의 행만을 골라낸다.

```{r}
gapminder |> 
  filter(year == 2007 & continent == "Asia") |> 
  slice_min(lifeExp, prop = 0.1)
```

::: callout-note
`slice` 함수는 데이터 프레임이 적용되는 것으로 모두 데이터 프레임을 산출한다. 그런데 유사한 작업을 벡터에 적용하는 함수들이 존재한다. `slice_head()`, `slice_tail()`, `slice()`에 대응하는 `dplyr` 벡터 함수로 `first()`, `last()`, `nth()`가 있다. 그런데 후자의 함수를 벡터가 아닌 데이터 프레임이 적용하면 slice 함수와 동일한 결과가 산출된다.
:::

#### `arrange()` 함수

특정 열(변수)과 관련된 조건에 의거해 행의 순서를 바꾼다. 행의 길이에는 변화가 없다.

```{r}
gapminder |> 
  arrange(lifeExp)
```

`desc()` 보조 함수(helper function)는 내림차순으로 행을 배열한다.

```{r}
gapminder |> 
  arrange(lifeExp, desc(year))
```

#### `distinct()` 함수

특정 열(변수)에 의거해 중복이 없이 고유한 행만을 골라낸다. 행의 길이가 준다.

`gapminder` 데이터와 관련하여 다음의 코드는 어떤 정보를 우리에게 주는지 생각해 본다.

```{r}
gapminder |> 
  distinct(country)
```

`.keep_all` 아규먼트를 이용하면 나머지 열도 함께 나타낼 수 있다. 나머지 열의 값이 무엇인지 생각해 본다.

```{r}
gapminder |> 
  distinct(continent, .keep_all = TRUE)
```

### 열 함수

#### `select()` 함수

열(변수)의 일부를 선택한다. 열의 길이가 준다.

```{r}
gapminder |> 
  select(year, country, gdpPercap)
```

열(변수)의 일부를 선택하지 않는다. 역시 열의 길이가 준다. 실질적으로 위와 동일한 결과가 산출된다. `!` 부호 대신 `-` 부호를 사용할 수 있다. 전자가 선호된다.

```{r}
gapminder |> 
  select(!c(lifeExp, continent, pop))
```

`starts_with()`, `ends_with()`, `contains()`와 같은 보조 함수를 잘 활용하면 효율적으로 필요한 변수만을 선정할 수 있다.

```{r}
gapminder |> 
  select(starts_with("c"))
```

#### `mutate()` 함수

기존의 열(변수)에 기반하여 새로운 변수를 생성한다. 열의 길이가 늘어난다.

```{r}
gapminder |> 
  mutate(
    gdp_billion = gdpPercap * pop / 10^9
  )
```

여러개의 변수를 동시에 생성할 수 있다. `row_number()` 보조 함수는 값에 순위를 부여하는 것이고, `.keep = "used"`는 결과에 변수 생성에 동원된 변수만을 포함시키게 해 준다.\

```{r}
gapminder |> 
  filter(year == 2007) |> 
  mutate(
    gdpPercap_rank = row_number(gdpPercap),
    lifeExp_highlow = lifeExp > 30000,
    .keep = "used"
  )
```

::: callout-note
`dplyr` 패키지는 데이터에 순위를 부여하는 여러 가지 방식을 제공하는데, `row_number()`, `min_rank()`, `dense_rank()`, `percent_rank()`, `cumu_dist()` 등이 있다. 자세한 사항은 맨 아래에 있는 기타 벡터 함수를 참고하면 된다.
:::

#### `rename()` 함수

변수의 이름을 바꾼다. 열의 길이에는 변화가 없다. `=` 부호의 왼쪽에 있는 것이 새로운 변수명이다.

```{r}
gapminder |> 
  rename(
    gdp_percap = gdpPercap,
    left_exp = lifeExp
  )
```

패밀리 함수인 `rename_with()`를 이용하면 다른 것도 가능하다. `tolower`은 변수명을 소문자로 바꾸는 보조 함수이고, `toupper`은 대문자로 바꾸는 보조 함수이다.

```{r}
gapminder |> 
  rename_with(
    tolower, starts_with("l")
  )
```

#### `relocate()` 함수

변수의 위치를 바꾼다. 열의 길이에는 변화가 없다. 기입한 변수들이 맨 앞으로 이동한다.

```{r}
gapminder |> 
  relocate(year, continent)
```

`.before`나 `.after` 아규먼트를 사용하여 해당 변수를 어떤 변수의 앞이나 뒤로 보낼 수 있다.

```{r}
gapminder |> 
  relocate(pop, .before = lifeExp )
```

#### `pull()` 함수

데이터 프레임의 한 컬럼을 벡터로 추출한다.

```{r}
gapminder |> pull(lifeExp) |> mean()
```

::: callout-note
Base R이 벡터 기반 연산에 강점이 있는 반면 [**tidyverse**](https://www.tidyverse.org/)는 데이터 프레임별 연산에 강점이 있다. 이렇다 보니 Base R의 많은 벡터 기반 함수를 [**tidyverse**](https://www.tidyverse.org/)에서 사용할 때 불편함을 느낄 수 있다. 이러한 문제점을 경감해 줄 수 있는 것이 `pull()` 함수이다. 예를 들어 위의 코드를 Base R에서 쓰면 다음과 같다.

```{r}
#| eval: false
mean(gapminder$lifeExp)
```

동일한 것을 정규 [**tidyverse**](https://www.tidyverse.org/)문법에 맞추어 쓰면 다음과 같다.

```{r}
#| eval: false
gapminder |> 
  summarize(
    mean_lifeExp = mean(lifeExp)
  )
```

좀 성가시게 길어지는 측면이 있다. 이 때 `pull()` 함수는 유용하게 사용될 수 있고, [**tidyverse**](https://www.tidyverse.org/)문법을 지키면서도 코드를 좀 더 간명하게 표현할 수 있다.
:::

### 그룹 함수

#### `group_by()` 함수

특정 범주 열(변수)에 의거해 행을 분할한다. 행의 길이는 변하지 않는다.

우선 하나의 범주 변수에 의거해 그룹화한다. 산출물을 보면 `year`에 의거해 행이 12개의 그룹으로 나누어졌음을 알 수 있다(두 번째 줄: Group: year \[12\]).

```{r}
gapminder |> 
  group_by(year)
```

두 개 이상의 범주 변수에 의거해 그룹화할 수도 있다.

```{r}
gapminder |> 
  group_by(year, continent)
```

#### `summarize()` 함수

주어진 열(변수)에 대한 통계 요약값을 계산하고 그것으로 이루어진 새로운 데이터 프레임을 생성한다. 엄밀히 말해 기존 열(변수)을 변형한다기 보다는 기존 데이터 프레임으로부터 새로운 데이터 프레임을 생성한다고 볼 수 있다. `summarize()` 함수는 대부분의 경우 `group_by()` 함수와 함께 사용된다. 다음의 둘을 비교해 보라.

```{r}
gapminder |> 
  filter(year == 2007) |> 
  summarize(
    mean_gdpPercap = mean(gdpPercap)
  )
```

```{r}
gapminder |> 
  filter(year == 2007) |> 
  group_by(continent) |> 
  summarize(
    mean_gdpPercap = mean(gdpPercap)
  )
```

좀 더 복잡한 확장이 가능하다. 마지막의 `n()`은 특별한 요약 함수로, 어떤 아규먼트도 없이 단독으로 사용되며 "현재(current)" 그룹의 빈도값을 산출한다.

```{r}
gapminder |> 
    group_by(continent, year) |> 
    summarize(
      mean_gdpPercap = mean(gdpPercap),
      sd_gdpPercap = sd(gdpPercap),
      mean_pop = mean(pop),
      sd_pop = sd(pop),
      n = n()
    )
```

`group_by()`와 `arrange()`를 결합하는 경우, `.by_group = TRUE`를 하면 그룹별로 행을 배열할 수 있다(그렇지 않으면 그룹 설정을 무시한 채 행을 배열한다.)

```{r}
gapminder |> 
  group_by(year, continent) |> 
  arrange(desc(gdpPercap), .by_group = TRUE)
```

아래는 연도별/대륙별로 일인당 GDP가 가장 높은 국가를 추출한 것이다. 코드를 생각해 보라.

```{r}
#| echo: false
gapminder |> 
  group_by(year, continent) |> 
  slice_max(gdpPercap)
```

`group_by()` 함수가 한 번 적용되면, 그 뒤의 모든 오퍼레이션에 그룹 분할이 적용되기 때문에 예기치 못한 일이 발생할 수 있다. 이것을 회피하기 위해 두 가지 옵션이 있다. 첫번째 방법은 마지막에 `upgroup()` 함수를 첨가하는 것이다. 아래에 위 질문에 대한 정답이 나타나 있다.

```{r}
gapminder |> 
  group_by(year, continent) |> 
  slice_max(gdpPercap) |> 
  ungroup()
```

두 번째 방법은 `group_by()` 함수 대신 `by` 아규먼트를 사용하는 것이다. 결과가 달라보이겠지만 정렬의 차이일 뿐 동일하다.

```{r}
gapminder |> 
  slice_max(
    gdpPercap, 
    by = c(year, continent)
  )
```

#### `count()` 함수

특정 범주 열(변수)에 의거한 빈도를 빠르게 계산해 준다. 빈도는 자동적으로 `n`이라는 이럼의 컬럼에 저장된다.

```{r}
gapminder |> 
  count(year, continent)
```

`wt` 아규먼트를 사용하면 빈도가 아니라 범주별 특정 변수의 합산값을 구할 수 있다.

```{r}
gapminder |> 
  count(year, continent, wt = pop)
```

위의 두 개는 사실 아래와 동일하다.

```{r}
gapminder |> 
  group_by(year, continent) |> 
  summarize(
    n = n(),
    sum_pop = sum(pop)
  )
```

#### `across()` 함수

다수의 열(변수)에 동일한 함수를 적용할 수 있다.

```{r}
gapminder |> 
  mutate(
    across(c(lifeExp, gdpPercap), round)
  )
```

이것은 다음과 동일하다.

```{r}
gapminder |> 
  mutate(
    lifeExp = round(lifeExp),
    gdpPercap = round(gdpPercap)
  )
```

`summarize()` 함수와 결합하여 선택된 변수에 특정 함수를 적용하고 그 결과의 이름을 변수명과 함수명을 사용하여 부여할 수 있다.

```{r}
gapminder |> 
  group_by(year, continent) |> 
  summarize(
    across(
      c(lifeExp, gdpPercap), 
      mean, 
      .names = "mean_{.col}"
    )
  )
```

`across()` 함수에서 중요한 것은 함수 아규먼트에 함수명 그 자체만 쓸 수 있을 뿐(즉, `mean`), 함수명 뒤에 `()`가 붙을 수 없다. 예를 들어 mean() 함수의 매우 중요한 아규먼트인 na.rm을 사용할 수 없다. 위의 예에서 두 변수 중 어느 변수에라도 결측값이 포함되어 있었다면 에러가 발생했을 것이다. 이 문제는 다음과 같은 방식으로 해결할 수 있다.

```{r}
gapminder |> 
  group_by(year, continent) |> 
  summarize(
    across(
      c(lifeExp, gdpPercap), 
      function(x) median(x, na.rm = TRUE)
    )
  )
```

혹은 보다 간단하게 `function()`을 `\()`로 대체할 수도 있다.

```{r}
gapminder |> 
  group_by(year, continent) |> 
  summarize(
    across(
      c(lifeExp, gdpPercap), 
      \(x) median(x, na.rm = TRUE)
    )
  )
```

만일 `across()` 함수 속에서 두 개 이상의 함수를 적용한다면 `list()`를 활용해야 한다. 결과에 새로 생성된 변수명이 원변수명_함수명(`{.col}_{.fn}`)의 형태를 띠고 있음에 주목하라. 사실 이것은 across() 함수 속에 `.names = "{.col}_{.fn}"`라고 지정한 것과 동일한 것으로, 만일 `.names = "{.fn}_{.col}"` 이라고 지정하면 다른 결과가 나타날 것이다.

```{r}
gapminder |> 
  group_by(year, continent) |> 
  summarize(
    across(
      c(lifeExp, gdpPercap), 
      list(
        mean = \(x) mean(x, na.rm = TRUE),
        median = \(x) median(x, na.rm = TRUE)
      )
    )
  )
```

`across()` 함수의 파생 함수로 `if_any()`와 `if_all()`이 있다. 두 함수 모두 매우 유용하지만 여기서는 다루지 않는다.

#### `c_across()` 함수

`group_by()` 함수와 `across()` 함수가 결합하는 것과 정반대로, `rowwise()` 함수와 `c_across()` 함수를 결합하며, 행별 통계값을 산출할 수 있다. 물론 여기서 `each_sd` 값은 아무런 의미가 없다. 행별로 수치형 변수(year, lifeExp, pop, gdpPercap)의 표준편차를 구한 것이다.

```{r}
gapminder |> 
  rowwise() |> 
  mutate(
    each_sd = sd(c_across(where(is.numeric)))
  )
```

:::: {.callout-note collapse="false" title="단일 테이블 조작 퀴즈"}
::: panel-tabset
## 문제

대륙별로 기대수명이 가장 높은 국가 찾기

-   2007년을 기준으로, 각 대륙에서 기대수명이 가장 높은 국가 1개를 찾아보시오.

-   결과로는 5개 대륙을 행으로 갖는 데이터셋을 기대수명이 높은 순서대로 정렬하시오.

-   또한, 결과에는 continent, country, lifeExp 열만 표시하시오.

## 코드

```{r}

gapminder |> 
  filter(year == 2007) |> 
  group_by(continent) |> 
  slice_max(lifeExp, n = 1) |> 
  arrange(desc(lifeExp)) |> 
  select(continent, country, lifeExp)

```
:::
::::

## 다중 테이블 결합

### 테이블 조인

테이블 조인(join)은 두 개 데이터 프레임을 공통키(common key)를 이용해 결합함으로써 하나의 데이터 프레임을 생성하는 것을 의미한다. 서로 상이한 방식의 조인이 가능하면, [**dplyr**](https://dplyr.tidyverse.org/) 패키지는 다양한 종류의 조인 함수를 제공한다.

-   `left_join()`: 첫 번째 테이블은 그대로 둔 상태에서 두 번째 테이블을 결합함으로써 두 번째 테이블의 열을 가져옴

-   `right_join()`: 두 번째 테이블은 그대로 둔 상태에서 첫 번째 테이블을 결합함으로써 첫 번째 테이블의 열을 가져옴

-   `inner_join()`: 두 테이블 모두에 존재하는 열을 취함

-   `full_join()`: 최소한 한 테이블에 존재하는 열을 모두 취함

-   `semi_join()`: 첫 번째 테이블의 행 중 두 번째 테이블에 대응하는 행이 있는 것만 취함

-   `anti_join()`: 첫 번째 테이블의 행 중 두 번째 테이블에 대응하는 행이 없는 것만 취함

이들 중 `left_join()`이 가장 많이 사용되기 때문에 그것에 집중한다.

#### `left_join()` 함수

실습을 위해 [`nycflights13`](https://github.com/tidyverse/nycflights13) 패키지의 데이터를 사용한다. 이 패키지에는 다섯 개의 데이터 프레임이 포함되어 있다. 지난 번에는 첫 번째 데이터만 사용했다.

-   `flights`: 2013년 NYC를 출발한 모든 항공기

-   `weather`: 공항별 시간별 기상 상황

-   `planes`: 항공기별 건조 정보

-   `airports`: 공항명과 위치

-   `airlines`: 항공사

그리고 이 6개의 데이터 프레임은 @fig-nycflights13-1 처럼 공통키(common key)를 통해 서로 연결되어 있다.

![`nycflights13` 데이터(<https://github.com/tidyverse/nycflights13>)](https://r4ds.hadley.nz/diagrams/relational.png){#fig-nycflights13-1}

`flights` 데이터의 변수가 너무 많기 때문에 조인을 위한 공통키를 중심으로 변수를 줄인다.

```{r}
library(nycflights13)
```

```{r}
flights2 <- flights |> 
  select(year, time_hour, origin, dest, tailnum, carrier)
flights2
```

`flights2` 데이터를 중심으로 나머지 4개의 데이터와 조인한다.

```{r}
airlines
flights2 |>
  left_join(airlines)
```

```{r}
weather
flights2 |> 
  left_join(weather |> select(origin, time_hour, temp, wind_speed))
```

```{r}
planes
flights2 |> 
  left_join(planes |> select(tailnum, type, engines, seats))
```

```{r}
airports
flights2 |> 
  left_join(airports, join_by(origin == faa))
```

`airports`의 경우만 왜 `join_by()`라는 아규먼트가 사용되었는데, 이 경우에는 공통키의 이름이 동일하지 않기 때문이다. 즉, `flights2` 데이터의 origin 컬럼과 `airports` 데이터의 faa가 공통키임을 지정해 주어야 하는 것이다.

### 테이블 병합

테이블 병합(merge)은 두 데이터 프레임을 결합해 새로운 단일한 데이터 프레임을 생성한다는 의미에서는 테이블 조인과 동일하지만, 공통키가 없으며, 행과 열 중 하나는 만드시 동일해야 한다. 가장 널리 사용되는 함수에 `bind_row()` 함수와 `bind_col()` 함수가 있다. 전자는 컬럼이 동일한 두 테이블을 상하로 연결하는 것이고, 후자는 행이 동일한 두 테이블을 좌우로 연결하는 것이다.

#### `bind_row()` 와 `bind_col()` 함수

`gapminder` 데이터를 25년 간격으로 세 개의 연도(1957, 1982, 2007년)로 분할한다.

```{r}
gap_1957 <- gapminder |> filter(year == 1957)
gap_1982 <- gapminder |> filter(year == 1982)
gap_2007 <- gapminder |> filter(year == 2007)
```

이 세개의 데이터 프레임은 동일한 열 구조(동일한 변수)를 가지고 있지만, 행이 다르다. 이런 경우 `bind_row()` 함수를 사용하여 하나의 데이터 프레임으로 결합할 수 있다.

```{r}
gapminder_merge_row <- bind_rows(
  gap_1957, gap_1982, gap_2007
)
gapminder_merge_row
```

이제 gapminder 데이터 프레임을 변수 세 개씩 묶어 두 개의 데이터 프레임으로 분할한다.

```{r}
gap_var1 <- gapminder |> select(country, continent, year)
gap_var2 <- gapminder |> select(lifeExp, pop, gdpPercap)
```

이 두개의 데이터 프레임은 동일한 행 구조(동일한 관측 개체)를 가지고 있지만, 열이 다르다. 이런 경우 `bind_col()` 함수를 사용하여 하나의 데이터 프레임으로 결합할 수 있다.

```{r}
gapminder_merge_col <- bind_cols(gap_var1, gap_var2)
gapminder_merge_col
```

#### 기타 집합 연산 함수

집합 연산(set operation) 함수란 두 데이터 프레임을 수학적 집합 연산(합집합, 교집합, 차집합, 동등성 검사)을 적용하여 새로운 데이터 프레임을 산출하는 함수를 말한다. 두 데이터 프레임은 동일한 열 구조를 가져야 하며, 행 전체를 하나의 원소로 취급한다. 여기에 해당하는 함수로, `intersect()`, `union()`, `setdiff()` 함수 등이 있다.

## 기타 벡터 함수

타이디버스 함수의 기본 작동 방식은 데이터 프레임을 입력으로 받아 데이터 프레임을 출력하는 것이다. 이에 반해 Base R은 기본적으로 벡터에 대한 연산에 기반하고 있다. 타이디버스의 이러한 측면은 주로 장점으로 작용한다고 볼 수 있지만, 단점으로 작용하는 경우도 적지 않다. 이를 극복하기 위해 [**dplyr**](https://dplyr.tidyverse.org/) 패키지는 몇 가지 유용한 벡터 함수를 제공하고 있다. 이러한 함수는 주로 단일 테이블 조작 함수의 내부에서 작동한다.

| 범주 | 함수 | 설명 |
|----|----|----|
| 값 추출 | `first()` | 첫 번째 값 |
|  | `last()` | 마지막 값 |
|  | `nth()` | n-번째 값 |
| 값 변경 | `if_else()` | 단일 벡터에 대해, 이진 조건식을 통해 재코드화 |
|  | `case_match()` | 단일 벡터에 대해, 조건식을 통해 재코드화 |
|  | `case_when()` | 다중 벡터에 대해, 조건식을 통해 재코드화 |
| 순위 부여 | `row_number()` | 일련번호 부여 |
|  | `min_rank()` | 동일값에 동순위를 부여하고, 그 다음 값에는 동순위 갯수를 감안한 그 다음 순위를 부여 |
|  | `dense_rank()` | 동일값에 동순위를 부여하고, 그 다음 값에는 동순위 갯수에 상관없이 바로 그 다음 순위를 부여 |
|  | `percent_rank()` | 백분위수(percentile)을 계산해 주는데, 해당 값보다 작은 값의 개수를 전체 개수에서 1을 뺀 값으로 나눈값을 산출 |
|  | `cume_dist()` | 백분위수(percentile)을 계산해 주는데, 해당 값보다 작거나 같은 값의 개수를 전체 개수로 나눈값을 산출 |
|  | `ntile()` | 값의 크기에 따라 몇 개의 그룹으로 나누고, 그룹 순위를 부여 |
|  | `consecutive_id()` | 동일한 값에는 동일한 일련번호를, 새로운 값이 나타날 때에는 그 다음 일련번호를 부여 |
| 값 순서 변경 | `desc()` | 내림차순으로 정렬 |
|  | `lag()` | 뒤로 밀어 이전 값을 가져옴. 첫번째 값이 NA |
|  | `lead()` | 앞으로 당겨서 이후 값을 가져옴. 마지막 값이 NA |
| 결측치 처리 | `coalesce()` | NA에 특정한 값을 부여 |
|  | `na_if()` | 특정한 값에 NA를 부여 |
| 논리형 벡터 생성 | `between()` | 특정한 값이 두 값 사이에 존재하는 지의 여부 검토 |
|  | `near()` | 두 값이 충분히 가까운지의 여부 검토 |

### 값 추출 함수

`first()` 함수는 해당 벡터의 첫 번째 셀 값을 반환한다. `last()` 함수는 해당 벡터의 마지막 셀 값을 반환한다. `nth()` 함수는 해당 벡터의 n-번째 셀 값을 반환한다. 주로 `summarize()` 함수와 함께 사용된다. 아래의 사례는 대륙별로 1인당 GDP가 가장 큰 국가와 가장 작은 국가를 추출한 것이다.

```{r}
gapminder |> 
  filter(year == 2007) |> 
  group_by(continent) |> 
  arrange(desc(gdpPercap)) |> 
  summarize(
    country_first = first(country),
    country_last = last(country)
  ) |> 
  ungroup()
```

유사한 기능을 하는 데이터 프레임 함수로 `slice_head()`, `slice_tail()`, `slice()` 함수가 있다. 궁극적인 차이점은 이 함수들은 특정한 행(들)으로 구성된 데이터 프레임을 반환한다는 것이다.

### 값 변경 함수

`if_else()` 함수는 값 변경 함수 중 가장 빈번하게 사용되는 것으로, 주로 단일 벡터에 대해, 이진 조건식을 통해 해당 변수의 값을 변경하는 것이다.

```{r}
gapminder |> 
  filter(year == 2007) |> 
  mutate(
    gdp_status = if_else(gdpPercap >= 20000, "high", "low")
  ) |> 
  count(gdp_status)
```

위의 사례는 수치형 변수를 범주형 변수로 바꾸는 것으로 보통 재코드화(recode)라고 불리는 연산이다. 두 개 이상의 범주로 분할하는 경우에도 `if_else()` 함수를 사용할 수 있지만, 이 경우는 `case_when()` 함수가 더 유용하다.

```{r}
gapminder |> 
  filter(year == 2007) |> 
  mutate(
    gdp_status = case_when(
      gdpPercap < 3000 ~ "Low", 
      gdpPercap >= 3000 & gdpPercap < 20000 ~ "Medium",
      gdpPercap >= 20000 ~ "High"
    )
  ) |> 
  count(gdp_status)
```

`case_when()` 함수는 조건식에 두 개 이상의 변수를 포함할 수 있다.

```{r}
gapminder |> 
  filter(year == 2007) |> 
  mutate(
    overall_status = case_when(
      gdpPercap < 3000 & lifeExp < 50 ~ "Really Bad",
      gdpPercap >= 20000 & lifeExp > 80  ~ "Really Good",
      .default = "Medium"
    )
  ) |> 
  count(overall_status)
```

`case_match()` 함수는 범주의 개수를 줄이는데 유용하게 사용될 수 있다. `.default` 인수를 통해 부여된 조건식에 해당하지 않는 나머지 모든 케이스에 대해 어떤 값을 부여할지를 결정할 수 있다. 이와 동일한 것을 `case_when()` 함수로도 가능하기 때문에 모든 경우에 대해 `case_when()` 함수를 활용하면 된다.

```{r}
gapminder |> 
  filter(year == 2007) |> 
  mutate(
    gdp_status = case_when(
      gdpPercap < 3000 ~ "Low", 
      gdpPercap >= 3000 & gdpPercap < 20000 ~ "Medium",
      gdpPercap >= 20000 ~ "High"
    )
  ) |> 
  mutate(
    gdp_status = case_match(
      gdp_status, 
      c("Low", "Medium") ~ 1,
      "High" ~ 2
    )
  ) |> 
  count(gdp_status)
```

### 순위 부여 함수

특정 벡터의 값을 기준으로 순위를 부여하고, 그 순위값으로 구성된 새로운 벡터를 생성하는 함수에 기본적으로 다음의 세 가지 방식이 있다.

-   `row_number()` 함수는 동일값이라 하더라도 값의 등장 순서에 따라 서로 다른 순위를 부여한다. 예를 들어, 다섯개의 숫자가 있고 두 번째 순위 값이 두 개라고 했을 때, 1\~5의 모든 순위가 존재한다.

-   `min_rank()` 함수는 동일값에 동순위를 부여하고, 그 다음 값에는 동순위 갯수를 감안한 그 다음 순위를 부여한다. 예를 들어, 다섯개의 숫자가 있고 두 번째 순위 값이 두 개라고 했을 때, 3은 없다.

-   `dense_rank()` 함수는 동일값에 동순위를 부여하고, 그 다음 값에는 동순위 갯수에 상관없이 바로 그 다음 순위를 부여한다 예를 들어, 다섯개의 숫자가 있고 두 번째 순위 값이 두 개라고 했을 때, 5는 없다.

```{r}
tbl_rank <- tibble(x = c(10, 20, 20, 30, 40))
tbl_rank |> 
  mutate(
    row_number = row_number(x),
    min_rank = min_rank(x),
    dense_rank = dense_rank(x)
  )
```

이 외에 두 개의 부가적인 함수가 존재하는데, 백분위수(percentile)를 계산한다는 의미에서는 동일하지만 계산 방식이 조금 다르다.

-   `percent_rank()` 함수: 백분위수을 계산해 주는데, 해당 값보다 작은 값의 개수를 전체 개수에서 1을 뺀 값으로 나눈값을 산출한다.

-   `cume_dist()` 함수: 백분위수를 계산해 주는데, 해당 값보다 작거나 같은 값의 개수를 전체 개수로 나눈값을 산출한다.

```{r}
tbl_rank <- tibble(x = c(10, 20, 20, 30, 40))
tbl_rank |> 
  mutate(
    percent_rank = percent_rank(x),
    cume_dist = cume_dist(x)
  )
```

### 값 순서 변경 함수

값 순서 변경 함수 중 가장 빈번하게 사용되는 것이 `desc()` 함수이다. 데이터 프레임 함수인 `arrange()`가 기본적으로 오름차순으로 정렬하는데, `desc()` 함수를 쓰면 내림차순으로 정렬할 수 있다.

```{r}
tbl_rank <- tibble(x = c(10, 20, 20, 30, 40))
tbl_rank |> 
  arrange(desc(x))
```

`lag()`과 `lead()` 함수는 주어진 벡터를 행방향으로 한칸 이동한 새로운 벡터를 생성하는데 사용된다. `lag()` 함수는 뒤로 한칸 밀어 이전 값을 가져와서 새로운 벡터를 생성하는데, 새로 만들어진 벡터의 첫 번째 셀 값은 NA가 된다. 이에 반해 `lead()` 함수는 앞으로 한칸 당겨 이후 값을 가져와서 새로운 벡터를 생성하는데, 새로 만들어진 벡터의 마지막 셀 값은 NA가 된다.

```{r}
tbl_rank <- tibble(x = c(10, 20, 20, 30, 40))
tbl_rank |>
  mutate(
    x_lag = lag(x), 
    x_lead = lead(x) 
  )
```

`default` 인자를 활용하면 NA의 생성을 막을 수 있다.

```{r}
tbl_rank <- tibble(x = c(10, 20, 20, 30, 40))
tbl_rank |>
  mutate(
    x_lag = lag(x, default = first(x)), 
    x_lead = lead(x, default = last(x)) 
  )
```

### 결측치 처리 함수

결측치 처리 함수는 벡터의 NA값과 관련된 함수이다. `coalesce()` 함수는 NA에 특정한 값을 부여하는데 반해, `na_if()` 함수는 특정한 값에 NA를 부여하는 함수이다.

```{r}
tbl_na <- tibble(x = c(1, 2, NA, 4, NA, 7))
tbl_na |> 
  mutate(
    x_coalesce = coalesce(x, 0), 
    x_na_if = na_if(x, 7)
  )
```

### 논리형 벡터 생성 함수

논리형 벡터 생성 함수는 조건의 부합 여부에 따라 TRUE와 FALSU로 구성된 새로운 벡터를 생성하는 함수를 의미한다. Base R에는 다음과 같은 논리형 벡터 생성 함수가 빈번하게 사용된다.

-   `is.na()`: 결측치 여부

-   `is.numeric()`: 수치형 여부

-   `is.integer()`: 정수형 여부

-   `is.character()`: 문자형 여부

-   `is.logical()`: 논리형 여부

-   `is.factor()`: 팩터 여부

여기에 덧붙여 [**dplyr**](https://dplyr.tidyverse.org/)은 흥미로운 논리형 벡터 생성 함수를 제공한다.

-   `between()`: 특정한 값이 주어진 두 값 사이에 위치하는 지의 여부 검토

-   `near()`: 특정한 값이 기준이 되는 값과 충분이 유사한지의 여부 검토

```{r}
gapminder |> 
  filter(
    year == 2007, 
    between(gdpPercap, 20000, 30000)
  )
```

`near()` 함수는 많이 사용되지는 않지만, 부등소수점 수(floating point number)의 정확도로 인해 발생하는 상동성 평가의 문제점을 극복하기 위한 함수이다. 아래의 예시를 보자. 두 값은 명백히 1과 2이다.

```{r}
x <- c(1 / 49 * 49, sqrt(2) ^ 2)
x
```

그러나 다음의 상동성 평가 문제가 발생한다.

```{r}
x == c(1, 2)
```

이것은 부등소수점 수의 정확도로 발생하는 문제이다.

```{r}
print(x, digits = 16)
```

`near()` 함수는 이러한 미세한 차이를 무시할 수 있게 해주어 상동성 평가 문제를 해결한다.

```{r}
near(x, c(1, 2))
```
