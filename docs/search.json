[
  {
    "objectID": "exec_11.html",
    "href": "exec_11.html",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "",
    "text": "여기서는 웹 앱 개발 도구로서의 Shiny에 대해 배운다. Shiny는 서버-기반의 웹 앱을 개발하기 위한 프레임워크를 제공한다. 원래 R 패키지로 개발되었으나 이제는 R과 Python 모두를 위한 웹 앱 개발 도구로 발전하고 있다.\n\nShiny for R\nShiny for Python\n\nShiny를 배우기 위한 다양한 리소스가 존재한다. 가장 중요한 리소스는 Shiny for R 홈페이지이다. Get Started를 살펴본 후 Gallery의 다양한 예제를 살펴보는 것으로 시작하는 것이 좋다. 이 홈페이지의 내용만으로도 Shiny의 기본 구조와 문법을 익히기에 충분하다.\n좀 더 종합적으로 Shiny을 이해하려면 다음의 웹 북을 활용할 수 있다. 첫 번째가 바이블이라고 할 수 있다.\n\nMastering Shiny by Hadley Wickham\nOutstanding User Interfaces with Shiny\nEngineering Production-Grade Shiny Apps\nInteractive Web-Based Data Visualization with R, plotly, and shiny\nR Shiny Applications in Finance, Medicine Pharama and Education Industry\nIntroduction to Data Science: 25 Shiny Applications\n데이터 사이언스를 위한 R 프로그래밍: 14 shiny",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#개요",
    "href": "exec_11.html#개요",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "",
    "text": "여기서는 웹 앱 개발 도구로서의 Shiny에 대해 배운다. Shiny는 서버-기반의 웹 앱을 개발하기 위한 프레임워크를 제공한다. 원래 R 패키지로 개발되었으나 이제는 R과 Python 모두를 위한 웹 앱 개발 도구로 발전하고 있다.\n\nShiny for R\nShiny for Python\n\nShiny를 배우기 위한 다양한 리소스가 존재한다. 가장 중요한 리소스는 Shiny for R 홈페이지이다. Get Started를 살펴본 후 Gallery의 다양한 예제를 살펴보는 것으로 시작하는 것이 좋다. 이 홈페이지의 내용만으로도 Shiny의 기본 구조와 문법을 익히기에 충분하다.\n좀 더 종합적으로 Shiny을 이해하려면 다음의 웹 북을 활용할 수 있다. 첫 번째가 바이블이라고 할 수 있다.\n\nMastering Shiny by Hadley Wickham\nOutstanding User Interfaces with Shiny\nEngineering Production-Grade Shiny Apps\nInteractive Web-Based Data Visualization with R, plotly, and shiny\nR Shiny Applications in Finance, Medicine Pharama and Education Industry\nIntroduction to Data Science: 25 Shiny Applications\n데이터 사이언스를 위한 R 프로그래밍: 14 shiny",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#기본-구조",
    "href": "exec_11.html#기본-구조",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "1 기본 구조",
    "text": "1 기본 구조\nShiny는 크게 세 부분으로 나뉘어 진다(그림 1).\n첫째, ui(혹은 ux) 부분이다. 프론트엔트(front-end) 부분으로 입력을 받고 출력을 표출하는 부분이다.\n둘째, server 부분이다. 백엔드(back-end) 부분으로 받은 입력으로 출력을 산출하는 부분이다.\n셋째, 결합 부분이다. ui와 server 부분을 결합해 웹 앱을 실행하는 부분이다.\n\n\n\n\n\n\n그림 1: Shiny의 구조(https://bookdown.org/hneth/i2ds/shiny.html)\n\n\n\n이건 좀 이상하다. 이상일 이상일",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "웹사이트 소개",
    "section": "",
    "text": "이 웹사이트는 데이터사이언스(Data Science)를 위한 개인 공부방으로 디자인되었다 .\n하지만 서울대학교에서 내가 개설한 데이터사이언스 관련 교과목의 보충 웹사이트로 활용될 수도 있다.\n\n2025/2 M3449.000300 AI 융합교육을 위한 인문사회 콘텐츠 설계 (Designing Human and Social Education Contents for AI Convergence Education)\n2024/1 M3450.001400 AI 융합교육을 위한 인문사회 컨텐츠 설계 (Designing Human and Social Education Contents for AI Convergence Education)",
    "crumbs": [
      "웹사이트 소개"
    ]
  },
  {
    "objectID": "index.html#웹사이트의-목적",
    "href": "index.html#웹사이트의-목적",
    "title": "웹사이트 소개",
    "section": "",
    "text": "이 웹사이트는 데이터사이언스(Data Science)를 위한 개인 공부방으로 디자인되었다 .\n하지만 서울대학교에서 내가 개설한 데이터사이언스 관련 교과목의 보충 웹사이트로 활용될 수도 있다.\n\n2025/2 M3449.000300 AI 융합교육을 위한 인문사회 콘텐츠 설계 (Designing Human and Social Education Contents for AI Convergence Education)\n2024/1 M3450.001400 AI 융합교육을 위한 인문사회 컨텐츠 설계 (Designing Human and Social Education Contents for AI Convergence Education)",
    "crumbs": [
      "웹사이트 소개"
    ]
  },
  {
    "objectID": "index.html#웹사이트의-구조",
    "href": "index.html#웹사이트의-구조",
    "title": "웹사이트 소개",
    "section": "웹사이트의 구조",
    "text": "웹사이트의 구조\n\n데이터 사이언스 관련 내용을 모두 10개의 하위 섹션으로 나누었다.\n각 하위 섹션은 세 개의 콘텐츠를 갖는다.\n\n내용 강의\n실습 강의\n실습",
    "crumbs": [
      "웹사이트 소개"
    ]
  },
  {
    "objectID": "index.html#참고문헌",
    "href": "index.html#참고문헌",
    "title": "웹사이트 소개",
    "section": "참고문헌",
    "text": "참고문헌\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund, 2023, R for Data Science: Import, Tidy, Transform, Visualize, and Model Data, 2nd edition, Boston: O’Reilly. \n\n이 사이트의 내용은 위의 책에 많은 토대를 두고 있다.\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. 1st edition. Sebastopol, CA: O’Reilly. (김설기ㆍ최혜민 옮김, 2019, R을 활용한 데이터 과학: 데이터 불러오기, 정리하기, 변형하기, 시각화하기, 모델링하기, 1판, 서울: 인사이트.)\nBonnell, Jerry, and Mitsunori Ogihara. 2023. Exploring Data Science with R and the Tidyverse. 1st edition. Chapman; Hall/CRC.\nIrizarry, Rafael A. 2024. Introduction to Data Science: Data Wrangling and Visualization with R. 2nd edition, Boca Raton: CRC Press.\nIrizarry, Rafael A. 2024. Introduction to Data Science: Statistics and Prediction Algorithms Through Case Studies. Boca Raton: CRC Press.\nIrizarry, Rafael A. 2020. Introduction to Data Science: Data Analysis and Prediction Algorithms with R. Boca Raton: CRC Press.\nAlexander, R., 2023, Telling Stories with Data: With Applications in R, Boca Raton: CRC Press.\nGrolemund, Garrett. 2014. Hands-On Programming with R: Write Your Own Functions and Simulations. O’Reilly Media, Inc..\nStauffer, R., Chimiak-Opoka, Joanna, Rodríguez-R, Luis Miguel, Simon, Thorsten, Zeileis, Achim, 2024, Introduction to Programming with R, 웹북\nDouglas, Alex, Roos, Deon, Mancini, Francesca, Couto Ana, Lusseau, David, 2024, An Introduction to R, 웹북\nBatra, Neale, ed., 2024, The Epidemiologist R Handbook, 웹북\nDoser, Jeffrey W., Finley, Andrew O., Melfi, Vince, 2022, R Programming for Data Sciences, 웹북\nBonnin, Sarah, 2020, Introduction to R 2021, 웹북\nGrolemund, Garrett, 2020, The Tidyverse Cookbook, 웹북\nAnsell, Brendan R. E. , Introduction to R - tidyverse, 웹북\nSarafian, Ron, Introduction to Data Science, 웹북\nIntroduction to R, 웹북\nData Analysis and Visualization in R for Ecologists, 웹북\nR for Epidemiology, 웹북\nRStudio IDE User Guide (https://docs.posit.co/ide/user/)\n한국알사용자회, 데이터 과학을 지탱하는 기본기, 웹북\n한국알사용자회, 데이터 시각화, 웹북\n한국알사용자회ㆍ이광춘, 2024, 챗GPT쿼토: 인공지능 시대 과학기술 저작 도구, 웹북\n김기환, 2023, R 프로그래밍(개정판), 웹북\n백영민. 2023. R 기반 데이터 과학: 타이디버스(tidyverse) 접근. 서울: 한나래아카데미.\n차영준ㆍ박진표, 2022, 데이터과학 입문을 위한 R과 타이디버스, 파주: 자유아카데미.\n곽기영, 2022, R 기초와 활용, 서울: 청람.\n강전희ㆍ엄동란, 2018, 처음 시작하는 R 데이터 분석, 서울: 한빛미디어.\n김영우, 2017, 쉽게 배우는 R 데이터 분석, 서울: 이지스퍼블리싱.",
    "crumbs": [
      "웹사이트 소개"
    ]
  },
  {
    "objectID": "lab_04.html",
    "href": "lab_04.html",
    "title": "Lab04: 데이터 변형하기",
    "section": "",
    "text": "아래의 함수들을 활용하여 데이터를 적절하게 변형할 수 있다.\n\n\n행 함수\n열 함수\n그룹 함수",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_04.html#실습의-목표",
    "href": "lab_04.html#실습의-목표",
    "title": "Lab04: 데이터 변형하기",
    "section": "",
    "text": "아래의 함수들을 활용하여 데이터를 적절하게 변형할 수 있다.\n\n\n행 함수\n열 함수\n그룹 함수",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_04.html#실습-준비",
    "href": "lab_04.html#실습-준비",
    "title": "Lab04: 데이터 변형하기",
    "section": "\n1 실습 준비",
    "text": "1 실습 준비\n\nlibrary(tidyverse)\n\n사용할 데이터는 World Bank가 gapmider.org를 통해 무료로 배포하는 것으로 gapmider 패키지에 포함되어 있다. gapmider 패키지를 인스톨하고 불러온다. 데이터가 어떻게 구성되어 있는지 살펴본다.\n\nlibrary(gapminder)\nView(gapminder)",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_04.html#행-함수",
    "href": "lab_04.html#행-함수",
    "title": "Lab04: 데이터 변형하기",
    "section": "\n2 행 함수",
    "text": "2 행 함수\n\n2.1 filter() 함수\n특정 열(변수)과 관련된 조건을 만족하는 행을 선정한다. 행의 길이가 준다.\n\n# continent의 값이 Europe인 행만 선택\ngapminder |&gt; \n  filter(continent == \"Europe\") \n\n# A tibble: 360 × 6\n   country continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Albania Europe     1952    55.2 1282697     1601.\n 2 Albania Europe     1957    59.3 1476505     1942.\n 3 Albania Europe     1962    64.8 1728137     2313.\n 4 Albania Europe     1967    66.2 1984060     2760.\n 5 Albania Europe     1972    67.7 2263554     3313.\n 6 Albania Europe     1977    68.9 2509048     3533.\n 7 Albania Europe     1982    70.4 2780097     3631.\n 8 Albania Europe     1987    72   3075321     3739.\n 9 Albania Europe     1992    71.6 3326498     2497.\n10 Albania Europe     1997    73.0 3428038     3193.\n# ℹ 350 more rows\n\n\n\n # pop이 5천만, gdpPercap이 3만을 초과하는 행만 선택\ngapminder |&gt; \n  filter(pop &gt; 50000000 & gdpPercap &gt; 30000)\n\n# A tibble: 9 × 6\n  country        continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;          &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 France         Europe     2007    80.7  61083916    30470.\n2 Germany        Europe     2002    78.7  82350671    30036.\n3 Germany        Europe     2007    79.4  82400996    32170.\n4 Japan          Asia       2007    82.6 127467972    31656.\n5 United Kingdom Europe     2007    79.4  60776238    33203.\n6 United States  Americas   1992    76.1 256894189    32004.\n7 United States  Americas   1997    76.8 272911760    35767.\n8 United States  Americas   2002    77.3 287675526    39097.\n9 United States  Americas   2007    78.2 301139947    42952.\n\n\n\n# year이 2007이고, lifeExp가 82를 초과하거나 gdpPercap이 4만을 초과하는 행만 선택\ngapminder |&gt; \n  filter(year == 2007 & (lifeExp &gt; 82 | gdpPercap &gt; 40000))\n\n# A tibble: 7 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Hong Kong, China Asia       2007    82.2   6980412    39725.\n2 Ireland          Europe     2007    78.9   4109086    40676.\n3 Japan            Asia       2007    82.6 127467972    31656.\n4 Kuwait           Asia       2007    77.6   2505559    47307.\n5 Norway           Europe     2007    80.2   4627926    49357.\n6 Singapore        Asia       2007    80.0   4553009    47143.\n7 United States    Americas   2007    78.2 301139947    42952.\n\n\n\n2.2 slice() 함수\nfilter() 함수와 마찬가지로 행의 숫자를 줄인다. slice() 함수는 slice_head(), slice_tail(), slice_max(), slice_min()과 같은 패밀리 함수가 더 널리 사용된다. 그런데 이 함수들은 작동 방식에 따라 두 가지로 구분된다.\n\n특정 열(변수)과 관계 없이, 행의 위치에 의거해 행을 선정: slice(), slice_head(), slice_tail()\n특정 열(변수)에 따른, 행의 위치에 의거해 행을 선정: slice_max(), slice_min()\n\n몇 번째에서 몇 번째 사이의 행만을 골라낸다.\n\n# 1~5행만을 선택\ngapminder |&gt; \n  slice(1:5)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n\n\n가장 앞에 위치한 몇 개(n)의 행만을 골라낸다. 실질적으로 위와 동일하다.\n\n# 가장 앞의 5개 행을 선택\ngapminder |&gt; \n  slice_head(n = 5)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n\n\n\n\n\n\n\n\n힌트\n\n\n\nBase R 함수인 head()또한 같은 역할을 할 수 있다.\n\ngapminder |&gt; \n  head(5)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n\n\n\n\n가장 뒤에 위치한 몇 개(n)의 행만을 골라낸다.\n\n# 가장 뒤의 5개 행을 선택\ngapminder |&gt; \n  slice_tail(n = 5)\n\n# A tibble: 5 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Zimbabwe Africa     1987    62.4  9216418      706.\n2 Zimbabwe Africa     1992    60.4 10704340      693.\n3 Zimbabwe Africa     1997    46.8 11404948      792.\n4 Zimbabwe Africa     2002    40.0 11926563      672.\n5 Zimbabwe Africa     2007    43.5 12311143      470.\n\n\n\n\n\n\n\n\n힌트\n\n\n\nBase R 함수인 tail()또한 같은 역할을 할 수 있다.\n\ngapminder |&gt; \n  tail(5)\n\n# A tibble: 5 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Zimbabwe Africa     1987    62.4  9216418      706.\n2 Zimbabwe Africa     1992    60.4 10704340      693.\n3 Zimbabwe Africa     1997    46.8 11404948      792.\n4 Zimbabwe Africa     2002    40.0 11926563      672.\n5 Zimbabwe Africa     2007    43.5 12311143      470.\n\n\n\n\n특정 열(변수)에 따라 값이 가장 큰 몇 개(n)의 행만을 골라낸다.\n\n# 2007년에 gdpPercap이 가장 큰 5개국 찾기\ngapminder |&gt; \n  filter(year == 2007) |&gt; # year이 2007인 행만 선택\n  slice_max(gdpPercap, n = 5) # gdpPercap이 가장 큰 5개 행 선택\n\n# A tibble: 5 × 6\n  country       continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Norway        Europe     2007    80.2   4627926    49357.\n2 Kuwait        Asia       2007    77.6   2505559    47307.\n3 Singapore     Asia       2007    80.0   4553009    47143.\n4 United States Americas   2007    78.2 301139947    42952.\n5 Ireland       Europe     2007    78.9   4109086    40676.\n\n\n특정 열(변수)에 따라 값이 가장 작은 것들 중 주어진 비중(prop)에 해당하는 행만을 골라낸다.\n\n# 2007년 아시아에서 lifeExp가 하위 10%인 국가 찾기\ngapminder |&gt; \n  filter(year == 2007 & continent == \"Asia\") |&gt; # year이 2007이고 continent가 Asia인 행만 선택\n  slice_min(lifeExp, prop = 0.1) # lifeExp가 작은 순으로 10% 행만 선택\n\n# A tibble: 3 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       2007    43.8 31889923      975.\n2 Iraq        Asia       2007    59.5 27499638     4471.\n3 Cambodia    Asia       2007    59.7 14131858     1714.\n\n\n\n2.3 arrange() 함수\n특정 열(변수)과 관련된 조건에 의거해 행의 순서를 바꾼다. 행의 길이에는 변화가 없다.\n\n# lifeExp 오름차순으로 행 정렬\ngapminder |&gt; \n  arrange(lifeExp)\n\n# A tibble: 1,704 × 6\n   country      continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Rwanda       Africa     1992    23.6 7290203      737.\n 2 Afghanistan  Asia       1952    28.8 8425333      779.\n 3 Gambia       Africa     1952    30    284320      485.\n 4 Angola       Africa     1952    30.0 4232095     3521.\n 5 Sierra Leone Africa     1952    30.3 2143249      880.\n 6 Afghanistan  Asia       1957    30.3 9240934      821.\n 7 Cambodia     Asia       1977    31.2 6978607      525.\n 8 Mozambique   Africa     1952    31.3 6446316      469.\n 9 Sierra Leone Africa     1957    31.6 2295678     1004.\n10 Burkina Faso Africa     1952    32.0 4469979      543.\n# ℹ 1,694 more rows\n\n\ndesc() 도우미 함수(helper function)는 내림차순으로 행을 배열한다.\n\n# year 오름차순으로 행 정렬 후 같은 year 안에서 lifeExp 내림차순으로 행 정렬\ngapminder |&gt; \n  arrange(year, desc(lifeExp))\n\n# A tibble: 1,704 × 6\n   country        continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;          &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Norway         Europe     1952    72.7  3327728    10095.\n 2 Iceland        Europe     1952    72.5   147962     7268.\n 3 Netherlands    Europe     1952    72.1 10381988     8942.\n 4 Sweden         Europe     1952    71.9  7124673     8528.\n 5 Denmark        Europe     1952    70.8  4334000     9692.\n 6 Switzerland    Europe     1952    69.6  4815000    14734.\n 7 New Zealand    Oceania    1952    69.4  1994794    10557.\n 8 United Kingdom Europe     1952    69.2 50430000     9980.\n 9 Australia      Oceania    1952    69.1  8691212    10040.\n10 Canada         Americas   1952    68.8 14785584    11367.\n# ℹ 1,694 more rows\n\n\n\n2.4 distinct() 함수\n특정 열(변수)에 의거해 중복이 없이 고유한 행만을 골라낸다. 행의 길이가 준다.\n\n# country 변수 안에 어떤 값들이 포함되어 있는지 확인\ngapminder |&gt; \n  distinct(country)\n\n# A tibble: 142 × 1\n   country    \n   &lt;fct&gt;      \n 1 Afghanistan\n 2 Albania    \n 3 Algeria    \n 4 Angola     \n 5 Argentina  \n 6 Australia  \n 7 Austria    \n 8 Bahrain    \n 9 Bangladesh \n10 Belgium    \n# ℹ 132 more rows\n\n\n.keep_all 아규먼트를 이용하면 나머지 열도 함께 나타낼 수 있다. 같은 값을 가진 행이 다수 존재한다면 가장 앞선 행을 보여준다.\n\n# continent 변수 안에 어떤 값들이 포함되어 있는지 나머지 열과 함께 확인\ngapminder |&gt; \n  distinct(continent, .keep_all = TRUE)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Albania     Europe     1952    55.2  1282697     1601.\n3 Algeria     Africa     1952    43.1  9279525     2449.\n4 Argentina   Americas   1952    62.5 17876956     5911.\n5 Australia   Oceania    1952    69.1  8691212    10040.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_04.html#열-함수",
    "href": "lab_04.html#열-함수",
    "title": "Lab04: 데이터 변형하기",
    "section": "\n3 열 함수",
    "text": "3 열 함수\n\n3.1 select() 함수\n열(변수)의 일부를 선택한다. 열의 길이가 준다.\n\n# year, country, gdpPercap 변수만 선택\ngapminder |&gt; \n  select(year, country, gdpPercap)\n\n# A tibble: 1,704 × 3\n    year country     gdpPercap\n   &lt;int&gt; &lt;fct&gt;           &lt;dbl&gt;\n 1  1952 Afghanistan      779.\n 2  1957 Afghanistan      821.\n 3  1962 Afghanistan      853.\n 4  1967 Afghanistan      836.\n 5  1972 Afghanistan      740.\n 6  1977 Afghanistan      786.\n 7  1982 Afghanistan      978.\n 8  1987 Afghanistan      852.\n 9  1992 Afghanistan      649.\n10  1997 Afghanistan      635.\n# ℹ 1,694 more rows\n\n\n열(변수)의 일부를 선택하지 않는다. 역시 열의 길이가 준다. 실질적으로 위와 동일하다.\n\n# lifeExp, continent, pop을 제외한 변수들만 선택\ngapminder |&gt; \n  select(-c(lifeExp, continent, pop))\n\n# A tibble: 1,704 × 3\n   country      year gdpPercap\n   &lt;fct&gt;       &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan  1952      779.\n 2 Afghanistan  1957      821.\n 3 Afghanistan  1962      853.\n 4 Afghanistan  1967      836.\n 5 Afghanistan  1972      740.\n 6 Afghanistan  1977      786.\n 7 Afghanistan  1982      978.\n 8 Afghanistan  1987      852.\n 9 Afghanistan  1992      649.\n10 Afghanistan  1997      635.\n# ℹ 1,694 more rows\n\n\nstarts_with(), ends_with(), contains()와 같은 도우미 함수를 잘 활용하면 효율적으로 필요한 변수만을 선정할 수 있다.\n\n# 이름이 \"c\"로 시작하는 변수들만 선택\ngapminder |&gt; \n  select(starts_with(\"c\"))\n\n# A tibble: 1,704 × 2\n   country     continent\n   &lt;fct&gt;       &lt;fct&gt;    \n 1 Afghanistan Asia     \n 2 Afghanistan Asia     \n 3 Afghanistan Asia     \n 4 Afghanistan Asia     \n 5 Afghanistan Asia     \n 6 Afghanistan Asia     \n 7 Afghanistan Asia     \n 8 Afghanistan Asia     \n 9 Afghanistan Asia     \n10 Afghanistan Asia     \n# ℹ 1,694 more rows\n\n\n\n3.2 mutate() 함수\n기존의 열(변수)에 기반하여 새로운 변수를 생성한다. 열의 길이가 는다.\n\n# 새롭게 정의한 gdp_billion 변수 추가\ngapminder |&gt; \n  mutate(\n    gdp_billion = gdpPercap * pop / 10^9\n  )\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap gdp_billion\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.        6.57\n 2 Afghanistan Asia       1957    30.3  9240934      821.        7.59\n 3 Afghanistan Asia       1962    32.0 10267083      853.        8.76\n 4 Afghanistan Asia       1967    34.0 11537966      836.        9.65\n 5 Afghanistan Asia       1972    36.1 13079460      740.        9.68\n 6 Afghanistan Asia       1977    38.4 14880372      786.       11.7 \n 7 Afghanistan Asia       1982    39.9 12881816      978.       12.6 \n 8 Afghanistan Asia       1987    40.8 13867957      852.       11.8 \n 9 Afghanistan Asia       1992    41.7 16317921      649.       10.6 \n10 Afghanistan Asia       1997    41.8 22227415      635.       14.1 \n# ℹ 1,694 more rows\n\n\n여러개의 변수를 동시에 생성할 수 있다. row_number() 도우미 함수는 값에 순위를 부여하는 것이고, .keep = \"used\"는 결과에 변수 생성에 동원된 변수만을 포함시키게 해 준다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; # year이 2007인 행만 선택 \n  mutate(\n    gdpPercap_rank = row_number(gdpPercap), # gdpPercap에 순위 부여\n    lifeExp_highlow = lifeExp &gt; 30, # lifeExp가 30을 넘으면 TRUE, 아니면 FALSE\n    .keep = \"used\" # 새로운 변수 생성에 사용한 변수들만 표시\n  )\n\n# A tibble: 142 × 4\n   lifeExp gdpPercap gdpPercap_rank lifeExp_highlow\n     &lt;dbl&gt;     &lt;dbl&gt;          &lt;int&gt; &lt;lgl&gt;          \n 1    43.8      975.             19 TRUE           \n 2    76.4     5937.             70 TRUE           \n 3    72.3     6223.             72 TRUE           \n 4    42.7     4797.             64 TRUE           \n 5    75.3    12779.            101 TRUE           \n 6    81.2    34435.            130 TRUE           \n 7    79.8    36126.            132 TRUE           \n 8    75.6    29796.            122 TRUE           \n 9    64.1     1391.             30 TRUE           \n10    79.4    33693.            128 TRUE           \n# ℹ 132 more rows\n\n\n\n3.3 rename() 함수\n변수의 이름을 바꾼다. 열의 길이에는 변화가 없다.\n\n# 변수의 이름 변경\ngapminder |&gt; \n  rename(\n    gdp_percap = gdpPercap,\n    left_exp = lifeExp\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year left_exp      pop gdp_percap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;      &lt;dbl&gt;\n 1 Afghanistan Asia       1952     28.8  8425333       779.\n 2 Afghanistan Asia       1957     30.3  9240934       821.\n 3 Afghanistan Asia       1962     32.0 10267083       853.\n 4 Afghanistan Asia       1967     34.0 11537966       836.\n 5 Afghanistan Asia       1972     36.1 13079460       740.\n 6 Afghanistan Asia       1977     38.4 14880372       786.\n 7 Afghanistan Asia       1982     39.9 12881816       978.\n 8 Afghanistan Asia       1987     40.8 13867957       852.\n 9 Afghanistan Asia       1992     41.7 16317921       649.\n10 Afghanistan Asia       1997     41.8 22227415       635.\n# ℹ 1,694 more rows\n\n\n패밀리 함수인 rename_with()를 이용하면 다른 것도 가능하다.\n\n# \"l\"로 시작하는 변수를 전부 소문자로 변경\ngapminder |&gt; \n  rename_with(\n    tolower, starts_with(\"l\")\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeexp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n3.4 relocate() 함수\n변수의 위치를 바꾼다. 열의 길이에는 변화가 없다.\n\n# year 변수의 위치를 continent 앞으로 이동\ngapminder |&gt; \n  relocate(year, continent)\n\n# A tibble: 1,704 × 6\n    year continent country     lifeExp      pop gdpPercap\n   &lt;int&gt; &lt;fct&gt;     &lt;fct&gt;         &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1  1952 Asia      Afghanistan    28.8  8425333      779.\n 2  1957 Asia      Afghanistan    30.3  9240934      821.\n 3  1962 Asia      Afghanistan    32.0 10267083      853.\n 4  1967 Asia      Afghanistan    34.0 11537966      836.\n 5  1972 Asia      Afghanistan    36.1 13079460      740.\n 6  1977 Asia      Afghanistan    38.4 14880372      786.\n 7  1982 Asia      Afghanistan    39.9 12881816      978.\n 8  1987 Asia      Afghanistan    40.8 13867957      852.\n 9  1992 Asia      Afghanistan    41.7 16317921      649.\n10  1997 Asia      Afghanistan    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n.before나 .after 아규먼트를 사용하여 해당 변수를 어떤 변수의 앞이나 뒤로 보낼 수 있다.\n\n# pop 변수의 위치를 lifeExp 앞으로 이동\ngapminder |&gt; \n  relocate(pop, .before = lifeExp )\n\n# A tibble: 1,704 × 6\n   country     continent  year      pop lifeExp gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;    &lt;int&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952  8425333    28.8      779.\n 2 Afghanistan Asia       1957  9240934    30.3      821.\n 3 Afghanistan Asia       1962 10267083    32.0      853.\n 4 Afghanistan Asia       1967 11537966    34.0      836.\n 5 Afghanistan Asia       1972 13079460    36.1      740.\n 6 Afghanistan Asia       1977 14880372    38.4      786.\n 7 Afghanistan Asia       1982 12881816    39.9      978.\n 8 Afghanistan Asia       1987 13867957    40.8      852.\n 9 Afghanistan Asia       1992 16317921    41.7      649.\n10 Afghanistan Asia       1997 22227415    41.8      635.\n# ℹ 1,694 more rows",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_04.html#그룹-함수",
    "href": "lab_04.html#그룹-함수",
    "title": "Lab04: 데이터 변형하기",
    "section": "\n4 그룹 함수",
    "text": "4 그룹 함수\n\n4.1 group_by() 함수\n특정 범주 열(변수)에 의거해 행을 분할한다. 행의 길이는 변하지 않는다.\n하나의 범주 변수에 의거해 그룹화한다. 산출물을 보면 year에 의거해 행이 12개의 그룹으로 나누어졌음이 나타나 있다(두 번째 줄: Group: year [12]).\n\n# year을 기준으로 그룹화\ngapminder |&gt; \n  group_by(year)\n\n# A tibble: 1,704 × 6\n# Groups:   year [12]\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n두 개 이상의 범주 변수에 의거해 그룹화할 수도 있다.\n\n# year, continent를 기준으로 그룹화\ngapminder |&gt; \n  group_by(year, continent)\n\n# A tibble: 1,704 × 6\n# Groups:   year, continent [60]\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n4.2 summarize() 함수\n주어진 열(변수)에 대한 통계 요약값을 계산하고 그것으로 이루어진 새로운 데이터 프레임을 생성한다. 엄밀히 말해 기존 열(변수)을 변형한다기 보다는 기존 데이터 프레임으로부터 새로운 데이터 프레임을 생성한다고 볼 수 있다. summarize() 함수는 대부분의 경우 group_by() 함수와 함께 사용된다. 다음의 둘을 비교해 보라.\n\n# 2007년 전체의 gdpPercap의 평균 계산\ngapminder |&gt; \n  filter(year == 2007) |&gt; # year이 2007인 행만 선택\n  summarize(mean_gdpPercap = mean(gdpPercap)) # gdpPercap의 평균값 계산\n\n# A tibble: 1 × 1\n  mean_gdpPercap\n           &lt;dbl&gt;\n1         11680.\n\n\n\n# 2007년 대륙별 gdpPercap의 평균 계산\ngapminder |&gt; \n  filter(year == 2007) |&gt; # year이 2007인 행만 선택\n  group_by(continent) |&gt;  # continent를 기준으로 그룹화\n  summarize(mean_gdpPercap = mean(gdpPercap)) # gdpPercap의 평균값 계산\n\n# A tibble: 5 × 2\n  continent mean_gdpPercap\n  &lt;fct&gt;              &lt;dbl&gt;\n1 Africa             3089.\n2 Americas          11003.\n3 Asia              12473.\n4 Europe            25054.\n5 Oceania           29810.\n\n\n좀 더 복잡한 확장이 가능하다. 마지막의 n()은 자동으로 생성되는 그룹별 빈도값이다.\n\n# continent, year별로 다양한 통계값 산출\ngapminder |&gt; \n    group_by(continent, year) |&gt; # continent, year을 기준으로 그룹화\n    summarize(\n      mean_gdpPercap = mean(gdpPercap), # gdpPercap의 평균값 계산\n      sd_gdpPercap = sd(gdpPercap), # gdpPercap의 표준편차 계산\n      mean_pop = mean(pop), # pop의 평균값 계산\n      sd_pop = sd(pop), # pop의 표준편차 계산\n      n = n() # 그룹에 포함된 행의 개수\n      )\n\n# A tibble: 60 × 7\n# Groups:   continent [5]\n   continent  year mean_gdpPercap sd_gdpPercap  mean_pop    sd_pop     n\n   &lt;fct&gt;     &lt;int&gt;          &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;\n 1 Africa     1952          1253.         983.  4570010.  6317450.    52\n 2 Africa     1957          1385.        1135.  5093033.  7076042.    52\n 3 Africa     1962          1598.        1462.  5702247.  7957545.    52\n 4 Africa     1967          2050.        2848.  6447875.  8985505.    52\n 5 Africa     1972          2340.        3287.  7305376. 10130833.    52\n 6 Africa     1977          2586.        4142.  8328097. 11585184.    52\n 7 Africa     1982          2482.        3243.  9602857. 13456243.    52\n 8 Africa     1987          2283.        2567. 11054502. 15277484.    52\n 9 Africa     1992          2282.        2644. 12674645. 17562719.    52\n10 Africa     1997          2379.        2821. 14304480. 19873013.    52\n# ℹ 50 more rows\n\n\ngroup_by()와 arrange()를 결합하는 경우, .by_group = TRUE를 하면 그룹별로 행을 배열할 수 있다.\n\n# year, continent 그룹별로 gdpPercap 내림차순 정렬\ngapminder |&gt; \n  group_by(year, continent) |&gt; # year, continent를 기준으로 그룹화\n  arrange(desc(gdpPercap), .by_group = TRUE) # 그룹별로 gdpPercap 내림차순 정렬\n\n# A tibble: 1,704 × 6\n# Groups:   year, continent [60]\n   country      continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 South Africa Africa     1952    45.0 14264935     4725.\n 2 Gabon        Africa     1952    37.0   420702     4293.\n 3 Angola       Africa     1952    30.0  4232095     3521.\n 4 Reunion      Africa     1952    52.7   257700     2719.\n 5 Djibouti     Africa     1952    34.8    63149     2670.\n 6 Algeria      Africa     1952    43.1  9279525     2449.\n 7 Namibia      Africa     1952    41.7   485831     2424.\n 8 Libya        Africa     1952    42.7  1019729     2388.\n 9 Congo, Rep.  Africa     1952    42.1   854885     2126.\n10 Mauritius    Africa     1952    51.0   516556     1968.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\n힌트.by_group = TRUE를 사용하지 않은 경우\n\n\n\n\n\n.by_group = TRUE를 붙이지 않으면 그냥 arrange()를 사용한 것과 같은 결과가 나온다.\n\n# .by_group = TRUE를 사용하지 않은 경우\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  arrange(desc(gdpPercap))\n\n# A tibble: 1,704 × 6\n# Groups:   year, continent [60]\n   country   continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Kuwait    Asia       1957    58.0  212846   113523.\n 2 Kuwait    Asia       1972    67.7  841934   109348.\n 3 Kuwait    Asia       1952    55.6  160000   108382.\n 4 Kuwait    Asia       1962    60.5  358266    95458.\n 5 Kuwait    Asia       1967    64.6  575003    80895.\n 6 Kuwait    Asia       1977    69.3 1140357    59265.\n 7 Norway    Europe     2007    80.2 4627926    49357.\n 8 Kuwait    Asia       2007    77.6 2505559    47307.\n 9 Singapore Asia       2007    80.0 4553009    47143.\n10 Norway    Europe     2002    79.0 4535591    44684.\n# ℹ 1,694 more rows\n\n\n\ngapminder |&gt; \n  arrange(desc(gdpPercap))\n\n# A tibble: 1,704 × 6\n   country   continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Kuwait    Asia       1957    58.0  212846   113523.\n 2 Kuwait    Asia       1972    67.7  841934   109348.\n 3 Kuwait    Asia       1952    55.6  160000   108382.\n 4 Kuwait    Asia       1962    60.5  358266    95458.\n 5 Kuwait    Asia       1967    64.6  575003    80895.\n 6 Kuwait    Asia       1977    69.3 1140357    59265.\n 7 Norway    Europe     2007    80.2 4627926    49357.\n 8 Kuwait    Asia       2007    77.6 2505559    47307.\n 9 Singapore Asia       2007    80.0 4553009    47143.\n10 Norway    Europe     2002    79.0 4535591    44684.\n# ℹ 1,694 more rows\n\n\n\n\n\n아래는 연도별/대륙별로 일인당 GDP가 가장 높은 국가를 추출한 것이다. 코드를 생각해 보라. Code를 누르면 답을 확인할 수 있다.\n\n\nOutput\nCode\n\n\n\n\n\n# A tibble: 60 × 6\n# Groups:   year, continent [60]\n   country       continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 South Africa  Africa     1952    45.0  14264935     4725.\n 2 United States Americas   1952    68.4 157553000    13990.\n 3 Kuwait        Asia       1952    55.6    160000   108382.\n 4 Switzerland   Europe     1952    69.6   4815000    14734.\n 5 New Zealand   Oceania    1952    69.4   1994794    10557.\n 6 South Africa  Africa     1957    48.0  16151549     5487.\n 7 United States Americas   1957    69.5 171984000    14847.\n 8 Kuwait        Asia       1957    58.0    212846   113523.\n 9 Switzerland   Europe     1957    70.6   5126000    17909.\n10 New Zealand   Oceania    1957    70.3   2229407    12247.\n# ℹ 50 more rows\n\n\n\n\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  slice_max(gdpPercap)\n\n\n\n\ngroup_by() 함수가 한 번 적용되면, 그 뒤의 모든 오퍼레이션에 그룹 분할이 적용되기 때문에 예기치 못한 일이 발생할 수 있다. 이것을 회피하기 위해 두 가지 옵션이 있다. 첫번째 방법은 마지막에 upgroup() 함수를 첨가하는 것이다.\n\n# 그룹화를 해제하고 year, continent별로 gdpPercap이 가장 높은 국가 선택\ngapminder |&gt; \n  group_by(year, continent) |&gt; # year, continent를 기준으로 그룹화\n  slice_max(gdpPercap) |&gt; # 그룹에서 gdpPercap이 가장 높은 행 선택\n  ungroup() # 그룹화 해제\n\n# A tibble: 60 × 6\n   country       continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 South Africa  Africa     1952    45.0  14264935     4725.\n 2 United States Americas   1952    68.4 157553000    13990.\n 3 Kuwait        Asia       1952    55.6    160000   108382.\n 4 Switzerland   Europe     1952    69.6   4815000    14734.\n 5 New Zealand   Oceania    1952    69.4   1994794    10557.\n 6 South Africa  Africa     1957    48.0  16151549     5487.\n 7 United States Americas   1957    69.5 171984000    14847.\n 8 Kuwait        Asia       1957    58.0    212846   113523.\n 9 Switzerland   Europe     1957    70.6   5126000    17909.\n10 New Zealand   Oceania    1957    70.3   2229407    12247.\n# ℹ 50 more rows\n\n\n두 번째 방법은 group_by() 함수 대신 by 아규먼트를 사용하는 것이다. 결과가 달라보이겠지만 정렬의 차이일 뿐 동일하다.\n\n# year, continent 기준으로 gdpPercap이 가장 높은 행 선택\ngapminder |&gt; \n  slice_max(gdpPercap, by = c(year, continent)) \n\n# A tibble: 60 × 6\n   country      continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Kuwait       Asia       1952    55.6   160000   108382.\n 2 Kuwait       Asia       1957    58.0   212846   113523.\n 3 Kuwait       Asia       1962    60.5   358266    95458.\n 4 Kuwait       Asia       1967    64.6   575003    80895.\n 5 Kuwait       Asia       1972    67.7   841934   109348.\n 6 Kuwait       Asia       1977    69.3  1140357    59265.\n 7 Saudi Arabia Asia       1982    63.0 11254672    33693.\n 8 Kuwait       Asia       1987    74.2  1891487    28118.\n 9 Kuwait       Asia       1992    75.2  1418095    34933.\n10 Kuwait       Asia       1997    76.2  1765345    40301.\n# ℹ 50 more rows\n\n\n\n4.3 count() 함수\n특정 범주 열(변수)에 의거한 빈도를 빠르게 계산해 준다.\n\n# year, continent별 행 개수 계산\ngapminder |&gt; \n  count(year, continent)\n\n# A tibble: 60 × 3\n    year continent     n\n   &lt;int&gt; &lt;fct&gt;     &lt;int&gt;\n 1  1952 Africa       52\n 2  1952 Americas     25\n 3  1952 Asia         33\n 4  1952 Europe       30\n 5  1952 Oceania       2\n 6  1957 Africa       52\n 7  1957 Americas     25\n 8  1957 Asia         33\n 9  1957 Europe       30\n10  1957 Oceania       2\n# ℹ 50 more rows\n\n\nwt 아규먼트를 사용하면 빈도가 아니라 범주별 특정 변수의 합산값을 구할 수 있다.\n\n# year, continent별 pop의 합산값 계산\ngapminder |&gt; \n  count(year, continent, wt = pop)\n\n# A tibble: 60 × 3\n    year continent          n\n   &lt;int&gt; &lt;fct&gt;          &lt;dbl&gt;\n 1  1952 Africa     237640501\n 2  1952 Americas   345152446\n 3  1952 Asia      1395357351\n 4  1952 Europe     418120846\n 5  1952 Oceania     10686006\n 6  1957 Africa     264837738\n 7  1957 Americas   386953916\n 8  1957 Asia      1562780599\n 9  1957 Europe     437890351\n10  1957 Oceania     11941976\n# ℹ 50 more rows\n\n\n위의 두 개를 한 번에 실행할 수 있다.\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; # year, continent를 기준으로 그룹화\n  summarize(\n    n = n(), # 그룹별 행 개수 계산\n    sum_pop = sum(pop) # 그룹별 pop의 합산값 계산\n  )\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent     n    sum_pop\n   &lt;int&gt; &lt;fct&gt;     &lt;int&gt;      &lt;dbl&gt;\n 1  1952 Africa       52  237640501\n 2  1952 Americas     25  345152446\n 3  1952 Asia         33 1395357351\n 4  1952 Europe       30  418120846\n 5  1952 Oceania       2   10686006\n 6  1957 Africa       52  264837738\n 7  1957 Americas     25  386953916\n 8  1957 Asia         33 1562780599\n 9  1957 Europe       30  437890351\n10  1957 Oceania       2   11941976\n# ℹ 50 more rows\n\n\n\n4.4 across() 함수\n다수의 열(변수)에 동일한 함수를 적용할 수 있다.\n\n# lifeExp와 gdpPercap을 반올림\ngapminder |&gt; \n  mutate(\n    across(c(lifeExp, gdpPercap), round)\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952      29  8425333       779\n 2 Afghanistan Asia       1957      30  9240934       821\n 3 Afghanistan Asia       1962      32 10267083       853\n 4 Afghanistan Asia       1967      34 11537966       836\n 5 Afghanistan Asia       1972      36 13079460       740\n 6 Afghanistan Asia       1977      38 14880372       786\n 7 Afghanistan Asia       1982      40 12881816       978\n 8 Afghanistan Asia       1987      41 13867957       852\n 9 Afghanistan Asia       1992      42 16317921       649\n10 Afghanistan Asia       1997      42 22227415       635\n# ℹ 1,694 more rows\n\n\n이것은 다음과 동일하다.\n\ngapminder |&gt; \n  mutate(\n    lifeExp = round(lifeExp), # lifeExp를 반올림한 새로운 변수 생성\n    gdpPercap = round(gdpPercap) # gdpPercap을 반올림한 새로운 변수 생성\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952      29  8425333       779\n 2 Afghanistan Asia       1957      30  9240934       821\n 3 Afghanistan Asia       1962      32 10267083       853\n 4 Afghanistan Asia       1967      34 11537966       836\n 5 Afghanistan Asia       1972      36 13079460       740\n 6 Afghanistan Asia       1977      38 14880372       786\n 7 Afghanistan Asia       1982      40 12881816       978\n 8 Afghanistan Asia       1987      41 13867957       852\n 9 Afghanistan Asia       1992      42 16317921       649\n10 Afghanistan Asia       1997      42 22227415       635\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\n힌트\n\n\n\n새롭게 생성한 변수가 기존 변수와 이름이 같은 경우 기존 변수를 대체한다.\n\n\nsummarize() 함수와 결합하여 선택된 변수에 특정 함수를 적용하고 그 결과의 이름을 변수명과 함수명을 사용하여 부여할 수 있다.\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; # year, continent를 기준으로 그룹화\n  summarize(across(c(lifeExp, gdpPercap), mean, # lifeExp와 gdpPercap의 평균값 계산\n                   .names = \"mean_{.col}\")) # 새롭게 생성된 변수의 이름을 \"mean_기존 이름\"으로 설정\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent mean_lifeExp mean_gdpPercap\n   &lt;int&gt; &lt;fct&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n 1  1952 Africa            39.1          1253.\n 2  1952 Americas          53.3          4079.\n 3  1952 Asia              46.3          5195.\n 4  1952 Europe            64.4          5661.\n 5  1952 Oceania           69.3         10298.\n 6  1957 Africa            41.3          1385.\n 7  1957 Americas          56.0          4616.\n 8  1957 Asia              49.3          5788.\n 9  1957 Europe            66.7          6963.\n10  1957 Oceania           70.3         11599.\n# ℹ 50 more rows\n\n\n\n4.5 c_across() 함수\ngroup_by() 함수와 across() 함수가 결합하는 것과 정반대로, rowwise() 함수와 c_across() 함수를 결합하며, 행별 통계값을 산출할 수 있다. 물론 여기서 sd 값은 아무런 의미가 없다.\n\ngapminder |&gt; \n  rowwise() |&gt; # 행별로 그룹화\n  mutate(\n    sd = sd(c_across(where(is.numeric))) # 각 행에서 숫자인 값들의 표준편차 계산\n  )\n\n# A tibble: 1,704 × 7\n# Rowwise: \n   country     continent  year lifeExp      pop gdpPercap        sd\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  4212207.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  4619999.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  5133067.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  5768510.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  6539272.\n 6 Afghanistan Asia       1977    38.4 14880372      786.  7439719.\n 7 Afghanistan Asia       1982    39.9 12881816      978.  6440408.\n 8 Afghanistan Asia       1987    40.8 13867957      852.  6933499.\n 9 Afghanistan Asia       1992    41.7 16317921      649.  8158513.\n10 Afghanistan Asia       1997    41.8 22227415      635. 11113262.\n# ℹ 1,694 more rows",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_03.html",
    "href": "lab_03.html",
    "title": "Lab03: 데이터 불러오기와 정리하기",
    "section": "",
    "text": "티블(tibble)에 대해 이해할 수 있다.\n다양한 형식의 데이터를 원하는 형태로 불러올 수 있다. (데이터 불러오기)\n데이터를 늘이고, 넓히고, 서로 결합할 수 있다. (데이터 정리하기)",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab03: 데이터 불러오기와 정리하기"
    ]
  },
  {
    "objectID": "lab_03.html#실습의-목표",
    "href": "lab_03.html#실습의-목표",
    "title": "Lab03: 데이터 불러오기와 정리하기",
    "section": "",
    "text": "티블(tibble)에 대해 이해할 수 있다.\n다양한 형식의 데이터를 원하는 형태로 불러올 수 있다. (데이터 불러오기)\n데이터를 늘이고, 넓히고, 서로 결합할 수 있다. (데이터 정리하기)",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab03: 데이터 불러오기와 정리하기"
    ]
  },
  {
    "objectID": "lab_03.html#티블tibble",
    "href": "lab_03.html#티블tibble",
    "title": "Lab03: 데이터 불러오기와 정리하기",
    "section": "\n1 티블(tibble)",
    "text": "1 티블(tibble)\n실습을 시작하기에 앞서 tidyverse 패키지를 불러오자. 설치는 이미 지난 시간에 했기 때문에 오늘은 library()함수를 통해 패키지를 불러오기만 하면 된다.\n\nlibrary(tidyverse)\n\n\n\n\n\n\n\n중요\n\n\n\n왼쪽 위 Editor 창에서 코드를 실행하기 위해서는 그냥 enter가 아니라 ctrl+enter(Mac은 cmd+enter)를 눌러야 한다.\n\n\n\n1.1 티블 생성하기\n\n1.1.1 기존 데이터를 티블 포맷으로 변환하기\nBase R에 포함되어 있는 iris라는 데이터 프레임을 사용한다. 우선 지난 시간에 배운 파이프 연산자(pipe operator)를 가지고 iris 데이터를 살펴보자.\n\niris |&gt; \n  glimpse()  \n\nRows: 150\nColumns: 5\n$ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n\n\nclass() 함수를 통해 iris 데이터의 형식이 data.frame인 것을 확인할 수 있다.\n\nclass(iris)\n\n[1] \"data.frame\"\n\n\nas_tibble() 함수를 이용하여 tibble 객체로 전환한다. 그러면 data.frame 객체가 tibble 객체로 전환된 것을 알 수 있다.\n\niris_tbl &lt;- iris |&gt; \n  as_tibble() \nclass(iris_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n1.1.2 티블 객체를 직접 생성하기\ntibble 객체를 직접 생성하는 방식은 두 가지로 나뉜다.\n\n열-단위 방식(보다 일반적): 우선 열-벡터를 만들고 그것을 결합해 최종적인 tibble 객체를 만든다. tibble() 함수를 이용한다.\n\n\n# 열-벡터를 만들고 이들을 결합하여 최종적인 tibble 객체 생성\ntibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n\n# A tibble: 3 × 3\n      x y         z\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 h      0.08\n2     2 m      0.83\n3     5 g      0.6 \n\n\n\n# 수식 등을 활용해서도 tibble 객체를 생성할 수 있다.\ntibble(\n  x = 1:5, \n  y = 1, \n  z = x ^ 2 + y\n)\n\n# A tibble: 5 × 3\n      x     y     z\n  &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     1     2\n2     2     1     5\n3     3     1    10\n4     4     1    17\n5     5     1    26\n\n\n\n행-단위 방식: 우선 행-벡터를 만들고 그것을 결합해 최종적인 tibble 객체를 만든다. tribble() 함수를 이용한다. tribble은 전치티블(transposed tibble)의 약자이다.\n\n\n# 행-벡터를 만들고 이들을 결합하여 최종적인 tibble 객체 생성\ntribble(\n  ~x, ~y, ~z,\n  1, \"h\", 0.08,\n  2, \"m\", 0.83,\n  5, \"g\", 0.60\n)\n\n# A tibble: 3 × 3\n      x y         z\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 h      0.08\n2     2 m      0.83\n3     5 g      0.6",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab03: 데이터 불러오기와 정리하기"
    ]
  },
  {
    "objectID": "lab_03.html#데이터-불러오기",
    "href": "lab_03.html#데이터-불러오기",
    "title": "Lab03: 데이터 불러오기와 정리하기",
    "section": "\n2 데이터 불러오기",
    "text": "2 데이터 불러오기\n\n2.1 readr 패키지\n\n2.1.1 파일 형식\nreadr 패키지는 다양한 함수를 이용해 다양한 형식의 데이터를 불러올 수 있게 도와준다.\n\nread_csv(): 콤마분리(comma-separated values, CSV) 형식의 파일\nread_csv2(): 세미콜론분리(semicolon-separated) 형식의 파일\nread_tsv(): 탭구분(tab-delimited) 형식의 파일\nread_delim(): 여타의 구분 형식의 파일\nread_fwf(): 고정폭(fixed-width) 형식의 파일\nread_table(): 공백구분 형식의 파일\nread_log(): 아파치 형식(Apache-style)의 로그 파일\n\n2.1.2 read_csv() 함수의 활용\n지난번 실습에서 사용한 데이터를 면밀히 살펴본다.\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\nstudents\n\n# A tibble: 6 × 5\n  `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n         &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n2            2 Barclay Lynn     French fries       Lunch only          5    \n3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n6            6 Güvenç Attila    Ice cream          Lunch only          6    \n\n\n다음의 몇 가지 점이 불만족스럽다.\n\n변수명: 특히 Student ID와 Full Name 변수명은 규칙에 어긋난다. 변수명 속에 공란이 있으면 좋지 않다. 이런 이름을 비구문명(non-syntactic name)이라고 하고, ``로 둘러싸여 표시된다. 나중에 다른 분석을 할 때 문제를 일으킬 수 있기 때문에 바꿔주는 것이 좋다.\n변수 형식: mealPlan은 문자형(chr)이 아니라 팩트형(fct)이, AGE는 문자형(chr)이 아니라 수치형(dbl)이 적절하다.\n결측치(NA): favourite.food의 ’N/A’는 형식에 맞지 않아 결측치가 아니라 문자로 취급된다. 따라서 ’N/A’가 결측치임을 알려주어야 한다.\n\n\nstudents &lt;- read_csv(\n  \"https://pos.it/r4ds-students-csv\", \n  skip = 1, # 첫 행을 건너뛰기\n  col_names = c(\"student_id\", \"full_name\", \"favorite_food\", \"meal_plan\", \"age\"), # 새로운 변수명 지정\n  col_types = cols( \n    meal_plan = col_factor(),\n    age = col_number()), # 변수별 타입 지정\n  na = \"N/A\" # 문자 \"N/A\"를 결측치 NA로 수정\n  )\nstudents\n\n# A tibble: 6 × 5\n  student_id full_name        favorite_food      meal_plan             age\n       &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n2          2 Barclay Lynn     French fries       Lunch only              5\n3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n4          4 Leon Rossini     Anchovies          Lunch only             NA\n5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch    NA\n6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n\n\n2.2 엑셀 파일\n\n2.2.1 readxl 패키지\n가장 널리 사용되는 스프레드시트(spreadsheet) 형식인 엑셀 파일을 불러들이기 위해서는 readxl이라는 패키지가 필요하다. tidyverse의 핵심 패키지는 아니지만 일종의 친척 패키지라 할 수는 있다. tidyverse에 포함되어 있지 않기 때문에 따로 인스톨하고 library() 함수를 통해 불러와야 한다.\n\nlibrary(readxl)\n\n가장 널리 사용되는 명령어는 다음의 세 가지이다.\n\nread_xls(): xls 포맷의 엑셀 파일 불러오기\nread_xlsx(): xlsx 포맷의 엑셀 파일 불러오기\nread_excel(): xls, xlsx 포맷의 엑셀 파일 불러오기\n\n2.2.2 read_excel() 함수의 활용\nWorld Population Prospects 2022 데이터를 직접 다운받아 실습을 진행하고자 한다. 이 데이터셋은 매우 중요하다. 다음의 절차에 따라 해당 엑셀 파일을 다운로드한다.\n\nWPP 웹사이트(https://population.un.org/wpp/)에 접속한다.\nDownload Data Files를 클릭한다.\n\n\n\n다음의 파일을 클릭한다: Compact (most used: estimates and medium projections) (XLSX, 24.07 MB)\n\n\n\n엑셀 파일(WPP2022_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT_REV1)을 다운로드하여 자신의 프로젝트 폴더에 저장한다. 프로젝트 폴더에 저장하지 않으면 따로 경로를 설정해주어야 한다.\n\nR 바깥에서 다운로드한 파일을 열어 어떠한 정보가 어떠한 방식으로 수록되어 있는지 살펴본다. 데이터 불러오기를 위해 다음의 네 가지 사항에 유의해야 함을 이해한다.\n\n16번 행까지는 불필요한 영역이다.\n17번 행을 변수명으로 사용할 경우 많은 문제점이 발생한다.\n결측치는 공란이거나 ‘…’ 기호로 표시되어 있다.\n첫 번째 워킹시트(Estimates)에는 1950~2021의 데이터가, 두 번째 워킹시트(Medium variant)에는 2022~2100년의 데이터가 수록되어 있다. 나중에 결합해야한다.\n\n우선 엑셀 파일을 그대로 불러와 본다.\n\nread_excel(\n  \"WPP2022_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT_REV1.xlsx\", \n  sheet = \"Estimates\" \n  )\n\n# A tibble: 20,608 × 65\n   ...1  ...2  ...3  ...4  `United Nations`  ...6  ...7  ...8  ...9  ...10 ...11\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;             &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  Population Divis… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 2 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  Department of Ec… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 3 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;              &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 4 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  World Population… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 5 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  File GEN/01/REV1… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 6 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  Estimates, 1950 … &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 7 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  POP/DB/WPP/Rev.2… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 8 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  © July 2022 by U… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 9 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  Suggested citati… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n10 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;              &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n# ℹ 20,598 more rows\n# ℹ 54 more variables: ...12 &lt;chr&gt;, ...13 &lt;chr&gt;, ...14 &lt;chr&gt;, ...15 &lt;chr&gt;,\n#   ...16 &lt;chr&gt;, ...17 &lt;chr&gt;, ...18 &lt;chr&gt;, ...19 &lt;chr&gt;, ...20 &lt;chr&gt;,\n#   ...21 &lt;chr&gt;, ...22 &lt;chr&gt;, ...23 &lt;chr&gt;, ...24 &lt;chr&gt;, ...25 &lt;chr&gt;,\n#   ...26 &lt;chr&gt;, ...27 &lt;chr&gt;, ...28 &lt;chr&gt;, ...29 &lt;chr&gt;, ...30 &lt;chr&gt;,\n#   ...31 &lt;chr&gt;, ...32 &lt;chr&gt;, ...33 &lt;chr&gt;, ...34 &lt;chr&gt;, ...35 &lt;chr&gt;,\n#   ...36 &lt;chr&gt;, ...37 &lt;chr&gt;, ...38 &lt;chr&gt;, ...39 &lt;chr&gt;, ...40 &lt;chr&gt;, …\n\n\n끔찍할 것이다. 아래의 과정을 거쳐 사용할 수 있는 데이터로 바꾸어 불러온다.\n우선 새로운 변수명들을 하나의 벡터로 만든다.\n\n# 새롭게 사용될 변수명 지정\nnew_names &lt;- c(\"index\", \"variant\", \"region_name\", \"notes\", \"location_code\", \n                \"ISO3\", \"ISO2\", \"SDMX\", \"type\", \"parent_code\", \"year\", \"pop_jan_total\", \n                \"pop_jul_total\", \"pop_jul_male\", \"pop_jul_female\", \"pop_den\", \"sex_ratio\", \n                \"median_age\", \"natural_change\", \"RNC\", \"pop_change\", \"PGR\", \n                \"dubling_time\", \"births\", \"births_by_f1519\", \"CBR\", \"TFR\", \"NRR\", \n                \"mean_age_childbearing\", \"sex_ratio_birth\", \"deaths_total\", \n                \"deaths_male\", \"deaths_female\", \"CDR\", \"life_exp_total\", \n                \"life_exp_male\", \"life_exp_female\", \"life_exp_15_total\", \n                \"life_exp_15_male\", \"life_exp_15_female\", \"life_exp_65_total\", \n                \"life_exp_65_male\", \"life_exp_65_female\", \"life_exp_80_total\", \n                \"life_exp_80_male\", \"life_exp_80_female\", \"infant_deaths\", \n                \"IMR\", \"live_births\", \"under_five_deaths\", \"mort_under_five\", \n                \"mort_bf_40_total\", \"mort_bf_40_male\", \"mort_bf_40_female\", \"mort_bf_60_total\", \n                \"mort_bf_60_male\", \"mort_bf_60_female\", \"mort_bt_1550_total\", \n                \"mort_bt_1550_male\", \"mort_bt_1550_female\", \"mort_bt_1560_total\", \n                \"mort_bt_1560_male\", \"mort_bt_1560_female\", \"net_migrants\", \"NMR\")\n\n앞에서 했던 과정과 유사하게 필요한 내용들을 수정하여 엑셀 파일을 불러온다.\n\n# Estimates 시트 정리\nwpp_2022_estimates &lt;- read_excel(\n  \"WPP2022_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT_REV1.xlsx\",\n  sheet = \"Estimates\",\n  skip = 17, \n  col_names = new_names,\n  col_types = c(rep(\"guess\", 3), \"text\", \"guess\", rep(\"text\", 2), rep(\"guess\", 58)),\n  na = c(\"...\", \"\")\n  )\n\n# Medium variant 시트 정리\nwpp_2022_future &lt;- read_excel(\n  \"WPP2022_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT_REV1.xlsx\",\n  sheet = \"Medium variant\",\n  skip = 17, \n  col_names = new_names,\n  col_types = c(rep(\"guess\", 3), \"text\", \"guess\", rep(\"text\", 2), rep(\"guess\", 58)),\n  na = c(\"...\", \"\")\n)\n\n# 행 단위로 결합\nwpp_2022 &lt;- bind_rows(wpp_2022_estimates, wpp_2022_future)\n\n# 새 창에서 보기\nView(wpp_2022)\n\n\n\n\n\n\n\n힌트rep() 함수\n\n\n\n\n\nrep()함수는 Basic R 함수로 값들을 반복하는 데 사용된다.\n\n# 벡터 전체를 반복\nrep(c(\"A\", \"B\", \"C\"), 3)\n\n[1] \"A\" \"B\" \"C\" \"A\" \"B\" \"C\" \"A\" \"B\" \"C\"\n\nrep(c(\"A\", \"B\", \"C\"), times = 3)\n\n[1] \"A\" \"B\" \"C\" \"A\" \"B\" \"C\" \"A\" \"B\" \"C\"\n\n\n\n# 벡터의 각 요소들을 반복\nrep(c(\"A\", \"B\", \"C\"), each = 2)\n\n[1] \"A\" \"A\" \"B\" \"B\" \"C\" \"C\"\n\n\n\n# 벡터의 각 요소들을 반복하고 그 전체를 다시 반복\nrep(c(\"A\", \"B\", \"C\"), each = 2, times = 2)\n\n [1] \"A\" \"A\" \"B\" \"B\" \"C\" \"C\" \"A\" \"A\" \"B\" \"B\" \"C\" \"C\"\n\n\n\n\n\n해야 할 일이 한가지 더 남아있다. 많은 변수 중에 데이터 탐색이라는 측면에서 가장 중요한 것은 type 변수이다. 다음을 통해 distinct()함수를 통해 type 변수에 어떤 내용이 담겨 있는지 확인한다.\n\nwpp_2022 |&gt; \n  distinct(type) # type 변수에 어떤 값들이 들어가 있는지 확인\n\n# A tibble: 9 × 1\n  type             \n  &lt;chr&gt;            \n1 World            \n2 Label/Separator  \n3 SDG region       \n4 Development Group\n5 Special other    \n6 Income Group     \n7 Region           \n8 Subregion        \n9 Country/Area     \n\n\ndistinct() 함수의 결과를 통해 세계 전체(World), 국가군(SDG region, Region 등), 국가(Country/Area) 등으로 데이터를 활용할 수 있다는 것을 인지한다. 그런데, “Label/Separator”는 엑셀 내에서 분할선의 역할만 하는 것으로, 무의미한 값이다. 따라서 이를 제거한다.\n\nwpp_2022 &lt;- wpp_2022 |&gt; \n  filter(type != \"Label/Separator\") # type 변수의 값이 \"Label/Separator\"가 아닌 행만 추출\n\n나중에 사용하기 위해, writexl 패키지의 write_xlsx() 함수를 이용하여 엑셀 파일로 저장한다.\n\nlibrary(writexl)\nwrite_xlsx(wpp_2022, \"wpp_2022.xlsx\")\n\n그런데, 저장된 파일을 read_excel() 함수로 다시 불러 들이면 컬럼 형식에 대한 정보가 사라져 버리는 등의 에러가 발생한다. 이런 점 때문에 다음과 같은 대안이 존재한다. readr 패키지의 write_rds() 함수로 저장하고, 다시 read_rds() 함수로 불러들이면 정확히 동일한 것을 얻을 수 있다.\n\nwrite_rds(wpp_2022, \"wpp_2022.rds\")\nread_rds(\"wpp_2022.rds\")\n\n# A tibble: 43,186 × 65\n   index variant   region_name notes location_code ISO3  ISO2   SDMX type \n   &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n 1     1 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 2     2 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 3     3 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 4     4 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 5     5 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 6     6 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 7     7 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 8     8 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 9     9 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n10    10 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n# ℹ 43,176 more rows\n# ℹ 56 more variables: parent_code &lt;dbl&gt;, year &lt;dbl&gt;, pop_jan_total &lt;dbl&gt;,\n#   pop_jul_total &lt;dbl&gt;, pop_jul_male &lt;dbl&gt;, pop_jul_female &lt;dbl&gt;,\n#   pop_den &lt;dbl&gt;, sex_ratio &lt;dbl&gt;, median_age &lt;dbl&gt;, natural_change &lt;dbl&gt;,\n#   RNC &lt;dbl&gt;, pop_change &lt;dbl&gt;, PGR &lt;dbl&gt;, dubling_time &lt;dbl&gt;, births &lt;dbl&gt;,\n#   births_by_f1519 &lt;dbl&gt;, CBR &lt;dbl&gt;, TFR &lt;dbl&gt;, NRR &lt;dbl&gt;,\n#   mean_age_childbearing &lt;dbl&gt;, sex_ratio_birth &lt;dbl&gt;, deaths_total &lt;dbl&gt;, …\n\n\n\n\n\n\n\n\n힌트\n\n\n\n.rds 파일은 R 전용 특수한 형태의 파일로, R에서 사용하기 편리한 구조를 가지고 있다. R에서 작업을 할 경우에는 .rds 파일을 이용하고 R을 사용하지 않는 사람과 파일을 주고 받을 때에는 .csv파일을 이용하면 좋다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab03: 데이터 불러오기와 정리하기"
    ]
  },
  {
    "objectID": "lab_03.html#데이터-정리하기",
    "href": "lab_03.html#데이터-정리하기",
    "title": "Lab03: 데이터 불러오기와 정리하기",
    "section": "\n3 데이터 정리하기",
    "text": "3 데이터 정리하기\n여기서는 데이터 늘이기(lengthening data), 데이터 넓히기(widening data), 데이터 결합하기(joining data)를 다룬다.\n\n3.1 데이터 늘이기\n실습을 위해 tidyverse 패키지에 포함되어 있는 who2 데이터를 사용한다. 이것은 WHO(world Health Organization, 세계보건기구)에서 제공한 데이터로서 1980~2013년 전세계 209개국의 결핵 환자수에 대한 데이터이다.\n\nglimpse(who2)\n\nRows: 7,240\nColumns: 58\n$ country    &lt;chr&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\",…\n$ year       &lt;dbl&gt; 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989,…\n$ sp_m_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_014  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_1524 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_2534 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_3544 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_4554 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_5564 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_65   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_014  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_1524 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_2534 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_3544 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_4554 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_5564 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_65   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n\n\ncountry와 year은 분명한 변수이지만 나머지 56개 변수는 무엇인지 알 수 없다. 그런데 잘 살펴보면, 변수명에 어떤 패턴이 있다는 것을 알 수 있다. 모두 세 부분으로 나뉘어져 있는데, 첫 번째 부분은 진단법(sp, rel, ep)과 관련되어 있고, 두 번째 부분은 성(m, f)과 관련되어 있고, 세 번째 부분은 연령(014, 1524, 2534, 3544, 4554, 5564, 65)과 관련되어 있다. 56개 변수의 셀 값은 모두 케이스(환자수)를 의미한다. 이 지저분한 데이터를 pivot_longer() 함수를 이용해 정돈된 데이터로 만들어 본다.\n\nwho2 |&gt; \n  pivot_longer(\n    cols = !c(country, year), # country와 year을 제외한 나머지 변수들을 바꾼다.\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), # 원래 데이터의 변수명들이 들어갈 새로운 변수명 지정\n    names_sep = \"_\", # \"_\"를 기준으로 원래의 변수명을 분할\n    values_to = \"count\" # 원래 데이터의 값들이 들어갈 새로운 변수명 지정\n  )\n\n# A tibble: 405,440 × 6\n   country      year diagnosis gender age   count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;\n 1 Afghanistan  1980 sp        m      014      NA\n 2 Afghanistan  1980 sp        m      1524     NA\n 3 Afghanistan  1980 sp        m      2534     NA\n 4 Afghanistan  1980 sp        m      3544     NA\n 5 Afghanistan  1980 sp        m      4554     NA\n 6 Afghanistan  1980 sp        m      5564     NA\n 7 Afghanistan  1980 sp        m      65       NA\n 8 Afghanistan  1980 sp        f      014      NA\n 9 Afghanistan  1980 sp        f      1524     NA\n10 Afghanistan  1980 sp        f      2534     NA\n# ℹ 405,430 more rows\n\n\n정돈된 데이터를 만들기 위해 왜 데이터 ’늘이기’를 해야하는지 생각해 보라.\n\n3.2 데이터 넓히기\n실습을 위해 tidyverse 패키지에 포함되어 있는 cms_patient_experience 데이터를 사용한다. 이것은 미국의 Centers of Medicare and Meicaid Services가 제공한 데이터이다.\n\nView(cms_patient_experience)\n\n이 데이터도 정돈된 데이터가 아니다. 자세히 살펴보면 다음과 같은 사실을 알 수 있다.\n\norg_pac_id와 org_nm 변수는 의료조직의 식별자와 이름이다.\n의료조직별로 6개씩의 열을 차지하고 있는데, 6개의 열은 measure_cd와 measure_title에 나타나 있는 것과 같은 6개의 서로 다른 조사 항목을 나타낸다.\n마지막의 prf_rate는 조사 항목별 점수이다.\n\npivot_wider() 함수를 이용하여, 행에는 개별 의료조직이, 열에는 개별 조사 항목이 나타나는 정돈된 데이터를 만들어 본다.\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    names_from = measure_cd, # 원래 데이터의 measure_cd 값들을 변수로 변환\n    values_from = prf_rate # 원래 데이터의 prf_rate 값들을 변수의 값으로 변환\n  )\n\n# A tibble: 500 × 9\n   org_pac_id org_nm           measure_title CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3\n   &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt;               &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 0446157747 USC CARE MEDICA… CAHPS for MI…          63          NA          NA\n 2 0446157747 USC CARE MEDICA… CAHPS for MI…          NA          87          NA\n 3 0446157747 USC CARE MEDICA… CAHPS for MI…          NA          NA          86\n 4 0446157747 USC CARE MEDICA… CAHPS for MI…          NA          NA          NA\n 5 0446157747 USC CARE MEDICA… CAHPS for MI…          NA          NA          NA\n 6 0446157747 USC CARE MEDICA… CAHPS for MI…          NA          NA          NA\n 7 0446162697 ASSOCIATION OF … CAHPS for MI…          59          NA          NA\n 8 0446162697 ASSOCIATION OF … CAHPS for MI…          NA          85          NA\n 9 0446162697 ASSOCIATION OF … CAHPS for MI…          NA          NA          83\n10 0446162697 ASSOCIATION OF … CAHPS for MI…          NA          NA          NA\n# ℹ 490 more rows\n# ℹ 3 more variables: CAHPS_GRP_5 &lt;dbl&gt;, CAHPS_GRP_8 &lt;dbl&gt;, CAHPS_GRP_12 &lt;dbl&gt;\n\n\n지난 시간과 같은 방식으로 데이터 늘이기를 수행했으나 여전히 하나의 의료 조직이 여러 행에 걸쳐 나타나고 있음을 확인할 수 있다. 이를 해결하기 위해 각 행을 고유하게 식별하는 변수를 선택한다. 이 데이터에서는 “org”로 시작하는 변수들이 이에 해당한다.\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    id_cols = starts_with(\"org\"), # 각 행을 고유하게 식별하는 변수 선택\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n\n# A tibble: 95 × 8\n   org_pac_id org_nm CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5 CAHPS_GRP_8\n   &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 0446157747 USC C…          63          87          86          57          85\n 2 0446162697 ASSOC…          59          85          83          63          88\n 3 0547164295 BEAVE…          49          NA          75          44          73\n 4 0749333730 CAPE …          67          84          85          65          82\n 5 0840104360 ALLIA…          66          87          87          64          87\n 6 0840109864 REX H…          73          87          84          67          91\n 7 0840513552 SCL H…          58          83          76          58          78\n 8 0941545784 GRITM…          46          86          81          54          NA\n 9 1052612785 COMMU…          65          84          80          58          87\n10 1254237779 OUR L…          61          NA          NA          65          NA\n# ℹ 85 more rows\n# ℹ 1 more variable: CAHPS_GRP_12 &lt;dbl&gt;\n\n\n이제 어떤 의료조직이 어떤 항목에서 얼마의 점수를 받았는지를 일목요연하게 알아 볼 수 있다. 정돈된 데이터를 만들기 위해 이번에는 왜 데이터 ’넓히기’를 해야하는지 생각해 보라.\n\n3.3 데이터 결합하기\n\n3.3.1 조인(join)의 종류\n여기서는 데이터 프레임을 결합하여 새로운 데이터 프레임을 생성하는 과정에 대해 살펴본다. tidyverse 패키지에 포함되어 있는 dplyr 패키지는 다양한 종류의 조인(join) 함수를 제공한다.\n\nleft_join(): 첫 번째 변수는 그대로 둔 상태에서 두 번째 변수를 결합함으로써 두 번째 변수의 열을 가져옴\ninner_join(): 두 번째 변수는 그대로 둔 상태에서 첫 번째 변수를 결합함으로써 첫 번째 변수의 열을 가져옴\nright_join(): 두 변수 모두에 존재하는 열을 취함\nfull_join(): 최소한 한 변수에 존재하는 열을 모두 취함\nsemi_join(): 첫 번째 변수의 행 중 두 번째 변수에 대응하는 행이 있는 것만 취함\nanti_join(): 첫 번째 변수의 행 중 두 번째 변수에 대응하는 행이 없는 것만 취함\n\n이들 중 left_join()이 가장 많이 사용되기 때문에 그것에 집중한다.\n\n3.3.2 left_join() 함수의 활용\n실습을 위해 nycflights13 패키지의 데이터를 사용한다. 이 패키지에는 다섯 개의 데이터 프레임이 포함되어 있다. 지난 번에는 첫 번째 데이터만 사용했다.\n\nflights: 2013년 NYC를 출발한 모든 항공기\nweather: 공항별 시간별 기상 상황\nplanes: 항공기별 건조 정보\nairports: 공항명과 위치\nairlines: 항공사\n\n그리고 이 6개의 데이터 프레임은 그림 1 처럼 공통키(common key)를 통해 서로 연결되어 있다.\n\n\n\n\n\n그림 1: nycflights13 데이터(https://github.com/tidyverse/nycflights13)\n\n\nflights 데이터의 변수가 너무 많기 때문에 조인을 위한 공통키를 중심으로 변수를 줄인다.\n\nlibrary(nycflights13)\n\n\nflights2 &lt;- flights |&gt; \n  select(year, time_hour, origin, dest, tailnum, carrier)\nflights2\n\n# A tibble: 336,776 × 6\n    year time_hour           origin dest  tailnum carrier\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  \n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     \n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     \n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     \n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     \n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     \n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6     \n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV     \n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6     \n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA     \n# ℹ 336,766 more rows\n\n\nflights2 데이터를 중심으로 나머지 4개의 데이터와 조인한다.\n\nairlines\n\n# A tibble: 16 × 2\n   carrier name                       \n   &lt;chr&gt;   &lt;chr&gt;                      \n 1 9E      Endeavor Air Inc.          \n 2 AA      American Airlines Inc.     \n 3 AS      Alaska Airlines Inc.       \n 4 B6      JetBlue Airways            \n 5 DL      Delta Air Lines Inc.       \n 6 EV      ExpressJet Airlines Inc.   \n 7 F9      Frontier Airlines Inc.     \n 8 FL      AirTran Airways Corporation\n 9 HA      Hawaiian Airlines Inc.     \n10 MQ      Envoy Air                  \n11 OO      SkyWest Airlines Inc.      \n12 UA      United Air Lines Inc.      \n13 US      US Airways Inc.            \n14 VX      Virgin America             \n15 WN      Southwest Airlines Co.     \n16 YV      Mesa Airlines Inc.         \n\nflights2 |&gt;\n  left_join(airlines)\n\n# A tibble: 336,776 × 7\n    year time_hour           origin dest  tailnum carrier name                  \n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;                 \n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines Inc. \n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines Inc. \n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines Inc.\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways       \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.  \n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines Inc. \n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      JetBlue Airways       \n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      ExpressJet Airlines I…\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      JetBlue Airways       \n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      American Airlines Inc.\n# ℹ 336,766 more rows\n\n\n\nweather\n\n# A tibble: 26,115 × 15\n   origin  year month   day  hour  temp  dewp humid wind_dir wind_speed\n   &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;\n 1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4 \n 2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06\n 3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5 \n 4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7 \n 5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7 \n 6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5 \n 7 EWR     2013     1     1     7  39.0  28.0  64.4      240      15.0 \n 8 EWR     2013     1     1     8  39.9  28.0  62.2      250      10.4 \n 9 EWR     2013     1     1     9  39.9  28.0  62.2      260      15.0 \n10 EWR     2013     1     1    10  41    28.0  59.6      260      13.8 \n# ℹ 26,105 more rows\n# ℹ 5 more variables: wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;,\n#   visib &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\nflights2 |&gt; \n  left_join(weather |&gt; select(origin, time_hour, temp, wind_speed))\n\n# A tibble: 336,776 × 8\n    year time_hour           origin dest  tailnum carrier  temp wind_speed\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;      &lt;dbl&gt;\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA       39.0       12.7\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA       39.9       15.0\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA       39.0       15.0\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6       39.0       15.0\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL       39.9       16.1\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA       39.0       12.7\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6       37.9       11.5\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV       39.9       16.1\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6       37.9       13.8\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA       39.9       16.1\n# ℹ 336,766 more rows\n\n\n\nplanes\n\n# A tibble: 3,322 × 9\n   tailnum  year type              manufacturer model engines seats speed engine\n   &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; \n 1 N10156   2004 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 2 N102UW   1998 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 3 N103US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 4 N104UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 5 N10575   2002 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 6 N105UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 7 N107US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 8 N108UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 9 N109UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n10 N110UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n# ℹ 3,312 more rows\n\nflights2 |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\n\n# A tibble: 336,776 × 9\n    year time_hour           origin dest  tailnum carrier type     engines seats\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;int&gt; &lt;int&gt;\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Fixed w…       2   149\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      Fixed w…       2   149\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Fixed w…       2   178\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      Fixed w…       2   200\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Fixed w…       2   178\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Fixed w…       2   191\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Fixed w…       2   200\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      Fixed w…       2    55\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      Fixed w…       2   200\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;          NA    NA\n# ℹ 336,766 more rows\n\n\n\nairports\n\n# A tibble: 1,458 × 8\n   faa   name                             lat    lon   alt    tz dst   tzone    \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n 1 04G   Lansdowne Airport               41.1  -80.6  1044    -5 A     America/…\n 2 06A   Moton Field Municipal Airport   32.5  -85.7   264    -6 A     America/…\n 3 06C   Schaumburg Regional             42.0  -88.1   801    -6 A     America/…\n 4 06N   Randall Airport                 41.4  -74.4   523    -5 A     America/…\n 5 09J   Jekyll Island Airport           31.1  -81.4    11    -5 A     America/…\n 6 0A9   Elizabethton Municipal Airport  36.4  -82.2  1593    -5 A     America/…\n 7 0G6   Williams County Airport         41.5  -84.5   730    -5 A     America/…\n 8 0G7   Finger Lakes Regional Airport   42.9  -76.8   492    -5 A     America/…\n 9 0P2   Shoestring Aviation Airfield    39.8  -76.6  1000    -5 U     America/…\n10 0S9   Jefferson County Intl           48.1 -123.    108    -8 A     America/…\n# ℹ 1,448 more rows\n\nflights2 |&gt; \n  left_join(airports, join_by(origin == faa))\n\n# A tibble: 336,776 × 13\n    year time_hour           origin dest  tailnum carrier name         lat   lon\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Newark Li…  40.7 -74.2\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      La Guardia  40.8 -73.9\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      John F Ke…  40.6 -73.8\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      John F Ke…  40.6 -73.8\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      La Guardia  40.8 -73.9\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Newark Li…  40.7 -74.2\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Newark Li…  40.7 -74.2\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      La Guardia  40.8 -73.9\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      John F Ke…  40.6 -73.8\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      La Guardia  40.8 -73.9\n# ℹ 336,766 more rows\n# ℹ 4 more variables: alt &lt;dbl&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, tzone &lt;chr&gt;\n\n\nairports의 경우만 왜 join_by()라는 아규먼트가 필요한지 생각해 본다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab03: 데이터 불러오기와 정리하기"
    ]
  },
  {
    "objectID": "lab_05.html",
    "href": "lab_05.html",
    "title": "Lab05: 데이터 시각화하기",
    "section": "",
    "text": "이 실습은 R로 데이터사이언스를 하는 과정 중 데이터 시각화하기(visualizing)를 다룬다. 다음의 사항을 다룬다. 데이터 시각화하기는 tidyverse의 핵심 패키지 중의 하나인 ggplot2 에서 제공된다.\n모든 실습의 시작은 tidyverse 패키지를 불러오는 것이다. 또한 이후 사용하게 될 패키지 ggrepel, patchwork, RColorBrewer 패키지도 미리 설치하고 불러온다.\n\nlibrary(tidyverse)\nlibrary(ggrepel)\nlibrary(patchwork)\nlibrary(RColorBrewer)\n\n실습을 위해 ggplot2 패키지 속에 포함되어 있는 mpg 데이터와 diamonds 데이터를 사용한다. 각 데이터에서 눈여겨 볼 변수는 아래와 같다.\n\n\nmpg\n\ndispl : 배기량(displacement)\nclass : 자동차 유형(compact/midsize/suv/2seater/minivan/pickup/subcompact)\nhwy : 고속도로(highway) 연비\n\n\n\ndiamonds\n\nprice : 가격\ncarat : 캐럿\ncolor : 다이아몬드 색깔\nclarity : 투명도\ncut : 가공의 품질",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab05: 데이터 시각화하기"
    ]
  },
  {
    "objectID": "lab_05.html#실습-개요",
    "href": "lab_05.html#실습-개요",
    "title": "Lab05: 데이터 시각화하기",
    "section": "",
    "text": "이 실습은 R로 데이터사이언스를 하는 과정 중 데이터 시각화하기(visualizing)를 다룬다. 다음의 사항을 다룬다. 데이터 시각화하기는 tidyverse의 핵심 패키지 중의 하나인 ggplot2 에서 제공된다.\n모든 실습의 시작은 tidyverse 패키지를 불러오는 것이다. 또한 이후 사용하게 될 패키지 ggrepel, patchwork, RColorBrewer 패키지도 미리 설치하고 불러온다.\n\nlibrary(tidyverse)\nlibrary(ggrepel)\nlibrary(patchwork)\nlibrary(RColorBrewer)\n\n실습을 위해 ggplot2 패키지 속에 포함되어 있는 mpg 데이터와 diamonds 데이터를 사용한다. 각 데이터에서 눈여겨 볼 변수는 아래와 같다.\n\n\nmpg\n\ndispl : 배기량(displacement)\nclass : 자동차 유형(compact/midsize/suv/2seater/minivan/pickup/subcompact)\nhwy : 고속도로(highway) 연비\n\n\n\ndiamonds\n\nprice : 가격\ncarat : 캐럿\ncolor : 다이아몬드 색깔\nclarity : 투명도\ncut : 가공의 품질",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab05: 데이터 시각화하기"
    ]
  },
  {
    "objectID": "lab_05.html#핵심-레이어-심미성과-기하",
    "href": "lab_05.html#핵심-레이어-심미성과-기하",
    "title": "Lab05: 데이터 시각화하기",
    "section": "\n1 핵심 레이어: 심미성과 기하",
    "text": "1 핵심 레이어: 심미성과 기하\n이 8개 구성요소 중 가장 중요한 것은 ‘심미성(aesthetics)’ 혹은 ‘심미성 매핑(aesthetic mapping)’와 ’기하(geometries)’ 혹은 ’기하 객체(geometric objects)’이다. 기하가 그래프의 전체 구조 혹은 형식을 규정하는 것이라면, 심미성은 기하의 외견을 규정한다. 결국 기하는 그래프의 유형(예: 막대 그래프, 산포도 등)과 관련되고, 심미성은 그래프의 시각적 속성(예: x축, y축, 컬러, 크기, 모양 등)과 관련된다. 이 두 가지는 독립적인 요소이지만, 어느 정도는 관련되어 있기도 하다. 모든 기하가 모든 심미성과 결합할 수 있는 것은 아니다. 특정한 기하는 오로지 특정한 심미성과만 결합한다. 예를 들어 포인트 기하 객체(geom_point())는 크기(size) 심미성과 관련되지만, 라인 기하 객체(geom_line())는 크기 심미성과는 관련되지 않고 라인폭(linewidth) 심미성과만 관련되는 식이다.\n\n1.1 기초 예제\n그래프를 그리기 위해 반드시 필요한 것은 데이터, 심미성, 기하이다. 이들을 차례로 하나씩 추가해본다.\n그림 1 를 보면, 빈 화면만 출력되는 것을 볼 수 있다. 데이터만 올라왔으므로, 그릴 수 있는 것이 없다. 그림 2 에서는 x축과 y축이 나타났다. 그러나 이 재료를 가지고 무슨 그래프를 그릴지는 지정하지 않았으므로 아무 그래프도 나타나지 않는다. 그림 3 에서야 비로소 그래프가 나타나는데, 이는 어떤 데이터로부터 어떤 변수를 사용할지, 그리고 그것을 어떤 방식으로 그릴지를 모두 지정해주었기 때문이다.\n\n# 데이터만 추가\nggplot(data=mpg)\n\n\n\n\n\n\n그림 1: 데이터만 추가\n\n\n\n\n\nggplot(data=mpg, aes(x=displ, y=hwy))\n\n\n\n\n\n\n그림 2: 데이터 + 심미성(x, y축)\n\n\n\n\n\nggplot(data=mpg, aes(x=displ, y=hwy)) +\n  geom_point()\n\n\n\n\n\n\n그림 3: 데이터 + 심미성(x, y축) + 기하\n\n\n\n\n\n1.2 심미성 매핑\n심미성 매핑이란 다양한 시각적 속성 혹은 재료를 그래프에 적용 혹은 부여하는 과정을 의미한다. displ과 hwy의 관계가 class에 따라 어떻게 달라지는지를 시각화한다. 다음의 두 그래프를 비교해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 4: 심미성: 컬러\n\n\n\n\n\nggplot(mpg, aes(x = displ, y = hwy, shape = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 5: 심미성: 형태\n\n\n\n\n그림 4 과 그림 5 중 어느 것이 더 효과적인 시각화라고 생각하는가? 컬러(color)와 형태(shape)라는 심미성 요소 외에 크기(size)와 투명도(alpha) 요소를 동일한 데이터에 적용해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, size = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 6: 심미성: 크기\n\n\n\n\n\nggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 7: 심미성: 투명도\n\n\n\n\n크기와 투명도는 양적인 차이를 나타내는데 적합한 심미성이기 때문에 class라는 정성적인 범주의 차이를 보여주는데는 적합하지 않다. 심미성 부여에서 가장 중요한 것은 결국 얼마나 적절한 심미성 요소, 혹은 시각 변수(visual variables)를 선택하느냐에 달려 있다.\n\n1.3 기하 객체\n그림 8 와 그림 9 이 다르게 보이는 것은 기하 객체가 하나는 포인트(point)이고 다른 하나는 완만한 선(smooth)이기 때문이다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point()\n\n\n\n\n\n\n그림 8: 기하: geom_point()\n\n\n\n\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_smooth()\n\n\n\n\n\n\n그림 9: 기하: geom_smooth()\n\n\n\n\n그림 4 과 그림 9 두 개를 결합해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = class)) + \n  geom_point() + \n  geom_smooth()\n\n\n\n\n\n\n그림 10: 기하: geom_point() + geom_smooth() 1\n\n\n\n\n원하는 것이 아니다. 왜 이런 결과가 나왔으며, 어떻게 하면 원하는 것을 얻을 수 있을지 생각해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(aes(color = class)) + \n  geom_smooth()\n\n\n\n\n\n\n그림 11: 기하: geom_point() + geom_smooth() 2\n\n\n\n\n두 결과의 차이는 color 심미성을 글로벌하게 적용하느냐 로컬하게 적용하느냐(포인트 기하에만 적용)에 달린 것이다. 글로벌한 심미성은 ggplot()속에서 설정하고, 국지적인 심미성은 개별 기하(geom_point()) 속에서 설정한다. 매우 중요한 사항이니 꼭 기억하도록 한다.\n다양한 기하 객체는 동일한 데이터를 다양한 방식으로 탐색할 수 있게 해준다. 다음의 세가지 기하 객체는 탐색적 데이터 분석에서 널리 사용되는 것이다.\n\nggplot(mpg, aes(x = hwy)) +\n  geom_histogram(binwidth = 2)\n\n\n\n\n\n\n그림 12: 기하: geom_histogram()\n\n\n\n\n\nggplot(mpg, aes(x = hwy)) +\n  geom_density()\n\n\n\n\n\n\n그림 13: 기하: geom_density()\n\n\n\n\n\nggplot(mpg, aes(x = hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n그림 14: 기하: geom_boxplot()",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab05: 데이터 시각화하기"
    ]
  },
  {
    "objectID": "lab_05.html#다른-레이어",
    "href": "lab_05.html#다른-레이어",
    "title": "Lab05: 데이터 시각화하기",
    "section": "\n2 다른 레이어",
    "text": "2 다른 레이어\n\n2.1 스케일\n스케일(scales)은 심미성이 구체적으로 어떻게 구현될지를 결정한다. 예를 들어 color 심미성이 적용되었다 하더라도 어떤 색상이 선정되어 어떻게 배열되는지에 따라 최종 그래프의 모습은 매우 달라질 수 있다. 그래프를 다시 나타낸다. 스케일이 어느 부분에 어떻게 적용되었는지 생각해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() \n\n\n\n\n\n\n그림 15\n\n\n\n\n그림 15 은 아래에서 보는 것처럼, ggplot2가 자동적으로 적용한 세 가지의 스케일 설정에 의거해 만들어진 것이다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_color_discrete()\n\n수정하여 다음과 같이 적용할 수 있다. scale 함수의 아규먼트가 어떤 역할을 하는지 생각해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(breaks = seq(15, 40, by = 5)) +\n  scale_color_brewer(palette = \"Set1\", labels = c(\"4\" = \"4-wheel\", \"f\" = \"front\", \"r\" = \"rear\"))\n\n\n\n\n\n\n그림 16\n\n\n\n\nscale_color_brewer() 함수는 ColorBrewer 컬러 스케일을 사용한 것인데 익히고 있으면 많은 도움이 된다. 살펴보면 양적인 변수에 적용하기 좋은 팔레트가 있고, 질적인 변수에 적용하기 좋은 팔레트도 있다. 한번 마음에 드는 팔레트를 골라보자.\n\npar(mar=c(0.1, 3, 0.1, 1))\ndisplay.brewer.all()\n\n\n\n\n\n\n\n\n\n\n\n\n\n힌트직접 색상 지정하는 방법\n\n\n\n\n\n한편, 내가 원하는 색상을 골라 직접 지정하는 방법도 있다. scale_color_brewer() 대신 scale_color_manual() 함수를 사용하면 된다. 또한 RGB 색상에 대한 html 코드를 사용해도 되고, R에서 부여한 657개의 이름 중에서 골라 사용해도 된다. 색상 이름 및 html 코드는 다음 사이트를 참고하라.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(breaks = seq(15, 40, by = 5)) +\n  scale_color_manual(values = c(\"sienna1\", \"slateblue4\", \"#698B22\"))\n\n\n\n\n\n\n\n\n\n\n\n2.2 패싯\n패싯(facets) 레이어는 다면생성(faceting) 과정을 통해 하나의 플롯을 여러개의 하위 플롯으로 쪼갬으로서 생성된다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_wrap(~cyl)\n\n\n\n\n\n\n그림 17: 패싯: facet_wrap()\n\n\n\n\n두 개의 변수에 의거해 패싯을 생성할 수도 있다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl)\n\n\n\n\n\n\n그림 18: 패싯: facet_grid()\n\n\n\n\n\n2.3 통계적 변환\n어떤 시각화 과정은 필연적으로 통계적 변환(statistical transformation)을 수반한다.\n\nggplot(diamonds, aes(x = cut)) + \n  geom_bar()\n\n\n\n\n\n\n그림 19: 통계적 변환: geom_bar()\n\n\n\n\nafter_stat()이라고 하는 도우미 함수를 사용하면, 이 그래프를 절대 빈도가 아닌 상대 빈도 그래프로 변환할 수 있다. 이 역시 통계적 변환 과정이 숨어 있는 것이다.\n\nggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + \n  geom_bar()\n\n\n\n\n\n\n그림 20: 통계적 변환: geom_bar()\n\n\n\n\n\n\n\n\n\n\n힌트geom_bar() vs. geom_col()\n\n\n\n\n\ngeom_bar() 함수는 자동으로 통계적 변환을 한 후 결과를 반환한다. 그래서 y축을 지정하지 않아도 된다. 반면 geom_col() 함수는 마찬가지로 막대그래프이지만, x축과 그에 상응하는 y축의 값을 바탕으로 그래프를 생성한다. 아래의 두 코드를 살펴보고 결과를 비교해보자. geom_bar()의 통계적 변환이 무엇을 한 것인지, 두 함수의 차이가 무엇이지 이해할 수 있을 것이다. 참고로 두 번째 코드는 지난 실습 때 다룬 count() 함수를 활용한 것이다. 다른 코드이지만 동일한 결과가 출력됨됨을 알 수 있다.\n\ndiamonds |&gt; \n  ggplot(aes(x = cut)) +\n  geom_bar()\n\n\n\n\n\n\n\n\ndiamonds |&gt;\n  count(cut) |&gt; \n  ggplot(aes(x = cut, y = n)) +\n  geom_col()\n\n\n\n\n\n\n\n\n\n\n막대 그래프에 심미성을 가미하고, position 아규먼트를 통한 위치 조정(position adjustment)을 시도한다.\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar()\n\n\n\n\n\n\n그림 21: position: stack\n\n\n\n\n기하 객체에 색상을 지정하고 싶을 때, 0차원(point)과 1차원(line) 객체에는 color라는 심미성을 적용하지만, 막대 그래프와 같은 2차원(area) 객체에는 fill이라는 심미성을 적용한다. 자주 혼돈이 되는 부분이다.\n위치 조정을 위해 position 아규먼트를 사용하는데, 네 가지 옵션이 있다.\n\nposition = \"stack\"\nposition = \"identity\"\nposition = \"dodge\"\nposition = \"fill\"\n\n그림 21 에는 디폴트로 position = \"stack\"이 적용된 것이다. 그림 22 는 position = \"dodge\"를 적용한 것이다 . 나머지 옵션도 적용해보고 차이가 무엇인지 알아본다.\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n그림 22: position: dodge\n\n\n\n\n\n\n\n\n\n\n힌트position 아규먼트의 종류와 차이\n\n\n\n\n\nposition 아규먼트에 따른 차이는 아래의 그래프가 잘 보여준다. 아래에서 배울(운) patchwork도 활용했다.\n\ng1 &lt;- ggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"stack\") +\n  labs(title = \"'stack' graph\")\n\ng2 &lt;- ggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"dodge\") +\n  labs(title = \"'dodge' graph\")\n\ng3 &lt;- ggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\") +\n  labs(title = \"'fill' graph\")\n\ng4 &lt;- ggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"identity\") +\n  labs(title = \"'identity' graph\")\n\ng1+g2+g3+g4 +\n  plot_annotation(\n    title = \"How does position argument work?\",\n    subtitle = \"Graph differences by position argument\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n2.4 좌표\n좌표(coordinates) 레이어 혹은 좌표계(coordinate systems)는 그래픽 요소들의 위치 결정에 기준이 되는 준거체계이다. 특히 두 가지가 함수가 유용하다. coord_flip() 함수는 축을 전환한다.\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\") +\n  coord_flip()\n\n\n\n\n\n\n그림 23: coord_clip() 함수\n\n\n\n\ncoord_fixed() 함수는 두 축의 스케일을 절대화하여 동일하게 적용한다. 아규먼트로 x축 한 단위 대비 y축 한 단위의 비(y/x)를 받으며, 생략할 경우 디폴트로 1을 지정한다. 무슨 의미인지 알아본다.\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point() +\n  coord_fixed()\n\n\n\n\n\n\n그림 24: coord_fixed() 함수\n\n\n\n\n\n\n\n\n\n\n힌트왜 coord_fixed() 함수를 사용할까?\n\n\n\n\n\ncoord_fixed()를 사용하지 않아도 ggplot은 적당한 비율을 찾아 그래프를 그려준다. 그러나 간혹 사용자가 원하는 가로-세로 비율이 있을 때가 있다. 예를 들어, 우리나라가 동고서저의 지형임을 보여주는 그래프를 그려보자.\n\n# 가상 데이터\ndata &lt;- tibble(x=seq(0, 170, by=10),\n               y=c(10, 62, 108, 162, 245, 330, 469, 608, 780, 942,\n                   1125, 1307, 1500, 1707, 1324, 849, 394, 0))\n\n\n# 비율 지정 안하면?\nggplot(data, aes(x=x, y=y)) +\n  geom_point()+\n  geom_line()+\n  labs(x=\"서울-강릉(km)\", y=\"고도(m)\")\n\n\n\n\n\n\n\n비율을 지정하지 않으니 조금 이상하다. 시각적 효과를 위해서, 가로 한 단위와 세로 한 단위의 비율을 적절히 맞춰보자.\n\n# 적정 비율 지정하기\nggplot(data, aes(x=x, y=y)) +\n  geom_point()+\n  geom_line()+\n  labs(x=\"서울-강릉(km)\", y=\"고도(m)\") +\n  coord_fixed(ratio = 0.02)\n\n\n\n\n\n\n\n아까보다 조금 더 가독성이 좋아짐을 확인할 수 있다.\n\n\n\n\n2.5 테마\n디폴트인 회색빛 배경이 마음에 들지 않았다면 그림 25 처럼 흑백 테마(theme_bw())를 적용할 수도 있다. 다른 테마도 적용해 보고 그 차이를 알아본다.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  theme_bw()\n\n\n\n\n\n\n그림 25: theme_bw() 함수\n\n\n\n\n이렇게 한꺼번에 그래프의 외관을 바꿀 수도 있지만 theme() 함수를 통해 그래프의 개별 요소 하나씩을 모두 수정할 수 있다. 어떤 요소를 바꿀 수 있는지 다음을 참고한다.\n\nhttps://ggplot2.tidyverse.org/reference/theme.html\n\n그림 26 는 몇 가지 요소를 수정한 사례이다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  labs(\n    title = \"Larger engine sizes tend to have lower fuel economy\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  theme(\n    legend.position = c(0.6, 0.7),\n    legend.direction = \"horizontal\",\n    plot.title = element_text(face = \"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(hjust = 0)\n  )\n\n\n\n\n\n\n그림 26: 개별 요소의 수정: theme() 함수",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab05: 데이터 시각화하기"
    ]
  },
  {
    "objectID": "lab_05.html#기타-사항",
    "href": "lab_05.html#기타-사항",
    "title": "Lab05: 데이터 시각화하기",
    "section": "\n3 기타 사항",
    "text": "3 기타 사항\n\n3.1 라벨과 주석\nlab() 함수를 활용하면 그래프의 다양한 종류의 라벨을 설정할 수 있다.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  labs(\n    x = \"Engine displacement (L)\",\n    y = \"Highway fuel economy (mpg)\",\n    color = \"Car type\",\n    title = \"Fuel efficiency generally decreases with engine size\",\n    subtitle = \"Two seaters (sports cars) are an exception because of their light weight\",\n    caption = \"Data from fueleconomy.gov\"\n  )\n\n\n\n\n\n\n그림 27: 라벨링\n\n\n\n\n기하 함수인 geom_text() 혹은 geom_label()를 통해 그래프 속에 텍스트를 삽입할 수 있다. 주석이 겹치는 것을 방지하기 위해 ggrepel 패키지가 유용하게 사용될 수 있다.\n\nlibrary(ggrepel)\n\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(colour = \"red\") +\n  geom_label_repel(data = mpg |&gt; slice_sample(prop = 0.1), aes(label = class))\n\n\n\n\n\n\n\n\n3.2 레이아웃\n레이아웃(layout)은 복수의 그래프를 적절히 배치하여 하나의 그래픽으로 융합하는 과정을 의미한다. 수 많은 ggplot2의 확장 패키지(ggplot2 extensions) 중 하나이 patchwork 패키지를 활용할 수 있다.\n\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 1\")\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"Plot 2\")\np1 + p2\n\n\n\n\n\n\n그림 28: 레이아웃: patchwork 패키지\n\n\n\n\n\n\n\n\n\n\n힌트patchwork() 더 살펴보기\n\n\n\n\n\npatchwork() 패키지는 그래프의 배치를 적용하는데 매우 유용하다. 좌우배치를 하되 자동으로 줄넘김을 원한다면 ‘A+B’, 무조건 좌우배치를 원할 때는 ‘A|B’, 상하배치를 원하다면 ’A/B’의 형식을 사용하면 된다. 매우 직관적이다. 위에서 position 아규먼트를 공부할 때 사용한 코드를 재사용해보자.\n\ng1+g2+g3+g4\n\n\n\n\n\n\n\n\n(g1+g3+g4)/g2\n\n\n\n\n\n\n\n\n\n\n\n3.3 그래프의 저장\n두 가지 방식이 있다.\n첫 번째 방식은 Output 창의 Plots 탭에 있는 Export 버을 이용하는 것이다. 다양한 그래픽 포멧 뿐만 아니라 pdf 형식으로도 저장할 수 있다.\n두 번째 방식은 ggplot2 의 ggsave() 함수를 이용하는 것이다. 결과물의 폰트 크기, 가로세로비, 해상도 등을 종합적으로 고려하여 최적의 세팅값을 찾아야 한다. 자신의 디바이스에 따라 동일한 세팅값이 다른 결과를 산출할 수도 있다.\n\nmy_plot &lt;- ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  labs(\n    title = \"Larger engine sizes tend to have lower fuel economy\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  theme(\n    legend.position = c(0.6, 0.7),\n    legend.direction = \"horizontal\",\n    plot.title = element_text(face = \"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(hjust = 0)\n  )\nggsave(filename = \"my_plot.png\", plot = my_plot, width = 8, height = 8 * 0.618, dpi = 600)",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab05: 데이터 시각화하기"
    ]
  },
  {
    "objectID": "lab_08.html",
    "href": "lab_08.html",
    "title": "Lab08: 데이터로 소통하기: Quarto",
    "section": "",
    "text": "File &gt; New File &gt; Quarto Document를 실행한다. Title과 Author란에 적절한 텍스트를 기입하고 아래에 위치한 Create 버튼을 클릭한다.\n\n그렇다면 아마도 아래의 화면이 보일 것이다.\n\n--- 으로 둘러싸인 YAML(YAML Ain’t Markup Language)에 아래와 같은 몇 가지 key: value 를 더해보자.\n\n---\nnumber-sections: true\nformat: \n  html: \n    toc: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\n---\n\n기본적인 Quarto 작성법은 다음과 같다.\n\n텍스트: 그냥 작성\n코드 청크(Code Chunk): Insert &gt; Executable Cell &gt; R(Ctrl+Alt+I)\n표(Table): Insert &gt; Table\n그림(Figure): Insert &gt; Figure\n링크(Link): (원하는 텍스트 선택 후) Insert &gt; Link\n머릿말(Header): Normal &gt; Header 1~6 중 선택\n\n이제 지난 실습록(데이터 수집하기)의 일부분을 재현해보자. 일반 텍스트와 코드 청크를 넣고 이를 렌더링해보면 그럴듯한 html 파일이 만들어짐을 확인할 수 있을 것이다.\n\n추가로 몇 가지의 팁을 소개한다.\n첫째, R의 패키지나 함수를 다르게 표시할 수 있다. 지금까지의 실습록에서 tidyverse 함수를 tidyverse 와 같이 표시하던 것이 기억날 것이다. 이는 해당 텍스트를 선택한 후, Format에서 Code를 누르면 생성된다. 혹은 Ctrl+D로 실행할 수 있다.\n둘째, Call-out 이다. 몇몇 실습록에서 아래와 같은 모습을 보았을 것이다. 문서 중간에 팁이나 주의를 알려주고 있다.\n\n\nCallout에는 공지(note), 팁(tip), 중요사항(important), 주의(caution), 경고(warning) 등이 있다. 이는 비주얼 에디터 메뉴 Insert-Callout에서 선택할 수 있고, ::: 으로 둘러싸인 부분에 글이나 코드 청크를 작성하면 된다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab08: 데이터로 소통하기: Quarto"
    ]
  },
  {
    "objectID": "lab_08.html#실습-1-기본-quarto-다큐먼트의-작성",
    "href": "lab_08.html#실습-1-기본-quarto-다큐먼트의-작성",
    "title": "Lab08: 데이터로 소통하기: Quarto",
    "section": "",
    "text": "File &gt; New File &gt; Quarto Document를 실행한다. Title과 Author란에 적절한 텍스트를 기입하고 아래에 위치한 Create 버튼을 클릭한다.\n\n그렇다면 아마도 아래의 화면이 보일 것이다.\n\n--- 으로 둘러싸인 YAML(YAML Ain’t Markup Language)에 아래와 같은 몇 가지 key: value 를 더해보자.\n\n---\nnumber-sections: true\nformat: \n  html: \n    toc: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\n---\n\n기본적인 Quarto 작성법은 다음과 같다.\n\n텍스트: 그냥 작성\n코드 청크(Code Chunk): Insert &gt; Executable Cell &gt; R(Ctrl+Alt+I)\n표(Table): Insert &gt; Table\n그림(Figure): Insert &gt; Figure\n링크(Link): (원하는 텍스트 선택 후) Insert &gt; Link\n머릿말(Header): Normal &gt; Header 1~6 중 선택\n\n이제 지난 실습록(데이터 수집하기)의 일부분을 재현해보자. 일반 텍스트와 코드 청크를 넣고 이를 렌더링해보면 그럴듯한 html 파일이 만들어짐을 확인할 수 있을 것이다.\n\n추가로 몇 가지의 팁을 소개한다.\n첫째, R의 패키지나 함수를 다르게 표시할 수 있다. 지금까지의 실습록에서 tidyverse 함수를 tidyverse 와 같이 표시하던 것이 기억날 것이다. 이는 해당 텍스트를 선택한 후, Format에서 Code를 누르면 생성된다. 혹은 Ctrl+D로 실행할 수 있다.\n둘째, Call-out 이다. 몇몇 실습록에서 아래와 같은 모습을 보았을 것이다. 문서 중간에 팁이나 주의를 알려주고 있다.\n\n\nCallout에는 공지(note), 팁(tip), 중요사항(important), 주의(caution), 경고(warning) 등이 있다. 이는 비주얼 에디터 메뉴 Insert-Callout에서 선택할 수 있고, ::: 으로 둘러싸인 부분에 글이나 코드 청크를 작성하면 된다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab08: 데이터로 소통하기: Quarto"
    ]
  },
  {
    "objectID": "lab_08.html#실습-2-개인-블로그-만들기",
    "href": "lab_08.html#실습-2-개인-블로그-만들기",
    "title": "Lab08: 데이터로 소통하기: Quarto",
    "section": "\n2 실습 2: 개인 블로그 만들기",
    "text": "2 실습 2: 개인 블로그 만들기\nQuarto를 활용하면 개인 블로그도 만들 수 있다. 어떻게 보면 블로그나 웹사이트는 위에서 만든 html의 집합이라고도 볼 수 있다. 블로그는 다음의 과정을 통해 생성할 수 있다.\n\n2.1 새로운 Quarto Blog 프로젝트 시작하기\nFile &gt; New Project &gt; Create Project &gt; Quarto Blog를 선택한다.\n\n\n\n\n\n\n\n\n\n\n디렉토리 이름과 경로를 설정하고, 아래에 위치한 Create Project 버튼을 클릭한다.\n\n\n2.2 렌더링하여 결과를 살펴보기\nRender 버튼을 클릭하여 결과를 확인한다. 결과는 오른쪽 패널의 Viewer 탭에 나타난다. Viewer 탭의 Show in new window 아이콘을 클릭하면 웹브라우저 상에 결과를 나타낼 수 있다.\n\nFiles 탭을 클릭하면 프로젝트 폴더에 다음과 같은 파일들이 생성되어 있음을 확인할 수 있다. 조교의 도움을 받아 각각의 파일이 어떠한 역할을 하는지 파악한다.\n\n\nFile\nDescription\n\n\n\n_quarto.yml\nQuarto 프로젝트 파일\n\n\nindex.qmd\n블로그의 홈페이지\n\n\nabout.qmd\n블로그의 어바우트 페이지\n\n\nposts/\n포스트를 포함하고 있는 폴더\n\n\nposts/_metadata.yml\n포스트가 공유하고 있는 옵션들\n\n\nstyles.css\n웹사이트의 CSS\n\n\n\n2.3 구성 요소 수정하기\n구성 요소를 수정하여 자신의 개인 블로그를 만들어 나간다.\n\n2.3.1 메타데이터\n블로그의 전체적인 모습은 _quarto.yml 파일에 의해 규정된다. _quarto.yml 파일의 내용을 살펴보고 조교의 도움을 받아 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히, 25개의 테마를 살펴보고, 그 중 하나를 선택한다. theme 만 바꿔주어도 아래와 같이 그럴듯한 블로그가 완성된다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n힌트다크 모드\n\n\n\n하나의 테마만 적용하는 것이 아니라, 다크 모드도 지정할 수 있다. 아래의 코드를 _quarto.yml 에 추가해보자.\n\ntheme:\n  light: flatly\n  dark: darkly\n\n\n\n\n2.3.2 홈페이지(home page)\n블로그의 홈페이지는 포스트 디렉토리에 포함되는 모든 포스트의 리스트를 제공하는 것으로 index.qmd 파일에 의해 규정된다. index.qmd 파일의 내용을 살펴보고 조교의 도움을 받아 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히 리스팅 유형(listing types) 옵션 세개(default, table, grid)를 살펴보고, 그 중 하나를 선택한다. 아래의 그림을 보면 그 차이를 직관적으로 알 수 있을 것이다.\n\n\n\n\n2.3.3 어바우트 페이지(about page)\n어바우트 페이지는 블로그와 블로그의 저작자에 대한 부가 정보를 제공하는 것으로 about.qmd 파일에 의해 규정된다. about.qmd 파일의 내용을 살펴보고 조교의 도움을 받아 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히 템플릿(template) 옵션 다섯개(jolla, trestles, solana, marquee, broadside)를 살펴보고, 그 중 하나를 선택한다. 아래는 jolla(좌)와 solana(우) 템플릿의 모습이다. 원한다면 사진도 변경할 수 있다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.4 포스트 디렉토리(posts directory)\n블로그의 콘텐츠는 포스트 디렉토리 속에 포함되어 있다. 기본적으로 하나의 포스트는 하나의 폴더인데, 개별 폴더 속에는 index.qmd라는 이름의 Quarto 파일이 들어 있다. 그리고 Quarto 다큐먼트에 포함되어 있는 이미지는 images라는 서브 폴더에 저장되어 있다.\n정리하면, 블로그를 만들기 위해 만든 폴더에 생성되는 .yml 파일은 블로그의 전체적인 모습을, index.qmd는 생성될 첫 블로그 페이지를, about.qmd는 블로그 정보를 담당한다. 이렇게 만들어진 블로그에 새로운 글은 하위의 post 폴더 내에 다시 qmd 파일을 생성하고 렌더링하여 포스팅할 수 있다.\n이제 다음의 절차에 따라 새로운 포스트를 생성해 본다.\n\nposts 디렉토리 아래에 새로운 디렉토리를 생성한다. 이름은 날짜와 주제가 결합된 형태로 하면 좋다.\n새로운 디렉토리에 index.qmd 파일을 생성한다. 아래와 같이 YAML 해더를 수정하고, 실습 1에서처럼 새로운 포스트를 작성한다.\n지금까지 배운 7번의 R 실습을 복습 겸 블로그에 차근차근 포스팅하여 나만의 기술 블로그로 만들 수도 있다.\n\n2.4 블로그를 웹 상에 출판하기\n어느 정도 개인 블로그가 완성되었다면, 다음의 절차에 따라 웹에 출판한다. 여기서는 Posit에서 제공하는 무료 출판 사이트인 Quarto Pub을 활용한다.\n\nQuarto Pub에 접속하여 계정을 만든다.\nRStudio에서, 왼쪽 하단부의 Terminal 탭을 누른다.\n프롬프트에 다음과 같이 입력하고 실행한다: quarto publish quarto-pub\n\n\n\n\n\n조교의 도움을 받고, 다음을 웹사이트를 참고한다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab08: 데이터로 소통하기: Quarto"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#데이터사이언스-프로세스-소통",
    "href": "R_lec_03_2025.html#데이터사이언스-프로세스-소통",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "데이터사이언스 프로세스: 소통",
    "text": "데이터사이언스 프로세스: 소통\n\nhttps://r4ds.hadley.nz/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#패키지",
    "href": "R_lec_03_2025.html#패키지",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "패키지",
    "text": "패키지\n\nhttps://r4ds.hadley.nz/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#section",
    "href": "R_lec_03_2025.html#section",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "",
    "text": "https://quarto.org/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#정의",
    "href": "R_lec_03_2025.html#정의",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "정의",
    "text": "정의\n\n“과학적, 기술적 출판을 위한 오픈소스 시스템(an open-source scientific and technical publishing system)”\n\n오픈소스 저작 시스템\n\n다양한 형식의 저작물(노트, 연구 논문, 프레젠테이션, 대시보드, 웹사이트, 블로그, 서적 등)을 다양한 디지털 포맷(HTML, PDF, MS Word, ePub 등)으로 출판할 수 있게 해주는 도구\n적용 분야의 스케일\n\n개인 스케일: 노트, 레포트, 연구 논문, 프레젠테이션, 블로그 등의 작성 도구\n그룹 스케일: 프로젝트의 원할한 진행을 위한 협업 프레임워크\n사회 스케일: 과학 커뮤니티의 재현성(reproducibility) 고양",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#기능",
    "href": "R_lec_03_2025.html#기능",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "기능",
    "text": "기능\n\nhttps://allisonhorst.com/cetinkaya-rundel-lowndes-quarto-keynote",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#기능-1",
    "href": "R_lec_03_2025.html#기능-1",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "기능",
    "text": "기능\n\nhttps://quarto.org/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#결과물-예시",
    "href": "R_lec_03_2025.html#결과물-예시",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "결과물 예시",
    "text": "결과물 예시\n\n개인 홈페이지 및 블로그: https://sangillee.snu.ac.kr/\n웹북: https://r4ds.hadley.nz/\n프레젠테이션: https://sangillee.snu.ac.kr/2024_AIEDAP/lecture_3.html\n대시보드: https://sangillee.snu.ac.kr/dashboard_popgeo/\n논문, 포스터, 소식지 등",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#구문syntax",
    "href": "R_lec_03_2025.html#구문syntax",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "구문(syntax)",
    "text": "구문(syntax)\n\n마크다운(markdown) 언어: 팬독(pandoc)\n\n마크업(markup) 언어: 다큐먼트의 구조와 포맷을 관장하는 텍스트-엔코딩 시스템\n사용자의 편의성을 크게 향상시킨 마크업 언어\n\nQuarto 다규먼트: .qmd\n\n프로그래밍 언어 + 워드프로세서",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#렌더링rendering",
    "href": "R_lec_03_2025.html#렌더링rendering",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "렌더링(rendering)",
    "text": "렌더링(rendering)\n\nknitr 패키지: .qmd를 .md로 전환\npandoc: .md를 다양한 디지털 포맷으로 전환\n\n\nhttps://r4ds.hadley.nz/quarto",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#quarto-다큐먼트의-기본-구조",
    "href": "R_lec_03_2025.html#quarto-다큐먼트의-기본-구조",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "Quarto 다큐먼트의 기본 구조",
    "text": "Quarto 다큐먼트의 기본 구조\n\nYAML 헤더(header)\n\n일종의 메타데이터\n다큐먼트의 전반적인 사항을 관장\n\n코드 청크(code chunk)\n\n프로그래밍 언어가 들어가는 부분\nR 스크립트 파일\n\n마크다운 텍스트(markdown text)\n\n워드프로세서처럼 텍스트를 작성(도표 포함)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#section-1",
    "href": "R_lec_03_2025.html#section-1",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "",
    "text": "https://r4ds.hadley.nz/quarto",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#yaml-헤더",
    "href": "R_lec_03_2025.html#yaml-헤더",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "YAML 헤더",
    "text": "YAML 헤더\n\n\n\n\n\n\n\n키(key)\n설명\n\n\n\n\ntitle\n다큐먼트의 제목\n\n\ndate\n다큐먼트 작성 날짜\n\n\nauthor\n다큐먼트 저자 이름\n\n\nformat\n다양한 포맷 관련 사항의 지정\n\n\ntoc\n목차 삽입\n\n\nnumber-section\n섹션 제목에 자동 번호 부여 여부\n\n\nexecute: echo\n소스 코드의 포함 여부를 글로벌하게 설정, 보통 true\n\n\nexecute: warning\n경고 메시지를 산출물에 나타나게 할지를 글로벌하게 설정, 보통 false\n\n\neditor\n비주얼 에디터와 소스 에디터 중 선택, 보통 visual",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#코드-청크",
    "href": "R_lec_03_2025.html#코드-청크",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "코드 청크",
    "text": "코드 청크\n\n\n\n\n\n\n\n\n\n\n\n\nOption\nRun code\nShow code\nOutput\nPlots\nMessages\nWarnings\n\n\n\n\neval: false\nX\n\nX\nX\nX\nX\n\n\ninclude: false\n\nX\nX\nX\nX\nX\n\n\necho: false\n\nX\n\n\n\n\n\n\nresults: hide\n\n\nX\n\n\n\n\n\nfig-show: hide\n\n\n\nX\n\n\n\n\nmessage: false\n\n\n\n\nX\n\n\n\nwarning: false\n\n\n\n\n\nX",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#마크다운-텍스트",
    "href": "R_lec_03_2025.html#마크다운-텍스트",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "마크다운 텍스트",
    "text": "마크다운 텍스트\n\n소스 에디터(source editor) vs. 비주얼 에디터(visual editor)\n마크다운 언어의 사용자 편이성을 한 번 더 강화한 것",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#zotero",
    "href": "R_lec_03_2025.html#zotero",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "Zotero",
    "text": "Zotero\n\nhttps://quarto.org/docs/visual-editor/technical.html",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#웹-발행publishing과-호스팅hosting-서비스",
    "href": "R_lec_03_2025.html#웹-발행publishing과-호스팅hosting-서비스",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "웹 발행(publishing)과 호스팅(hosting) 서비스",
    "text": "웹 발행(publishing)과 호스팅(hosting) 서비스\n\nQuarto Pub(https://quartopub.com/)\nGitHub Pages(https://pages.github.com/)\nNetlify(https://www.netlify.com/)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#quarto-pub",
    "href": "R_lec_03_2025.html#quarto-pub",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "Quarto Pub",
    "text": "Quarto Pub\n\nhttps://quarto.org/docs/publishing/quarto-pub.html",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#데이터-대시보드",
    "href": "R_lec_03_2025.html#데이터-대시보드",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "데이터 대시보드",
    "text": "데이터 대시보드\n\n레이아웃 요소: 대시보드의 기본 구조\n\n카드(행과 열)\n페이지, 내비게이션 바, 사이드바, 툴바, 탭셋\n\n내용 요소: 카드를 채우는 내용의 유형\n\n텍스트, 표, 그래프, 동영상, 밸류박스, 지도, 챗봇 등\n\n작동 요소: 상호작용성의 형식과 정도",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#예시",
    "href": "R_lec_03_2025.html#예시",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "예시",
    "text": "예시\nhttps://sangillee.quarto.pub/my-first-dashboard/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#레이아웃-요소-1-카드",
    "href": "R_lec_03_2025.html#레이아웃-요소-1-카드",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "레이아웃 요소 1: 카드",
    "text": "레이아웃 요소 1: 카드\n\nCodeResult\n\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1 \n\n### Column {width=60%}\n\nCard 2-2",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#레이아웃-요소-2-탭셋",
    "href": "R_lec_03_2025.html#레이아웃-요소-2-탭셋",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "레이아웃 요소 2: 탭셋",
    "text": "레이아웃 요소 2: 탭셋\n\nCodeResult\n\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30% .tabset}\n\n### Column\n\nCard 2-1 {width=50%}\n\n### Column\n\nCard 2-2 {width=50%}",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#레이아웃-요소-3-페이지",
    "href": "R_lec_03_2025.html#레이아웃-요소-3-페이지",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "레이아웃 요소 3: 페이지",
    "text": "레이아웃 요소 3: 페이지\n\nCodeResult\n\n\n# Page A\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1\n\n### Column {width=60%}\n\nCard 2-2\n\n# Page B\n\nCard 3",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#레이아웃-요소-4-내비게이션-바",
    "href": "R_lec_03_2025.html#레이아웃-요소-4-내비게이션-바",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "레이아웃 요소 4: 내비게이션 바",
    "text": "레이아웃 요소 4: 내비게이션 바\n\n\ntitle\nauthor\nformat: dashboard\n\nlogo\nnav-buttons\nscrolling: true\n\ntheme: 25 bootswatch themes(https://quarto.org/docs/dashboards/theming.html)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#레이아웃-요소-5-사이드바",
    "href": "R_lec_03_2025.html#레이아웃-요소-5-사이드바",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "레이아웃 요소 5: 사이드바",
    "text": "레이아웃 요소 5: 사이드바",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#내용-요소-1-그래프",
    "href": "R_lec_03_2025.html#내용-요소-1-그래프",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "내용 요소 1: 그래프",
    "text": "내용 요소 1: 그래프\n\n그래프 카드: 그래프 하나를 만들어내는 코드 청크\nggplot2 패키지, plotly 패키지\n\n#| title: \"Histogram of GDP per capita\"\nlibrary(tidyverse)\nlibrary(gapminder)\ngapminder |&gt; \n  filter(year == 2007) |&gt;\n  ggplot(aes(x = gdpPercap)) +\n  geom_histogram()",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#내용-요소-2-테이블",
    "href": "R_lec_03_2025.html#내용-요소-2-테이블",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "내용 요소 2: 테이블",
    "text": "내용 요소 2: 테이블\n\n테이블 카드: 테이블 하나를 만들어내는 코드 청크\nDT 패키지, knitr 패키지\n\n#| title: Lookup Table\nlibrary(DT)\ndatatable(gapminder, filter = \"top\", \n          options = list(\n            pageLength = 5, autoWidth = TRUE\n          ))",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#내용-요소-3-지도",
    "href": "R_lec_03_2025.html#내용-요소-3-지도",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "내용 요소 3: 지도",
    "text": "내용 요소 3: 지도\n\n지도 카드: 지도 하나를 만들어내는 코드 청크\nggplot2 패키지, leaflet 패키지\n\n#| title: A Reference Map \nlibrary(leaflet) \nleaflet() |&gt;  \n  addTiles()",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#내용-요소-4-텍스트",
    "href": "R_lec_03_2025.html#내용-요소-4-텍스트",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "내용 요소 4: 텍스트",
    "text": "내용 요소 4: 텍스트\n\n텍스트 카드: 텍스트 박스 하나를 만들어내는 div\n{.card} 탭과 title 속성\n\n::: {.card title=\"Text\"}\nThis is my first dashboard.\n:::",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#내용-요소-5-밸류박스valueboxe",
    "href": "R_lec_03_2025.html#내용-요소-5-밸류박스valueboxe",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "내용 요소 5: 밸류박스(valueboxe)",
    "text": "내용 요소 5: 밸류박스(valueboxe)\n\n밸류박스 카드: 밸류박스 하나를 만들어내는 코드 청크\n아이콘: bootstrap icon(https://icons.getbootstrap.com/)\n컬러: 8개(https://quarto.org/docs/dashboards/data-display.html)\n\n#| content: valuebox\n#| title: \"Number of Countries\"\nn_countries &lt;- gapminder |&gt; distinct(country) |&gt; nrow()\nlist(\n  icon = \"asterisk\",\n  color = \"primary\",\n  value = n_countries\n)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#웹-발행",
    "href": "R_lec_03_2025.html#웹-발행",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "웹 발행",
    "text": "웹 발행\n\nQuarto Pub(https://quartopub.com/)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "lab_09.html",
    "href": "lab_09.html",
    "title": "Lab09: 데이터로 소통하기: 대시보드 만들기",
    "section": "",
    "text": "이번 실습은 Quarto를 이용하여 데이터 대시보드(dashboard)를 만드는 것이다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab09: 데이터로 소통하기: 대시보드 만들기"
    ]
  },
  {
    "objectID": "lab_09.html#실습-개요",
    "href": "lab_09.html#실습-개요",
    "title": "Lab09: 데이터로 소통하기: 대시보드 만들기",
    "section": "",
    "text": "이번 실습은 Quarto를 이용하여 데이터 대시보드(dashboard)를 만드는 것이다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab09: 데이터로 소통하기: 대시보드 만들기"
    ]
  },
  {
    "objectID": "lab_09.html#레이아웃-설정법",
    "href": "lab_09.html#레이아웃-설정법",
    "title": "Lab09: 데이터로 소통하기: 대시보드 만들기",
    "section": "\n1 레이아웃 설정법",
    "text": "1 레이아웃 설정법\n\n1.1 페이지의 설정\n페이지(page)는 최상위 레이아웃 요소이다. 기본 원칙은 다음과 같다.\n\n헤더 1(header 1) 레벨이 페이지의 구분을 결정한다.\nQuarto에서는 페이지가 내비게이션바에 나타난다.\n\n# Page A\n\n# Page B\n\n1.2 사이드바의 설정\n사이드바(sidebar)는 {.sidebar} 태그를 통해 만들 수 있는데, 헤더 1(header 1) 레벨이므로 특정한 페이지에 종속되지 않는다. 사이드바는 주로 사용자의 투입을 받을 때 사용되기 때문에 동적인 대시보드에 주로 사용된다. 정적인 대시보드의 경우에는 텍스트를 통한 특정 정보의 제공에 사용될 수 있다.\n# {.sidebar}\nSidebar content\n\n1.3 행과 열의 설정\n행(row)과 열(column)은 가장 기본이 되는 레이아웃 요소이다. 기본 원칙은 다음과 같다.\n\n헤더 2(header 2) 레벨이 행과 열의 구분을 일차적으로 결정한다.\n헤더 3(header 3) 레벨이 하위 행과 열의 구분을 이차적으로 결정한다.\nRow와 Column 옆에 {height}, {width} 태그를 통해 가로 세로의 상대적인 크기를 정한다.\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1\n\n### Column {width=60%}\n\nCard 2-2\n\n# Page B\n\nCard 3\n\n1.4 탭셋의 설정\nRow나 Column에 {.tabset}을 표기하면, 하위의 행과 열이 탭으로 구분된다. 이렇게 하면 카드의 크기가 지나치게 줄어드는 단점을 해소할 수 있다.\n\n1.5 기본 구조 살펴보기\n위를 바탕으로 대시보드의 골격을 작성해본다.\n---\ntitle: \"dashboard\"\nformat: dashboard\ntheme: default\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n# {.sidebar}\nSidebar content\n\n# Page A\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1\n\n### Column {width=60%}\n\nCard 2-2 {.tabset}\n\n#### Column\n\nCard 2-1 {width=50%}\n\n#### Column\n\nCard 2-2 {width=50%}\n\n# Page B\n\nCard 3\n위와 같이 설정하면 다음과 같은 결과를 얻을 수 있다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab09: 데이터로 소통하기: 대시보드 만들기"
    ]
  },
  {
    "objectID": "lab_09.html#카드와-내용-요소",
    "href": "lab_09.html#카드와-내용-요소",
    "title": "Lab09: 데이터로 소통하기: 대시보드 만들기",
    "section": "\n2 카드와 내용 요소",
    "text": "2 카드와 내용 요소\n카드(card)란 특정한 내용 요소(텍스트, 벨류박스, 테이블, 그래프, 지도 등)를 포함하고 있는, 대시보드의 가장 기본적인 단위이다. 다음의 두 가지 사항이 중요하다.\n\n카드의 제목이 중요하다. 완성된 대시보드 상에 등장하기 때문에 사용자가 이해하기 쉬운 제목이 부여되어야 한다.\n내용 요소에 따라 카드를 작성하는 방법이 조금 다르다.\n\n내용 요소 제작의 세세한 사항은 아래의 “예시 대시보드 만들기”에서 확인한다.\n\n2.1 그래프\nQuarto는 그래프 하나를 만들어내는 코드 청크를 하나의 카드로 인식한다. 그래프 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. ggplot2와 같은 정적인 플롯 도구 뿐만 아니라 plotly와 같은 반응형 플롯 도구를 사용하여 그래프 카드를 생성한다.\n\n2.2 테이블\nQuarto는 테이블 하나를 디스플레이하는 코드 청크를 하나의 카드로 인식한다. 테이블 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. knitr 패키지의 kable() 함수, DT 패키지의 datatable() 함수 등을 이용해 테이블 카드를 생성한다.\n\n2.3 지도\nQuarto는 지도 하나를 디스플레이하는 코드 청크를 하나의 카드로 인식한다. 지도 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. ggplot2와 같은 정적인 지도 제작 도구 뿐만 아니라 leaflet과 같은 반응형 지도 제작 도구를 사용하여 지도 카드를 생성한다.\n\n2.4 텍스트\n일종의 텍스트 박스도 하나의 카드로 간주된다. 그래프, 테이블, 지도가 하나의 코드 청크가 하나의 카드로 인식되는데 반해 텍스트 카드는 다른 형식을 취한다. ::: {.card} div를 사용해야 하며 괄호 내부에 title= 옵션을 사용해 제목을 지정해야 한다. 가령 {.card title=\"Text\"}와 같이 표기해야 한다.\n\n2.5 밸류박스\n요약적 수치를 큰 박스 속에 나타내는 것을 밸류박스(value box)라고 하는데, 코드 청크로 표현하지만 형식은 조금 다르다. #| content: valuebox라는 옵션이 반드시 포함되야 하며, 제목을 지정하기 위해 #| title: 옵션도 필요하다. 또한 리스트를 이용해 아이콘(icon), 컬러(color), 수치(value)를 지정해야 한다.\n아이콘은 부트스트랩 아이콘(bootstrap icon)이 사용된다. 적절한 아이콘을 찾고 그 이름을 #| title: 옵션을 통해 설정하는 것이 중요하다.\n모든 컬러가 다 사용가능한 것은 아니다. 아래의 표를 참조하여 컬러를 설정해야 한다.\n\n\nColor Alias\nDefault Theme Color(s)\n\n\n\nprimary\nBlue\n\n\nsecondary\nGray\n\n\nsuccess\nGreen\n\n\ninfo\nBright Blue\n\n\nwarning\nYellow/Orange\n\n\ndanger\nRed\n\n\nlight\nLight Gray\n\n\ndark\nBlack",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab09: 데이터로 소통하기: 대시보드 만들기"
    ]
  },
  {
    "objectID": "lab_09.html#예시-대시보드-만들기",
    "href": "lab_09.html#예시-대시보드-만들기",
    "title": "Lab09: 데이터로 소통하기: 대시보드 만들기",
    "section": "\n3 예시 대시보드 만들기",
    "text": "3 예시 대시보드 만들기\n위의 사항을 바탕으로 예시 대시보드(https://sechangkim.quarto.pub/my-first-dashboard/)에 접속하여 구성을 살펴본다. 다음의 사항에 주목한다.\n\n내비게이션바에 서울대학교 로고가 있고, 오른쪽 맨 끝애 홈페이지 및 이메일 아이콘이 위치해 있다.\n대시보드가 네 개의 페이지(Intro, Graphs, Tables, Maps)로 나뉘어져 있고, 각 페이지마다 행, 열, 탭셋과 같은 레이아웃 요소들이 배치되어 있다.\n\n어떤 식으로 제작할 수 있을지 생각해 본다. 새로운 프로젝트를 생성하고 Quarto 다큐먼트를 생성한다. 아래는 해당 대시보드를 만들기 위해 사용된 코드이다. 참고하여 자신만의 대시보드를 만들어 본다. 단, 로고 및 홈페이지 주소는 반드시 자신의 것으로 수정해야 한다.\n\n3.1 YAML 해더\n특히, nav-buttons: 옵션의 지정 형식에 주의한다. scrolling 옵션과 다양한 theme: 옵션을 시험해 본다.\n---\ntitle: \"My First Dashboard\"\nauthor: Your name\nformat: \n  dashboard:\n    embed-resources: true\n    logo: img/snu_ui_download.png\n    nav-buttons: \n      - icon: house-door-fill\n        href: Your Blog Address\n        aria-label: GitHub\n      - icon: envelope\n        href: mailto:vs5345@snu.ac.kr\n        aria-label: Mail\ntheme: default\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n3.2 Intro 페이지\nIntro라는 이름의 페이지를 설정한다.\n# Intro\n\n3.2.1 첫번째 행: Text 카드\n행을 설정하고 행의 상대적인 높이(10%)를 지정한다.\n## Row {height=\"12%\"}\n텍스트 카드를 생성한다. 텍스트 카드를 생성하기 위해 {.card} 태그가 사용되어야 하며, 텍스트 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다.\n::: {.card title=\"Text\"}\nThis is my first dashboard.\n:::\n\n3.2.2 두번째 행의 탭셋: Histogram of GDP per capita & Table of Mean Values\n행을 설정하고 행의 상대적인 높이(70%)를 지정한다. 탭셋을 생성하기 위해 {.tabset} 태그가 사용되어야 함에 주의한다.\n## Row {.tabset height=\"70%\"}\n그래프 카드를 생성하기 위해 ggplot2 패키지를 활용한다. 그래프 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다. 두 개의 그래프를 지난 실습에서 배웠던 patchwork 함수로 가로 배치하였다. 이때 산출될 플롯의 크기는 fig-width와 fig-height로 조정할 수 있다.\n#| title: \"Histogram of GDP per capita\"\n#| fig-width: 20\n#| fig-height: 6\nlibrary(tidyverse)\nlibrary(gapminder)\nlibrary(patchwork)\n\np1 &lt;- gapminder |&gt; \n  filter(year==2007) |&gt; \n  ggplot(aes(x=gdpPercap))+\n  geom_histogram()\n\np2 &lt;- gapminder |&gt; \n  filter(year==2007) |&gt; \n  ggplot(aes(x=gdpPercap, y=lifeExp))+\n  geom_point()\n\np1|p2\n테이블 카드를 생성하기 위해 knitr 패키지의 kable() 함수를 활용한다. 테이블 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다.\n#| title: \"Table of Mean Values\"\nlibrary(knitr)\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  summarize(\n    GDP_percap = mean(gdpPercap),\n    Life_Exp = mean(lifeExp),\n    Population = mean(pop),\n    .by = continent\n  ) |&gt; \n  kable()\n\n3.2.3 세번째 행의 3개의 밸류박스\n행을 설정하고 행의 상대적인 높이(18%)를 지정한다.\n## Row {height=\"18%\"}\n첫번째 밸류박스를 생성한다. #| content: valuebox 옵션과 #| title: 옵션이 사용됨에 주의한다.\n#| content: valuebox\n#| title: \"Number of Countries\"\nn_countries &lt;- gapminder |&gt; distinct(country) |&gt; nrow()\nlist(\n  icon = \"asterisk\",\n  color = \"primary\",\n  value = n_countries\n)\n두번째 밸류박스를 생성한다.\n#| content: valuebox\n#| title: \"First Year\"\nfirst_year &lt;- gapminder |&gt; distinct(year) |&gt; pull() |&gt; first()\nlist(\n  icon = \"airplane\",\n  color = \"secondary\",\n  value = first_year\n세번째 밸류박스를 생성한다.\n#| content: valuebox\n#| title: \"Last Year\"\nlast_year &lt;- gapminder |&gt; distinct(year) |&gt; pull() |&gt; last()\nlist(\n  icon = \"bank\",\n  color = \"success\",\n  value = last_year\n)\n더 다양한 아이콘이 궁금하다면 이 웹사이트를 참고할 것.\n\n3.3 Graphs 페이지\nGraphs라는 이름의 페이지를 설정한다.\n# Graphs\n\n3.3.1 첫번째 행의 그래프 카드: GDP and Life Expectancy\n행을 설정한다.\n## Row\nggplot2 패키지를 활용하여 그래프 카드를 생성한다.\n#| title: GDP and Life Expectancy\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(aes(x = log10(gdpPercap), y = lifeExp)) +\n  geom_point(aes(color = continent), show.legend = FALSE) +\n  geom_smooth() + \n  facet_wrap(~continent, ncol = 5)\n\n3.3.2 두번째 행의 그래프 카드: Population & Life Expectancy\n첫번째 그래프(Population)를 위한 열을 설정한다.\n### Column\n그래프 카드를 생성한다.\n#| title: Population\ngapminder |&gt; \n  summarize(\n    sum_pop = sum(pop),\n    .by = c(year, continent)\n  ) |&gt; \n  ggplot(aes(x = year, y = sum_pop)) +\n  geom_area(aes(fill = continent)) +\n  labs(x = \"Year\", y = \"Population\", fill = \"Continents\")\n두번째 그래프(Life Expectancy)를 위한 열을 설정한다.\n### Column\n그래프 카드를 생성한다.\n#| title: Life Expectancy\ngapminder |&gt; \n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line(aes(color = continent, group = country)) +\n  labs(x = \"Year\", y = \"Life Expectancy\", color = \"Continents\")\n\n3.4 Tables 페이지\nTables라는 이름의 페이지를 설정한다.\n# Tables\n단일 행을 설정한다.\n## Row\nDT 패키지를 활용하여 테이블 카드를 생성한다.\n#| title: Lookup Table\nlibrary(DT)\ndatatable(gapminder, filter = \"top\", \n          options = list(\n            pageLength = 5, autoWidth = TRUE\n          ))\n\n\n\n\n\n\n노트DT() 함수\n\n\n\n\n\n다음 주 강의에 조금 더 자세히 배우겠지만, DT는 다양한 표 형식을 제공한다. 아래의 코드는 필터링 기능과 수정 기능, 다운로드 버튼을 생성해준다.\n\nlibrary(DT)\nlibrary(gapminder)\ndatatable(gapminder,\n          filter = \"top\",\n          editable=TRUE,\n          extensions = \"Buttons\",\n          options = list(\n            pageLength = 15,\n            autoWidth = TRUE,\n            dom = \"Bfrtip\",\n            buttons=c(\"copy\", \"excel\", \"pdf\", \"print\")\n          ))\n\n\n\n\n\n\n\n\n\n3.5 Maps 페이지\nMaps라는 이름의 페이지를 설정한다.\n# Maps\n단일 행을 설정한다.\n## Row\nleaflet 패키지를 활용하여 지도 카드를 생성한다.\n#| title: A Reference Map \nlibrary(leaflet) \nleaflet() |&gt;  \n  addTiles()\n\n\n\n\n\n\n노트leaflet 패키지\n\n\n\n\n\nleaflet() 함수는 다양한 지도와 환경설정을 제공한다. 초점을 경도 0도, 위도 20도에 두고 확대 정도를 3단계로 두고 싶다면 아래와 같은 코드를 사용할 수 있다. 또한 배경 지도도 변경할 수 있는데, 이 때는 addProviderTiles() 함수를 활용할 수 있다.\n\nlibrary(leaflet) \nleaflet() |&gt;  \n  setView(lng=0, lat=20, zoom=3) |&gt; \n  addProviderTiles('CartoDB.Positron')\n\n\n\n\n\n\n\n\n\n3.6 대시보드 웹 상에 출판하기\n블로그와 마찬가지로 다음의 절차에 따라 완성된 대시보드를 웹 상에 출판한다. 여기서는 Posit에서 제공하는 무료 출판 사이트인 Quarto Pub을 활용한다.\n\nQuarto Pub에 접속하여 계정을 만든다.\nRStudio에서, 왼쪽 하단부의 Terminal 탭을 누른다.\n프롬프트에 다음과 같이 입력하고 실행한다: quarto publish quarto-pub\n나머지 사항에 대해서는 조교의 도움을 받는다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab09: 데이터로 소통하기: 대시보드 만들기"
    ]
  },
  {
    "objectID": "lab_02.html",
    "href": "lab_02.html",
    "title": "Lab02: R과 데이터사이언스",
    "section": "",
    "text": "R의 패키지에 대해 이해할 수 있다.\n\n데이터사이언스의 과정을 개괄적으로 이해할 수 있다.\n\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기\n\n\n파이프 연산자의 사용법에 대해 이해할 수 있다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#실습의-목표",
    "href": "lab_02.html#실습의-목표",
    "title": "Lab02: R과 데이터사이언스",
    "section": "",
    "text": "R의 패키지에 대해 이해할 수 있다.\n\n데이터사이언스의 과정을 개괄적으로 이해할 수 있다.\n\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기\n\n\n파이프 연산자의 사용법에 대해 이해할 수 있다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#패키지",
    "href": "lab_02.html#패키지",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n1 패키지",
    "text": "1 패키지\n패키지를 사용하기 우선 패키지가 사용자의 디바이스에 물리적으로 인스톨되어 있어야 하고, R 세션에서 패키지를 불러와야 한다. 패키지를 인스톨하는 방법은 두 가지 이다. 스크립트 내에서 패키지를 반복해서 인스톨하는 것은 합리적이지 않기 때문에 전자의 관행을 추천한다.\n\nOutput 창의 Packages 탭 선택: Install 아이콘 클릭하고 패키지 이름 입력\n스크립트 내에서 인스톨하기: install.packages(\"패키지명\")\n\n쌍따옴표 속에 패키지 이름을 타이핑해야 한다. 한번 인스톨이 되면 업데이트하지 않는 한 새롭게 패키지를 인스톨할 필요가 없다. 인스톨된 패키지를 사용하려면 스크립트 내에서 다음과 같이 타이핑하고 실행한다.\n\nlibrary(패키지명)\n\n괄호 속에 패키지명을 기입해야 한다.\n\n\n\n\n\n\n중요\n\n\n\ninstall.packages()함수에서는 반드시 패키지명을 쌍따옴표로 싸야하지만, library()함수에서는 그렇지 않다. 불러온 패키지는 R 세션이 유지되는 동안 내내 사용할 수 있지만, R 세션을 끝내고 다시 시작하면 다시 library()함수를 이용해 다시 불러와야 한다. 그래서 R 스크립트 파일의 시작 부분에는 패키지를 불러오는 코드를 위치시키고, 다시 스크립트 파일을 열 때마다 그 부분을 재실행하는 것이 좋은 습관이다.\n\n\ntidyverse 패키지를 사용하는 것의 장점은 이 패키지만 불러오면 구성 패키지까지 한꺼번에 사용할 수 있게 된다는 점이다. 스크립트 내에서 다음과 같은 코드를 실행한다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#시각화하기",
    "href": "lab_02.html#시각화하기",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n2 시각화하기",
    "text": "2 시각화하기\n\n2.1 데이터 살펴보기\n이 실습을 위해 남극 파머군도(Palmer Archipelago)에 서식하는 펭귄 성체의 신체 계측 데이터를 사용한다. 이 데이터는 palmerpenguins라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다.\n\nlibrary(palmerpenguins)\n\n이제 이 패키지에 포함되어 있는 penguins라는 이름의 데이터를 불러온다.\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n데이터를 자세히 살펴보면 몇 가지를 알 수 있다.\n\n티블(tibble)이라는 형식의 데이터 프레임이다. 티블은 tidyverse의 공식 데이터 프레임 포맷이다.\n관측개체는 344개, 변수는 8개이다.\nspecies, island, sex 변수의 유형은 팩트형(fctr)이고, bill_length_mm, bill_depth_mm은 실수형(dbl)이고, 나머지는 정수형(int)이다.\n\n변수가 많아지면 전체 데이터를 조망하기 어렵기 때문에, 최초의 tidyverse 함수인 glimpse()를 사용하여 데이터의 행과 열을 바꾸어 보자.\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\n\n\n\n\n힌트데이터 내 속성들에 대한 정보가 궁금할 때\n\n\n\n\n\npenguins 데이터 내 속성들에 대한 설명을 보고싶다면 help(penguins) 또는 ?penguins를 입력한 뒤 실행한다.\n\n\n\n\n2.2 그래프 만들기\n이 penguins 데이터와 ggplot2() 패키지를 이용하여 “펭귄의 날개 길이와 몸무게의 관계”를 표현하는 그래프를 작성해 보자. ggplot2()의 더 많은 사용법에 대해서는 이후의 실습에서 매우 자세히 다룰 것이기 때문에 오늘은 간단한 제작 과정만을 따라가 보면서 데이터 시각화에 흥미를 가질 수 있도록 해보자.\n\n2.2.1 플롯 객체의 지정\nggplot()이라는 함수를 통해 플롯 제작을 개시하는 단계이며, 어떤 데이터를 사용할지를 지정한다.\n\nggplot(data = penguins) # 플롯 제작에 penguins 데이터를 사용\n\n\n\n\n\n\n\n\n2.2.2 플롯의 심미성 지정\n데이터가 어떤 시각적 속성으로 표현될 것인가를 지정한다. 여기서는 간단히 어떤 변수들이 x-축과 y-축에 나타나는지만 지정한다. mapping = aes() 아규먼트가 핵심이다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n힌트코드의 가독성을 위한 Tip\n\n\n\nR에서 코드를 작성하다 보면 한 덩어리의 코드가 매우 길어지는 일이 빈번하게 발생한다. 코드를 정리하지 않고 계속 작성할 경우 작성자 본인이 봐도 무엇을 한 것인지 모르는 일이 발생하기 때문에 줄바꿈을 통해 코드를 간결하게 정리하는 것이 좋다. 특히 R이 익숙하지 않은 초보자의 경우 각 줄마다 본인이 무엇을 했는지 # 각주를 통해 설명을 달아 놓으면 R 문법에 익숙해지는데 도움이 된다.\n\n\n\n2.2.3 플롯의 기하 속성 지정\n데이터가 어떤 기하학적 속성으로 표현될 것인가를 지정한다. geom 아규먼트가 핵심인데, geom_point()는 데이터를 포인트라고 하는 기하학적 속성으로 표현한다는 것을 지정한 것으로 결국 산포도(scatterplot)을 산출하게 된다.\n\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n) +\n  geom_point() # 데이터를 산포도로 표현\n\n\n\n\n\n\n\n\n2.2.4 심미성의 첨가\n이러한 관련성이 펭귄의 종족에 따라 다르게 나타나는지를 탐색하기 위해 color 라는 심미성을 species라는 변수에 적용한다.\n\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species) # x축에 날개 길이, y축에 몸무게를 표시, 종별로 색상을 지정\n) +\n  geom_point() # 데이터를 산포도로 표현\n\n\n\n\n\n\n\n\n2.2.5 기하 레이어의 첨가\n두 변수의 관련성을 보여주는 선형 기하를 첨가한다. 여기서는 geom_smooth()를 이용하여 OLS 회귀선을 첨가한다.\n\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n) +\n  geom_point(mapping = aes(color = species)) + # 데이터를 산포도로 표현, 종별로 색상을 지정\n  geom_smooth(method = \"lm\") # OLS 회귀선을 추가\n\n\n\n\n\n\n\n\n\n\n\n\n\n힌트OLS 회귀선이란?\n\n\n\n\n\nOLS(Ordinary Least Square, 최소제곱법) 회귀선이란 관측값과 회귀선의 차이인 잔차의 제곱을 최소화하는 직선을 의미한다. 데이터들의 추세선 정도로 이해하면 된다. 선 주변의 음영은 신뢰 구간을 나타내는데, 이를 제거하고 싶으면 se = FALSE를 추가하면 된다.\n\n\n\n\n2.2.6 라벨링 등 마무리 작업\n\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n) +\n  geom_point(mapping = aes(color = species)) + # 데이터를 산포도로 표현, 종별로 색상을 지정\n  geom_smooth(method = \"lm\") + # OLS 회귀선을 추가\n  labs(\n    title = \"Body mass and flipper length\", # 플롯의 제목을 지정\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\", # 플롯의 부제목을 지정\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\", # 축의 이름을 지정\n    color = \"Species\" # 범례의 제목을 설정\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n노트\n\n\n\n데이터 시각화에 대한 보다 자세한 내용은 5주차 실습에서 다룬다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#변형하기",
    "href": "lab_02.html#변형하기",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n3 변형하기",
    "text": "3 변형하기\n변형하기와 관련된 함수들은 대부분 dplyr 패키지에 포함되어 있다.\n\n3.1 데이터 살펴보기\n이 실습을 위해 미국 교통통계국(U.S. Bureau of Transportation)이 제공하는 데이터를 사용하는데, 이것은 2013년 한 해 동안 미국 뉴욕시를 출발한 336,776대의 항공기에 대한 정보를 담고 있다. 이 데이터는 nycflights13 이라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다. 그리고 나서 패키지에 포함되어 있는 flights라는 이름의 데이터를 불러온다.\n\nlibrary(nycflights13)\nglimpse(flights)\n\nRows: 336,776\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n\n\n\n\n\n\n힌트\n\n\n\nflights 데이터 내 속성들에 대한 설명을 보고싶다면 help(flights) 또는 ?flights를 입력한 뒤 실행한다.\n\n\n\n3.2 주요 함수\n여기서는 가장 널리 사용되는 6개 함수에 대해서만 개략적으로 다룬다. 그 6개 함수는 select(), filter(), arrange(), mutate(), group_by(), summerize()이다.\n\n3.2.1 select() 함수\n열(변수) 중 일부를 솎아낸다. 즉, 변수의 개수를 줄인다.\n\nselect(flights, year, month, day) # 지정한 열(변수)만 추출\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\n\n3.2.2 filter() 함수\n특정 열(변수)에 의거해 조건을 만족하는 행을 솎아낸다. 즉 관측개체의 갯수를 줄인다.\n\nfilter(flights, month == 1 & day == 1) # 지정한 행(관측개체)만 추출\n\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.3 arrange() 함수\n특정 열(변수)에 의거해 행의 순서를 바꾼다. 내림차순으로 정렬하고 싶다면 desc(dep_time)을 넣으면 된다.\n\narrange(flights, dep_time) # dep_time 오름차순으로 행 정렬\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1    13        1           2249        72      108           2357\n 2  2013     1    31        1           2100       181      124           2225\n 3  2013    11    13        1           2359         2      442            440\n 4  2013    12    16        1           2359         2      447            437\n 5  2013    12    20        1           2359         2      430            440\n 6  2013    12    26        1           2359         2      437            440\n 7  2013    12    30        1           2359         2      441            437\n 8  2013     2    11        1           2100       181      111           2225\n 9  2013     2    24        1           2245        76      121           2354\n10  2013     3     8        1           2355         6      431            440\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.4 mutate() 함수\n기존의 열(변수)을 변형하여 새로운 열(변수)을 생성한다. 아래에 gain , speed  변수가 새로 생긴 것을 확인할 수 있다.\n\nmutate(flights,\n    gain = dep_delay - arr_delay, # gain이라는 새로운 열(변수) 생성\n    speed = distance / air_time * 60 # speed라는 새로운 열(변수) 생성\n  )\n\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, gain &lt;dbl&gt;, speed &lt;dbl&gt;\n\n\n\n3.2.5 group_by() 함수\n열(변수)(범주형 변수, categorical variables)에 의거해 전체 행을 그룹으로 분할한다. Groups: month[12]를 통해 월별로 행이 분할되었음을 알 수 있다.\n\ngroup_by(flights, month) # 전체 행을 월별로 분할\n\n# A tibble: 336,776 × 19\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.6 summerize() 함수\n열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장한다.\n\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE)) # dep_delay의 평균을 delay라는 변수에 저장\n\n# A tibble: 1 × 1\n  delay\n  &lt;dbl&gt;\n1  12.6\n\n\n\n\n\n\n\n\n힌트결측값\n\n\n\n\n\nR에서 데이터 셋에 결측값이 포함되어 있을 경우 통계량을 계산하면 NA라는 결과를 얻게 된다. 따라서 데이터셋에 결측값이 있는지 확인한 뒤 이를 분석에서 제외하거나 다른 값으로 대체해야 한다. 여기에서는 결측값을 분석에서 제외하는 방법만 다룬다.\n\n# 결측값을 포함하여 통계량을 계산했을 때\nsummarize(flights, delay = mean(dep_delay))\n\n# A tibble: 1 × 1\n  delay\n  &lt;dbl&gt;\n1    NA\n\n\n\n# dep_delay변수에 결측값이 몇개 있는지 확인: is.na\nsum(is.na(flights$dep_delay))\n\n[1] 8255\n\n\n\n# 통계량 계산에서 결측값을 제외: na.rm = TRUE\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  delay\n  &lt;dbl&gt;\n1  12.6\n\n\n\n\n\n위의 group_by() 함수와 결합하면, 그룹별로 열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장할 수 있다.\n\nby_day &lt;- group_by(flights, year, month, day) # 전체 행을 연, 월, 일로 분할하여 새로운 변수에 할당\nsummarize(by_day, delay = mean(dep_delay, na.rm = TRUE)) # 일별 delay 계산\n\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day delay\n   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n 1  2013     1     1 11.5 \n 2  2013     1     2 13.9 \n 3  2013     1     3 11.0 \n 4  2013     1     4  8.95\n 5  2013     1     5  5.73\n 6  2013     1     6  7.15\n 7  2013     1     7  5.42\n 8  2013     1     8  2.55\n 9  2013     1     9  2.28\n10  2013     1    10  2.84\n# ℹ 355 more rows\n\n\n\n\n\n\n\n\n노트\n\n\n\n데이터 변형하기에 대한 보다 자세한 내용은 4주차 실습에서 다룬다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#정리하기",
    "href": "lab_02.html#정리하기",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n4 정리하기",
    "text": "4 정리하기\n정리하기와 관련된 함수들은 대부분 tidyr 패키지에 포함되어 있다. 많은 함수가 있지만 가장 중요한 두 개의 함수에만 집중한다.\n\n4.1 데이터 살펴보기\n이 실습에서는 tidyverse에 포함되어 있는 매우 단순한 데이터를 사용한다.\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n\n\n\n4.2 주요 함수\n\n4.2.1 pivot_longer() 함수\ntable4a에서 1999과 2000은 변수명일 수 없다. year라는 변수의 속성이어야 한다.\n\npivot_longer(\n  table4a, \n  cols = c(`1999`, `2000`), # 바꾸고싶은 변수 지정 \n  names_to = \"year\", # 원래 데이터의 변수명들이 들어갈 새로운 변수명 지정\n  values_to = \"cases\" # 원래 데이터의 값들이 들어갈 새로운 변수명 지정\n)\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\n\n4.2.2 pivot_wider() 함수\ntable2에서 type 변수는 두 개의 변수명을 포함하고 있다. 즉, cases와 population은 속성값이라기 보다는 변수명이다.\n\npivot_wider(\n  table2, \n  names_from = \"type\", # 원래 데이터의 type 값들을 변수로 변환\n  values_from = \"count\" # 원래 데이터의 count 값들을 변수의 값으로 변환\n)\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\n\n\n\n\n\n\n\n노트\n\n\n\n데이터 정리하기에 대한 보다 자세한 내용은 3주차 실습에서 다룬다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#불러오기",
    "href": "lab_02.html#불러오기",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n5 불러오기",
    "text": "5 불러오기\n불러오기와 관련된 함수들은 대부분 readr 패키지에 포함되어 있다. 여러 유형의 파일을 불러오기 위해 여러 함수가 존재하지만, 콤마분리값(comma-separated values, CSV) 형식의 데이터를 불러오는 함수(read_csv())만 실습한다.\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\") # URL에서 가져온 CSV 파일을 students에 할당\nglimpse(students)\n\nRows: 6\nColumns: 5\n$ `Student ID`   &lt;dbl&gt; 1, 2, 3, 4, 5, 6\n$ `Full Name`    &lt;chr&gt; \"Sunil Huffmann\", \"Barclay Lynn\", \"Jayendra Lyne\", \"Leo…\n$ favourite.food &lt;chr&gt; \"Strawberry yoghurt\", \"French fries\", \"N/A\", \"Anchovies…\n$ mealPlan       &lt;chr&gt; \"Lunch only\", \"Lunch only\", \"Breakfast and lunch\", \"Lun…\n$ AGE            &lt;chr&gt; \"4\", \"5\", \"7\", NA, \"five\", \"6\"\n\n\n\n\n\n\n\n\n노트\n\n\n\n데이터 불러오기에 대한 보다 자세한 내용은 3주차 실습에서 다룬다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#파이프-연산자pipe-operator",
    "href": "lab_02.html#파이프-연산자pipe-operator",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n6 파이프 연산자(pipe operator)",
    "text": "6 파이프 연산자(pipe operator)\n우리는 이전 실습에서 할당 연산자(&lt;-)에 대해 배웠다. 오늘 살펴본 다양한 변형의 결과를 다른 데이터 프레임에 담고 싶으면 다음과 같이 할당 연산자를 사용할 수 있다.\n\nflights_day1 &lt;- filter(flights, month == 1 & day == 1)\nglimpse(flights_day1)\n\nRows: 842\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n\n6.1 파이프 연산자\n\n현재 RStudio의 디폴트는 %&gt;%로 설정되어 있다. 이것을 Tools &gt; Global Options &gt; Code에 가서 ’Use native pipe operator, |&gt; (requires R 4.1+)’를 선택해 주어야 한다. 아래의 그림 1 를 참고하라.\n\n\n\n\n\n\n그림 1: 파이프 연산자(https://r4ds.hadley.nz/data-transform)\n\n\n\n단축키는 Crtl + Shift + M(Mac은 Commnad + Shift + M)이다. 다른 건 몰라도 이 단축키만은 반드시 기억해야 한다.\n\nIAH 공항으로 가기 위한 가장 빠른 항공편을 찾기 위한 다음의 코드들을 비교해 보자. 먼저 파이프 연산자를 사용하지 않은 경우이다.\n\n# 중간에 여러 변수를 거쳐야 한다.\nflights1 &lt;- filter(flights, dest == \"IAH\")\nflights2 &lt;- mutate(flights1, speed = distance / air_time * 60)\nflights3 &lt;- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n\n# 또는 함수 안에 함수를 집어넣는 과정을 반복해야 한다.\narrange(\n  select(\n    mutate(\n      filter(\n        flights, \n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n다음은 파이프 연산자를 사용한 경우이다. 동일한 결과를 가져다 주지만 훨신 더 간결하고 직관적이고 이해하기 쉽다. 파이프 연산자의 사용 원리는 이후 실습에서 자세히 배운다.\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt;\n  mutate(speed = distance / air_time * 60) |&gt; \n  select(year:day, dep_time, carrier, flight, speed) |&gt; \n  arrange(desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "abc.html",
    "href": "abc.html",
    "title": "abc",
    "section": "",
    "text": "이상일\n\n\n\n 맨 위로"
  },
  {
    "objectID": "exec_01.html",
    "href": "exec_01.html",
    "title": "R과 RStudio",
    "section": "",
    "text": "여기서는 R과 RStudio의 기본기를 다진다. 다음과 같은 사항이 다루어진다.\n\nR과 RStudio 설치\nRStudio 둘러보기\n프로젝트와 스크립트 개념 이해하기\n\n\n\n\n\n\n\n경고\n\n\n\nR은 실행과정에서 폴더 경로에 한글이 포함된 경우 오류가 자주 발생한다. 따라서 사용자 계정 이름이 한국어로 설정되어 있지 않은지 반드시 확인해야 하며, 앞으로 만들 프로젝트 폴더 등도 이름을 모두 영어로 설정하는 것이 좋다.\nWindows: [설정] -&gt; [계정] -&gt; [사용자 정보]로 들어가 볼드체로 된 사용자 계정 이름이 영어인지 확인하기. 사용자 계정이 한국어로 설정되어 있다면 영어로 된 새로운 윈도우 사용자 계정을 만들어야 한다.\nMac: 프로젝트 폴더 이름 설정만 잘 신경쓰면 된다.",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 RStudio"
    ]
  },
  {
    "objectID": "exec_01.html#개요",
    "href": "exec_01.html#개요",
    "title": "R과 RStudio",
    "section": "",
    "text": "여기서는 R과 RStudio의 기본기를 다진다. 다음과 같은 사항이 다루어진다.\n\nR과 RStudio 설치\nRStudio 둘러보기\n프로젝트와 스크립트 개념 이해하기\n\n\n\n\n\n\n\n경고\n\n\n\nR은 실행과정에서 폴더 경로에 한글이 포함된 경우 오류가 자주 발생한다. 따라서 사용자 계정 이름이 한국어로 설정되어 있지 않은지 반드시 확인해야 하며, 앞으로 만들 프로젝트 폴더 등도 이름을 모두 영어로 설정하는 것이 좋다.\nWindows: [설정] -&gt; [계정] -&gt; [사용자 정보]로 들어가 볼드체로 된 사용자 계정 이름이 영어인지 확인하기. 사용자 계정이 한국어로 설정되어 있다면 영어로 된 새로운 윈도우 사용자 계정을 만들어야 한다.\nMac: 프로젝트 폴더 이름 설정만 잘 신경쓰면 된다.",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 RStudio"
    ]
  },
  {
    "objectID": "exec_01.html#r과-rstudio-설치",
    "href": "exec_01.html#r과-rstudio-설치",
    "title": "R과 RStudio",
    "section": "\n1 R과 RStudio 설치",
    "text": "1 R과 RStudio 설치\n프로그램을 다운로드하기 위해 다음의 웹사이트로 이동한다. 여기는 RStudio를 만든 posit(과거에는 회사명 자체도 RStudio였음)이라는 회사가 관리하는 RStudio Desktop 다운로드 페이지이다.\n그러면 그림 1 과 같이 R과 RStudio를 설치할 수 있는 화면이 나타날 것이다.\n\n\n\n\n\n그림 1: 다운로드 화면\n\n\n\n1.1 R의 설치\n왼쪽의 다운로드 바를 클릭하면 CRAN(The Comprehensive R Archive Network)으로 이동한다. 자신의 운영체계에 맞는 R의 최신 버전을 다운로드하고 자신의 디바이스에 설치한다. 이 다큐먼트 작성 시점 기준으로 R의 최신 버전은 4.5.1이다.\n\n\n\n\n\n\n노트\n\n\n\nCRAN은 R의 핵심 소프트웨어 저장소(software repository)이다. R 프로그램 자체의 과거와 현재의 버전들 뿐만 아니라 수많은 R 패키지(package)(현재 대략 20,000개)가 모여 있는 곳이다. 1997년 Kurt Hornik와 Friedrich Leisch에 의해 처음 만들어졌으며, 현재에도 Hornik와 많은 자원봉사자들에 의해 운영되고 있다. 자세한 사항은 Wikipedia를 참조할 수 있다.\n\n\n\n1.2 RStudio의 설치\nR의 지배적인 IDE(Integrated Development Environment, 통합개발환경)인 RStudio를 설치한다. 다시 원래의 다운로드 페이지로 돌아와, 오른편의 다운로드 바를 클릭하면 윈도우즈용 RStudio의 파일을 다운로드할 수 있다. 스크롤 다운하면 다른 운영체계를 위한 RStudio를 다운로드할 수 있다. 다운받은 RStudio를 자신의 디바이스에 설치한다. 이 다큐먼트 작성 시점 기준으로 RStudio의 최신 버전은 2025년 5월 1일에 발표된 2025.05.1+513이다.\nRStudio는 R만을 위한 IDE인데, posit은 최근 R과 Python 모두를 사용할 수 있는 범용 IDE인 Positron을 개발하였다. 2025년 7월 3일에 베타 버전을 끝내고 정식 출시했으며, 현재는 2025년 8월 14일에 출시된 2025.08.0-130이 최신 버전이다. Positron은 RStudio와 Python에서 많이 사용되는 VS Code를 결합한 것으로, 향상된 기능과 외견이 기대된다. 2026년부터는 RStudio에서 Positron으로의 이동이 본격화될 것이다. Positron을 살펴보는데 아래의 동영상이 도움이 될 것이다.",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 RStudio"
    ]
  },
  {
    "objectID": "exec_01.html#rstudio-둘러보기",
    "href": "exec_01.html#rstudio-둘러보기",
    "title": "R과 RStudio",
    "section": "\n2 RStudio 둘러보기",
    "text": "2 RStudio 둘러보기\n\n2.1 창(pane, 패인)\nRStudio를 실행하면 아마도 대부분의 경우 그림 2 와 같은 화면을 보게 될 것이다. 크게 세 개의 창으로 구성되어 있음을 알 수 있다.\n\n\n\n\n\n그림 2: 세 개의 창\n\n\n왼편에 가장 크게 나타나 있는 것을 Console 창(pane)이라고 부르고, 우하의 창은 Output 창 혹은 File 창이라고 부른다. 우상에도 또 다른 창이 하나 보이는데 보통 Environment 창이라고 부른다.\n\n\n\n\n\n\n노트\n\n\n\n개별 창은 여러 개의 탭(tab)으로 구성되어 있는데, 탭의 기능이 매우 다양하기 때문에 소속 탭의 모든 기능을 포괄하는 일관성 있는 창 이름을 붙이는 것이 매우 어렵다. 예를 들어 Output 창의 경우 Plots와 Viewer 탭은 결과물을 보여주는 것이라 할 수 있지만 나머지 탭은 꼭 그렇지도 않다.\n\n\n\n2.2 Console 창에서 놀아보기\n여기서는 Console 창을 통해 R의 가장 기본적인 다음의 개념들에 대해 알아보고자 한다. Console 창은 R에서 CLI(command-line interface, 명령줄(어) 인터페이스) 역할을 하는 가장 핵심적인 부분이다. 사용자가 프로그램을 통해 컴퓨터와 상호작용하는 인터페이스이다.\n\n프롬프트(prompt): 명령 프롬프트(command prompt)라고도 불리는 것으로, CLI에서 명령어 대기 상태를 나타내는 일종의 부호이다. R에서는 &gt;를 사용한다.\n할당(assignment): 값을 식별자(identifier)를 가진 객체로 전환하는 과정을 의미한다. 프로그래밍 언어는 할당을 위한 고유한 연산자(operator)를 가지고 있는데, R은 &lt;-을 사용한다. =도 동일한 기능을 하는데, 권장하지는 않는다.\n객체(object): 값을 품고 있는, 식별자를 가진, 메모리 상의 기본 단위\n함수(function): 특정 동작을 수행하는 코드 블록을 의미한다. 인풋을 함수에 적용하면 함수의 고유한 동작을 통해 아웃풋이 산출된다.\n벡터(vector): 숫자의 일차원적 집합으로 보통 개별 행(row) 혹은 개별 열(column)을 의미한다.\n데이터 프레임(data frame): 하나 이상의 벡터를 모아 둔 숫자의 2차원적 집합으로, 다수의 행과 다수의 열로 이루어진 테이블을 의미한다. 이것이 보통 우리가 데이터셋이라고 부르는 것이다.\n\n\n2.2.1 프롬프트, 할당, 객체\n콘솔 창에 R 프롬프트인 &gt;가 나타나 있을 것이다. 아래와 같이 숫자 1을 타이핑하고 실행을 위해 [enter] 키를 누른다.\n\n1\n\n[1] 1\n\n\n간단한 연산을 해본다. 사실 R은 기본적으로 계산기이다.\n\n1 + 2\n\n[1] 3\n\n\n이제 할당 연산자(&lt;-)를 활용하여 할당을 해보자.\n\na &lt;- 1\n\n우상의 Environment 창을 보면 뭔가 생성된 것을 확인할 수 있을 것이다. a라는 객체가 생성되었으며 그것은 1이라는 값을 품고 있다는 의미이다. 이제 a는 알파벳 소문자가 아니라 1이라는 숫자와 필연적으로 결합해 있는 객체이다. 다음을 샐행하면 이러한 사실을 보다 명확히 확인할 수 있다.\n\n\n\n\n\n\n노트\n\n\n\n할당 연산자의 단축키는 Alt + - 이다. 가장 많이 사용하게 될 단축키 중의 하나이다. 이 단축키를 사용하면 좋은 점 중의 하나는 전후에 빈 공간이 자동적으로 생성된다는 점이다. 따라서 객체 이름 다음에 할당 연산자를 사용하기 위해 스페이스바를 사용할 필요가 없다.\n\n\n\na\n\n[1] 1\n\n\n아래와 같이 하면 객체끼리의 연산이 가능하다.\n\nb &lt;- 2\nc &lt;- a + b\nc\n\n[1] 3\n\n\nBase R에는 할당 연사자 외에도 여러 연산자가 존재한다. 이를 정리하면 다음과 같다.\n\n\n\n\n\n\n\n\n범주\n연산자\n설명\n예시\n\n\n\n할당(assignment) 연산자\n\n&lt;- 혹은 -&gt;\n\n데이터를 객체에 할당\na &lt;- 5\n\n\n수리(arithmetic) 연산자\n+\n더하기(addition)\n5 + 5 = 10\n\n\n\n-\n빼기(subtraction)\n5 - 5 = 0\n\n\n\n*\n곱하기(multiplication)\n2 * 8 = 16\n\n\n\n/\n나누기(division)\n100 / 10 = 10\n\n\n\n\n^ 혹은 **\n\n제곱(exponent/power)\n5^2 = 25\n\n\n\n%%\n나머지(modulo)\n100 %% 15 = 10\n\n\n\n%/%\n몫(integer division)\n100 %/% 15 = 6\n\n\n관계(relational) 연산자\nx &lt; y\nx가 y보다 작은 경우\n3 &lt; 4 TRUE\n\n\n\n\nx &gt; y\nx가 y보다 큰 경우\n3 &gt; 4 FALSE\n\n\n\n\nx &lt;= y\nx가 y보다 작거나 같은 경우\n3 &lt;= 4 TRUE\n\n\n\n\nx &gt;= y\nx가 y보다 크거나 같은 경우\n3 &gt;= 4 FALSE\n\n\n\n\nx == y\nx와 y가 같은 경우\n3 == 4 FALSE\n\n\n\n\nx != y\nx와 y가 다른 경우\n3 != 4 TRUE\n\n\n\n논리(logical) 연산자\n!\n논리 부정(negation)\n\n\n\n\n&\n논리곱(logical “and”)\n\n\n\n\n|\n논리합(logical “or”)\n\n\n\n\nxor\n배타적 논리합(logical “exclusive or”)\n\n\n\n기타 연산자\nx %in% y\n원소 포함\n벡터 x의 각 원소가 y 안에 존재하는지 확인\n\n\n\n!(x %in% y)\n원소 비포함\n벡터 x의 각 원소가 y 안에 존재하지 않는지 확인\n\n\n\n2.2.2 함수\nsum() 함수를 사용하여 동일한 연산을 할 수 있다. sum()은 R에 기본적으로 내장되어 있는 Base R 함수 중 하나이다.\n\nsum(a, b)\n\n[1] 3\n\n\n\n\n\n\n\n\n중요\n\n\n\n지금부터 모든 함수명에는 항상 ()를 연결하여 나타낼 것이다. 다른 객체명과의 혼동을 방지하기 위한 것도 있지만, 모든 함수는 () 속에 인풋(이것을 인자(argument)라고 부른다)을 받아들이기 때문이다.\n\n\nR에는 수많은 내장 함수가 있다. 그 중 몇가지만 실행하면 다음과 같다. sqrt()는 제곱근을, abs()는 절대값을, log10()는 밑을 10으로 하는 로그값을 산출해준다.\n\nsqrt(2)\n\n[1] 1.414214\n\nabs(-3)\n\n[1] 3\n\nlog10(100)\n\n[1] 2\n\n\nBase R에서 사용되는 주요 내장 함수를 정리하면 다음과 같다.\n\n\n\n\n\n\n\n범주\n구분\n함수\n\n\n\n논리형 판별 함수\n결측치 여부\n\nis.na(), is.nan(), is.infinite(), is.finite()\n\n\n\n\n유형 확인\n\nis.numeric(), is.integer(), is.character(), is.logical(), is.factor()\n\n\n\n\n구조 확인\n\nis.data.frame(), is.matrix(), is.list(), is.vector()\n\n\n\n\n기타\n\nis.null(), is.atomic(), is.element()\n\n\n\n위치 기반 추출 함수\n첫 번째 원소\nx[1]\n\n\n\n마지막 원소\nx[length(x)]\n\n\n\nn번째 원소\nx[n]\n\n\n\n앞의 몇 개의 원소\nhead()\n\n\n\n뒤의 몇 개의 원소\ntail()\n\n\n수학 함수\n절댓값/부호\n\nabs(), sign()\n\n\n\n\n제곱근/지수\n\nsqrt(), exp()\n\n\n\n\n로그\n\nlog(), log10(), log2()\n\n\n\n\n삼각함수\n\nsin(), cos(), tan(), asin()\n\n\n\n\n반올림\n\nround(), floor(), ceiling(), trunc()\n\n\n\n\n요약\n\nsum(), mean(), median(), var(), sd(), min(), max(), range(), summary()\n\n\n\n벡터 생성 함수\n수열/반복\n\nseq(), rep()\n\n\n\n\n특정 유형\n\nnumeric(), integer(), logical(), character()\n\n\n\n\n난수/표본 생성\n\nsample(), rnorm(), runif(), rbinom()\n\n\n\n집합 연산 함수\n합집합\nunion()\n\n\n\n교집합\nintersect()\n\n\n\n차집합\nsetdiff()\n\n\n\n동일 여부\nsetequal()\n\n\n\n원소 포함 여부\nis.element()\n\n\n변환 함수\n유형 변환\n\nas.numeric(), as.character(), as.factor(), as.data.frame()\n\n\n\n\n재코딩/재배열\n\ncut(), relevel(), reorder()\n\n\n\n\n표준화\nscale()\n\n\n기타 함수\n길이\nlength()\n\n\n\n정렬\n\nsort(), order()\n\n\n\n\n중복 처리\n\nunique(), duplicated()\n\n\n\n\n결측치 처리\nna.omit()\n\n\n\n\n\n\n\n\n\n노트\n\n\n\n최근 tidyverse 패키지의 사용이 활발해 지면서 이러한 Base R 함수의 활용에 약간의 변동이 발생하고 있다. tidyverse 패키지는 타이디버스 디자인 원리에 의거해 새로운 함수를 디자인하여 제공하고 있다. 이러한 타이디버스 함수가 Base R 함수나 기존의 패키지의 함수를 대체해 나가고 있는 실정이다. 여전히 많은 사람이 여기에 열거되어 있는 Base R의 기본 함수를 사용하고, 그러한 문법에 따라 코드를 작성하고 있다. 나는 타이디버스가 R의 미래라고 확신하며 가능한 코드를 타이디버스 함수를 이용해 작성하도록 노력할 것이다. 여기서 Base R의 함수는 기본적으로 벡터에 적용되는 함수이고, 타이디버스 함수는 데이터 프레임에 적용되는 함수라는 점을 명확히 할 필요가 있다. 따라서 타이디버스에서 벡터 연산을 할 때는 위에서 열거한 많은 함수를 그대로 사용한다. 특히, 논리형 판별 함수와 수학 함수는 그대로 사용하고 있다. 집합 연산 함수는 이름은 동일하지만 사실 새롭게 디자인한 함수이다. 타이디버스는 새로운 데이터 프레임 기반 함수를 통해 기존의 벡터 기반 함수가 하는 일을 대체하고자 한다. 그렇지만 모든 코드를 데이터 프레임 함수로만 작성할 수 없고, Base R의 여러 벡터 함수는 여전히 유용하게 사용되고 있다. 타이디버스가 부가적으로 제공하는 벡터 함수에 대해서는 다른 장에서 다루도록 한다.\n\n\n\n2.2.3 벡터와 데이터 프레임\n위에서 살펴본 숫자 하나하나는 큰 의미가 없다. 우리는 보통 숫자의 집합(array), 즉 벡터를 다룬다.\n\na &lt;- c(58, 26, 24)\nb &lt;- c(58L, 26L, 24L)\nc &lt;- c(TRUE, TRUE, FALSE)\nd &lt;- c(\"이상일\", \"김세창\", \"김우형\")\n\na, b, c, d는 모두 벡터이다. 우상의 Environment 창에서도 이러한 사실을 확인할 수 있다. 그런데, 이 세가지 벡터는 데이터의 유형(type)이라는 측면에서 서로 다르다. a는 숫자형(numeric), b는 정수형(integer), c는 논리형(logical), d는 문자형(character)이다. Environment 창을 보면, a에 대해서는 num, b에 대해서는 int, c에 대해서는 logi, d에 대해서는 chr이라는 축약어가 붙어 있음을 알 수 있는데, 이것이 바로 벡터의 유형을 나타내고 있는 것이다. 사실 R에서 다루는 벡터의 유형은 10가지가 넘는다.\n\n\n\n\n\n\n노트\n\n\n\ntidyverse 패키지의 핵심 패키지 중의 하나인 tibble 패키지에서 규정된 데이터 유형에 대해서는 다음의 웹사이트를 참고할 수 있다. https://tibble.tidyverse.org/articles/types.html\n\n\n벡터를 data.frame()이라는 함수를 통해 결합하면 데이터 프레임을 만들 수 있다.\n\ndf &lt;- data.frame(a, b, c, d)\ndf\n\n   a  b     c      d\n1 58 58  TRUE 이상일\n2 26 26  TRUE 김세창\n3 24 24 FALSE 김우형\n\n\n우상의 Environment 창을 보면 뭔가 변화가 있음을 확인할 수 있을 것이다. Data가 생겼고 그 아래에 df가 생성되어 있을 것이다. “3 obs. of 4 variables”라는 말이 굉장히 중요하다. 이것은 df라는 데이터 프레임 객체가 3개의 관측 개체(observations)와 4개의 변수(variables)로 구성되어 있다는 것을 의미한다. 데이터 프레임, 관측 개체, 변수에 대해서는 강의에서 상세하게 다룬다.\nEnvironment 창에서 df를 클릭해보라. 그러면 왼편에 또 하나의 창이 생기면서 마치 엑셀과 같은 형식으로 데이터가 나타날 것이다. View() 함수를 실행해도 동일한 결과를 얻을 수 있다.\n\nView(df)\n\n여기서 중요한 것은 새로 생긴 창이다. 이것을 보통 Editor 창이라고 부른다. 이제부터 Console은 부차적인 목적으로만 사용할 것이고 Editor 창이 주인공이 된다.",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 RStudio"
    ]
  },
  {
    "objectID": "exec_01.html#프로젝트project와-스크립트script",
    "href": "exec_01.html#프로젝트project와-스크립트script",
    "title": "R과 RStudio",
    "section": "\n3 프로젝트(project)와 스크립트(script)",
    "text": "3 프로젝트(project)와 스크립트(script)\n\n3.1 프로젝트 만들기\n\n3.1.1 R 프로젝트의 개념\nRStudio에서 프로젝트란 한 단위의 R 과업을 의미한다. 매우 단순한 과업도 있겠지만, 보통 데이터를 읽고, 정돈하고, 변형하고, 시각화하고, 모델링하는 등의 다양한 활동이 개입된다. 하나의 일관된 목적을 위해 이러한 다양한 일을 한다면, 이것들을 한데 모아 함께 관리하는 것이 좋을 것이다. 프로젝트는 하나의 과업을 위해 당신이 행한 모든 것이 체계적으로 정돈되어 있는 가상의 방이다. 좀 이질적인 과업을 하게 된다면 기존의 프로젝트 속에서 하기 보다는 또 다른 프로젝트를 만들어 그 속에서 하는 것이 효과적일 것이다.\nRStudio의 프로젝트는 실질적으로 하나의 폴더를 의미한다. 하나의 폴더 속에 모든 활동과 그것의 인풋 및 아웃풋이 모두 저장되고, RStudio는 그것을 체계적으로 관리할 수 있게 해주는 툴을 제공한다.\n다음과 같은 관행을 추천한다.\n\n디바이스에 모든 R 프로젝트를 포괄하는 최상위 폴더를 만든다. 걸맞는 폴더명(예: R_Projects)을 부여한다. 이것은 R 외부에서 미리 해둔다. 물론 Output 창의 Files 탭을 이용하면 R 내부에서도 할 수 있다.\n최상위 폴더 아래에 개별 R 프로젝트를 위한 폴더를 만든다. 과업에 걸맞는 폴더명(예: AI_Class_2025)을 부여한다. 이것을 R 외부에서 미리 해둘 수도 있고, R 내부에서 프로젝트를 생성할 때 할 수도 있다. 후자를 추천한다.\n\n3.1.2 R 프로젝트 만들기\n두 가지 방법이 있다.\n\n최상단 메뉴를 이용: File &gt; New Project\n상단 메뉴바 오른쪽 맨끝에 있는 작은 화살표 아이콘: New Project\n\n그림 3 에 나타나 있는 절차를 통해 프로젝트를 생성한다. 각각 다음의 단계를 거친다.\n\n1단계: 과제 폴더(디렉토리)를 미리 만들어 두지 않았다면, New Directory를 선택한다(추천). 그렇지 않았다면 Existing Directory를 선택한다.\n2단계: New Project를 선택한다.\n3단계: ’Directory name:’에 과제를 위한 폴더명을 타이핑한다(예: AI_Class_2025). ’Create project as subdirectory of:’에 최상위 폴더(예: R_Projects)를 선택한다.\n\n\n\n\n\n\n그림 3: R 프로젝트의 생성 절차\n\n\nOutput 창의 Files 탭을 누르면, 다양한 기본 파일들이 해당 폴드에 생성되었음을 확인할 수 있다. 가장 중요한 파일은 .RProj라는 확장자를 가진 파일이다. 나중에 R 외부에서 이 파일을 더블클릭하면 R 프로젝트를 열 수 있다.\n\n\n\n\n\n\n힌트\n\n\n\n\n\nR 외부의 파일 관리 시스템(윈도우즈의 경우 파일 탐색기)를 사용하지 말고, Output 창의 Files 탭을 사용하는 것이 훨씬 유용하다. 파일 탐색기에서 제공하는 거의 대부분의 기능을 제공한다.\n\n\n\n\n3.1.3 옵션의 변경\nRStudio의 기본 세팅값을 바꿀 수 있는 다양한 옵션이 존재한다. Tools &gt; Global Options를 선택하면 그림 4 과 같은 화면을 볼 수 있을 것이다. 다음의 두 가지를 해보라.\n\n자신이 좀 숙달된 R 사용자가 되었다고 판단되는 즈음에, 가운데 Workspace 부분을 그림과 동일하게 변경해보라. 디폴트는 체크가 되어 있는 것인데, 프로젝트를 다시 열었을 때 그 전에 만들어 둔 데이터나 객체가 모두 그대로 남아있게 한다. 초보자에게는 이것이 좋을 것이다. 그러나 새로운 세션을 시작할 때 마다 그 전의 흔적을 밀어버리고, 다시 모든 코드를 실행하여 결과를 새로이 얻는 것이, 프로그래밍 측면에서는 ‘완전한’ 일이다.\n왼쪽에서 Apearance를 선택한 후, ’Editor font size:’나 ’Editor theme’을 변경하여 자신의 선호를 반영하라.\n\n\n\n\n\n\n그림 4: 옵션의 변경\n\n\n\n3.2 스크립트 만들기\n\n3.2.1 Console에서 Script Editor로\nConsole은 명령어를 입력하고 그 결과를 볼 수 있는 곳이다. 이것은 Base R의 기본 기능을 RStudio가 충실하게 구현한 것이다. 그런데 제법 복잡한 R 프로젝트를 수행하고자 할 때 Console을 이용하는 방식은 제한점이 많다.\n\n다양하고 복잡한 R 명령어를 실행하고 그 결과를 보기에는 공간이 협소하다.\nConsole에서 행한 것은 저장되지 않는다. 보다 정확하게 말하면, 산출물은 저장될 수 있지만, 그러한 산출물을 얻는데 동원된 일련의 코드는 저장되지 않는다. RStudio를 나갔다가 다시 들어오면 객체, 플롯 등의 산출물은 그대로 남아 있지만 어떤 과정을 거쳐 그러한 결과물을 산출했는지에 대한 것을 남아 있지 않다. 이런 점은 상당한 기간이 지난 후에는 더 큰 문제로 다가온다.\n\n이러한 의미에서 R을 가지고 행한 것을 모두 저장하는, 일종의 연구노트와 같은 것이 필요하다. 이것을 R 스크립트(script)라고 부르는데, 좌상의 Editor 창에서 스크립트를 다루고, .R이라는 확장자를 가진 파일로 저장한다.\n\n3.2.2 스크립트 파일 생성하고 저장하기\n스크립트 파일을 생성하는 세 가지 정도의 방법이 있다.\n\nFile &gt; New File &gt; R Script 선택\nFile 메뉴 바로 아래의 New File 아이콘을 누른 후 R Script 선택\n단축키(Ctrl + Shift + N) 실행\n\n이렇게 하면 그림 5 과 같이 좌상에 Editor 창이 생성된다. 그 안에서 그림에서 보는 바와 같이 코드를 작성하게 된다.\n\n\n\n\n\n그림 5: 네 개의 창(https://docs.posit.co/ide/user/ide/guide/ui/ui-panes.html)\n\n\n스크립트 파일에 이름을 부여하고 저장한다.\n\nFile &gt; Save 선택\nSave current document 아이콘 클릭\n단축키(Ctrl + S) 실행\n\n3.2.3 스크립트 파일에서의 실행\n앞에서 Console에서 했던 모든 일을 동일하게 할 수 있다. 단 실행 방식이 조금 다르다. 앞에서 생성한 df 데이터 프레임의 a 벡터(변수)의 평균값을 구하기 위해 이전과 동일하게 입력한다. 그런데 프롬프트가 없고, [enter]를 눌러도 실행되지 않는다.\n\nmean(df$a)\n\n우선 실행할 코드 라인 혹은 코드의 영역을 지정해야 한다. 두 가지 방법이 있다.\n\n실행할 코드 라인 혹은 코드 블록에 커서를 위치시킨다.\n왼쪽 마우스 버튼을 누른 상태에서 커서를 이동시켜 실행할 영역 전체를 선택한다.\n\n영역이 지정되면 실행하면 되는데, 여기에도 두 가지 방법이 있다.\n\n단축키(Ctrl + Enter) 실행\nEditor 창의 우상에 있는 ‘Run the current line or selection’ 아이콘을 클릭(그림 6 참조)\n\n\n\n\n\n\n그림 6: 스크립트 파일에서의 실행(https://docs.posit.co/ide/user/ide/guide/code/execution.html)\n\n\n이전의 실행을 반복하고자 할 때는 다음과 같이 하면 된다.\n\n단축키(Ctrl + Alt +P) 실행\nEditor 창의 우상에 있는 ‘Re-run the previous code region’ 아이콘을 클릭(그림 6 참조)\n\n스크립트 파일 내 모든 코드를 실행하고자 할 때는 다음과 같이 하면 된다.\n\n단축키(Crtl + Shift + S)\n\n3.2.4 코멘트\n코드에 대한 코멘트를 스크립트 파일 곳곳에 남겨두면 나중에 코드 작성의 의도를 보다 쉽게 파악할 수 있다. 이와 관련하여 두 가지 사항을 알아두면 유용하다.\n첫째, # 표시 뒤의 것은 R이 실행하지 않기 때문에 중간중간에 # 표시를 하고 그 뒤에 자신의 코멘트를 남겨두는 것을 권한다.\n\nmean(df$a) # 세 사람의 나이 평균을 구함. 첫 번째 사람 나이가 엄청나게 많음.\n\n둘째, 코드가 길어지면, 그것을 몇 개의 섹션으로 나누고 그것에 코멘트를 달아 줄 수 있다. 단축키(Crtl + Shift + R)를 실행하여 섹션 라벨(Section label)을 달 수 있고, Editor 창의 왼쪽 하단에 있는 작은 아이콘을 이용해 섹션을 빠르게 이동할 수 있다.\n\n\n\n\n\n그림 7: 섹션 코멘트 달기(https://r4ds.hadley.nz/workflow-style.html#sectioning-comments)",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 RStudio"
    ]
  },
  {
    "objectID": "exec_10.html",
    "href": "exec_10.html",
    "title": "소통하기: 지리공간적 시각화",
    "section": "",
    "text": "여기서는 지리공간적 시각화, 특히 지도 제작에 집중한다. “지도는 텍스트, 테이블, 챠트와 같은 것들 보다 훨씬 더 효과적으로 정보를 전달할 수 있다.”(Dougherty 와/과 Ilyankou 2021)\n우선 tidyverse 패키지를 불러온다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: 지리공간적 시각화"
    ]
  },
  {
    "objectID": "exec_10.html#개요",
    "href": "exec_10.html#개요",
    "title": "소통하기: 지리공간적 시각화",
    "section": "",
    "text": "여기서는 지리공간적 시각화, 특히 지도 제작에 집중한다. “지도는 텍스트, 테이블, 챠트와 같은 것들 보다 훨씬 더 효과적으로 정보를 전달할 수 있다.”(Dougherty 와/과 Ilyankou 2021)\n우선 tidyverse 패키지를 불러온다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: 지리공간적 시각화"
    ]
  },
  {
    "objectID": "exec_10.html#지리공간적-데이터와-지도",
    "href": "exec_10.html#지리공간적-데이터와-지도",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n1 지리공간적 데이터와 지도",
    "text": "1 지리공간적 데이터와 지도\n\n1.1 벡터와 래스터 데이터\n지도는 간단히 말해 지리공간적(geospatial) 데이터를 그래픽 형태로 나타낸 것이다. 따라서 지리공간적 데이터를 이해하는 것이 지도 제작의 시발점이 되어야 한다. 지리공간적 데이터는 GIS적 관점에서 벡터(vector) 데이터와 래스터(raster) 데이터로 나뉜다. 벡터 데이터는 지리공간적 사상의 기하학적 형태(형상 데이터)와 그것의 다양한 특성(속성 데이터)을 담고 있는 데이터이다.\n벡터 데이터는 지리공간적 사상을 포인트, 라인, 폴리곤 피처로 구분하고, 개별 피처를 형태와 위치를 개별 피처를 구성하고 있는 버택스의 좌표값을 저장함으로써 구현하는데, 이러한 정보를 담고 있는 것을 형상 데이터라고 한다. 예를 들어 우리나라 17개 시도에 대한 디지털 행정구역도가 여기에 해당한다. 이에 반해 속성 데이터는 포인트, 라인, 폴리곤 등으로 재현된 개별 피처의 다양한 특성을 가지고 있는 것으로 보통 테이블 데이터라고 한다. 예를 들어, 우리나라 17개 시도의 인구수, 인구성장률, 순이동률과 같은 것이다. 형상 데이터가 지리공간적 데이터의 특수성을 더 잘 반영하기 때문에 보통 형상 데이터를 공간 데이터라고도 하면, 벡터 데이터에서는 이 두 종류의 데이터가 기본적으로 독립적이며 보통은 느슨한 형태로 결합되어 있다.\n이에 반해 래스터 데이터는 세상을 동일한 크기의 수 많은 그리드 셀(grid cell)로 구성되어 있다고 보며, 개별 그리드 셀에 속성이 저장되어 있는 데이터를 의미한다. 가장 쉬운 예가 인공위성 영상이다. 인공위성 영상의 특정한 공간해상도를 가진 픽셀로 나뉘어져 있고, 개별 픽셀에 특정한 값(특정한 밴드의 반사값)이 들어가 있다. 따라서 래스터 데이터는 벡터 데이터처럼 형상 데이터와 속성 데이터가 분리되어 있는 것이 아니라 일체형이다. 특수한 경우가 아니라면 하나의 래스터 파일에는 하나의 속성만이 들어가 있다. 이에 반해 벡터 데이터의 속성 파일에는 수많은 변수가 포함될 수 있다.\n지도 제작의 원칙은 동일하지만, 지도로 나타낼 데이터가 벡터 데이터인지 래스터 데이터인지에 혹은 둘 다인지에 따라 지도화의 세부 절차는 달라질 수 있다. 여기서는 벡터 데이터에 기반한 지도 제작에 집중하고자 한다. 속성 데이터는 기본적으로 R의 데이터 프레임과 동일한 개념이므로, 데이터사이언스의 기본 과정을 통해 불러오고, 정돈하고, 변형할 수 있다. 따라서 보다 중요한 것은 형상 데이터를 다루는 것이다.\n\n1.2 셰이프 파일\n벡터 데이터 포맷, 보다 정확하게는 형상 데이터의 포맷으로 가장 널리 사용되고 있는 것이 셰이프 파일(shape file)이다. 셰이프 파일(확장자가 .shp인 파일)은 전세계에서 가장 큰 GIS 회사인 ESRI가 오래전에 개발한 벡터 데이터 포맷으로, 현재 표준 포맷의 역할을 하고 있다. 그런데 셰이프 파일은 동일한 이름을 공유하지만 확장자가 서로 다른 몇 개의 파일의 묶음을 지칭한다는 점을 이해할 필요가 있다. 반드시 다음의 네 파일을 함께 가지고 있어야 한다.\n\n*.shp: 버텍스의 좌표값이 포함된 핵심 파일\n*.dbf: 기본 속성 파일\n*.shx: 공간적 인덱싱 파일\n*.prj: 투영 정보 파일\n\n마지막의 *.prj 파일은 없어도 지도로 나타날 수는 있다. 그러나 다른 셰이프 파일과 함께 지도로 나타내거나 축척막대와 같은 지도 요소를 적절하게 나타내기 위해서는 좌표참조계(CRS) 정보가 포함된 *.prj 파일은 가질 필요가 있다.\n\n1.3 sf 패키지\nR에서 형상 데이터를 다루는데 있어 거의 표준처럼 사용되고 있는 것이 sf 패키지이다. 기본적으로는 셰이프 파일을 불러오기 위한 st_read() 함수를 주로 사용하게 되겠지만, sf 패키지는 벡터-기반 GIS 오퍼레이션을 위한 폭넓은 함수를 제공한다. 중요한 것을 정리하면 다음과 같다.\n\n\n\n\n\n\n\n구분\n함수\n설명\n\n\n\n읽고 쓰기\n\nst_read()\nread_sf()\n\n셰이프 파일 읽어 들이기\n\n\n\nst_write()\n셰이프 파일 저장\n\n\n투영 관련\nst_crs()\nCRS 정보 확인\n\n\n\nst_transform()\nCRS 바꾸기\n\n\n기하 측정\nst_area()\n면적 계산\n\n\n\nst_length()\n길이 계산\n\n\n\nst_perimeter()\n둘레 계산\n\n\n\nst_distance()\n거리 계산\n\n\n기하 변형\nst_centroid()\n센트로이드 생성\n\n\n\nst_buffer()\n버퍼 생성\n\n\n\nst_boundary()\n가장자리 추출\n\n\n\nst_simplify()\n선 피처 단순화 실행\n\n\n기하 생성\nst_point()\n포인트 피처 생성\n\n\n\nst_vironoi()\n보로노이 폴리곤 생성\n\n\n\nst_convex_hull()\n컨벡스 헐 생성\n\n\n\nst_make_grid()\n규칙 그리드 생성\n\n\n기하 검토\nst_is_valid()\n지오메트리가 밸리드한지 여부 검토\n\n\n\nst_make_valid()\n지오메트리를 밸리드하게 만들기\n\n\n기하 중첩\nst_intersection()\n기하 교집합 중첩\n\n\n\nst_union()\n기하 합집합 중첩\n\n\n\nst_crop()\n기하 크롭 중첩\n\n\n기타\nst_coordinates()\n버택스 좌표값 반환\n\n\n\nst_cast()\n다른 피처 유형으로 변환\n\n\n\nst_as_sf()\nsf 객체로 변환\n\n\n\nst_graticule()\n그래티큘 생성\n\n\n\nst_join()\n공간적 조인 실행\n\n\n\n래스터 데이터를 다루는데는 terra 패키지가 가장 널리 사용되고 있으며, stars패키지가 최근 많은 주목을 받고 있다. stars 패키지와 sf 패키지는 모두 에트저르 페베스마(Edzer Pebesma)가 만들었다. 두 패키지에 대한 설명은 페베스마와 로저 비번드(Roger Bivand)가 함께 쓴 ’R을 활용한 공간데이터사이언스(Spatial Data Science With Applications in R)’에 잘 나타나 있다(Pebesma 와/과 Bivand (2023))",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: 지리공간적 시각화"
    ]
  },
  {
    "objectID": "exec_10.html#정적-지도-제작",
    "href": "exec_10.html#정적-지도-제작",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n2 정적 지도 제작",
    "text": "2 정적 지도 제작\n\n2.1 세계 지도\nggplot2 패키지를 이용하여 정적 지도를 그려본다. ggplot2패키지로 지도를 그린다는 것은 ’지도도 그래프다.’라는 접근법에 기반하고 있다. ggplot2의 문법을 지도 제작으로 확장할 수 있고, 막강한 생태계를 고려할 때 충분히 이점이 있는 접근법이다.\n데이터는 지난 실습에서 사용한 WPP 2024(World Population Prospects 2024)이다. 2024년 전세계 국가별 TFR(Total Fertility Rate, 합계출산율) 지도를 그려본다.\n벡터 데이터를 활용한 지도는 형상 데이터와 속성 데이터를 결합해야만 제작할 수 있다. 여기서 형상 데이터는 전세계 국가 경계 데이터이고, 속성 데이터는 TFR이 포함된 WPP 2024 데이터이다. 형상 데이터는 spData 패키지에 들어 있는 world 객체를 사용한다. 벡터 형식의 데이터는 sf 패키지의 st_as_sf() 함수를 통해 sf 객체로 변환하는 것이 좋다.\n\nlibrary(spData)\nlibrary(sf)\ndata(world)\nworld &lt;- st_as_sf(world)\n\nWPP 2024 데이터를 불러와 2025년만 골라낸다.\n\nwpp_2024 &lt;- read_rds(\"wpp_2024.rds\")\nmy_wpp &lt;- wpp_2024 |&gt; \n  filter(year == 2025)\n\n두 데이터를 left_join() 함수를 이용하여 결합한다. 벡터 데이터의 경우는 늘 반드시 형상 데이터를 중심에 두고 left_join() 함수를 통해 속성 데이터를 불러와 합체해야 한다.\n\nworld_data &lt;- world |&gt;\n  left_join(my_wpp, join_by(iso_a2 == ISO2))\n\n로빈슨 도법(Robinson projection)의 지도를 제작한다. ggplot2 패키지로 지도를 그리는 가장 좋은 방법은 기하객체 함수인 geom_sf()와 좌표 변환 함수인 coord_sf()를 결합하는 것이다. scale_x_continuous()와 scale_y_continuous()의 내용은 그래티큘(경위선망)을 원하는 방식대로 지도에 포함시키기 위한 것이다. 그래프를 world_map이라는 이름의 객체로 저장하는 것은 뒤에서 이 지도를 사용하기 때문이다.\n\nworld_map &lt;- ggplot() +\n  geom_sf(data = world_data, aes(fill = TFR, text = name_long)) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_fill_viridis_c() +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.5, seq(-60, 60, 30), 89.5)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\nworld_map\n\n\n\n\n\n\n\n\n2.2 우리나라 지도\n우리나라 지도도 그려본다. ’Lab07: 데이터 수집하기’에서 KOSIS의 API를 통해 수집, 정리한 시군구 단위 지역소멸위험지수를 지도화한다. 우선 우리나라 시군구 행정 경계에 대한 도형(형상, 기하) 데이터가 필요하다. GADM(Database of Global Administrative Areas)는 전 세계 국가별, 행정구역 수준별, 고해상도 디지털 경계 파일을 제공한다. 직접 웹사이트를 방문해 파일을 다운로드할 수도 있지만, 여기서는 geodata 패키지의 도움을 받는다. geodata 패키지는 정말 다양한 종류의 공간 데이터를 쉽게 다운로드할 수 있게 도와준다. 1레벨인 시도 단위와 2레벨인 시군구 단위를 다운받는다. path 아규먼트가 반드시 필요한데, 프로젝트 파일의 폴더도 좋고, 앞으로 geodata 패키지를 통해 다운받을 데이터를 모아둘 곳을 따로 정해두어도 좋다. 그렇지만 할당 연산자를 통해 이름을 부여하면 따로 다운로드된 파일을 다시 부르는 수고는 하지 않아도 된다.\n\nlibrary(geodata)\nlibrary(tmap)\n\nkorea_sd &lt;- gadm(country = \"South Korea\", level = 1, path = \"D:/My R/Geodata/\")\nkorea_sd &lt;- korea_sd |&gt; \n  st_as_sf()\nkorea_sgg &lt;- gadm(country = \"South Korea\", level = 2, path = \"D:/My R/Geodata/\")\nkorea_sgg &lt;- korea_sgg |&gt; \n  st_as_sf()\n\n그런데 파일을 열어보고서 경악한다. 행정구역 코드가 없다. 그래서 이 방법은 포기한다.\n행정구역 파일은 통계청의 통계지리정보서비스에서 구할 수 있다. 다운받는 방법을 익히면 좋겠지만, 시간 절약을 위해 다운받아 정리한 파일을 그냥 제공한다. 프로젝트 폴더에 파일을 저장한 후, 아래의 코드를 통해 불러온다.\n\nsido_shp &lt;- st_read(\"sido.shp\", options = \"ENCODING=CP949\")\nsigungu_shp &lt;- read_sf(\"sigungu.shp\", options = \"ENCODING=CP949\")\n\n두 파일에 대해 서로 다른 함수를 적용한 것을 알 수 있다. st_read() 함수는 가장 보편적으로 사용되는 것으로 불러올 때마다 파일에 대한 정보(지오메트리 유형, 바운딩 박스, CRS 등)가 자동으로 디스플레이된다. 이러한 정보는 항상 유익한 것이지만 보이지 않게 하고 싶을 수도 있다. 이 때 read_sf() 함수를 사용할 수 있다.\n불러들인 파일을 바탕으로 시군구 경계를 그려본다. 지도 제작 전문 패키지인 tmap의 qtm() 함수를 이용하여 시군구 경계에 대한 지도를 빠르게 그려본다. tmap패키지로 지도를 그린다는 것은 ’지도는 지도다.’라는 접근법에 기반하고 있다. tmap의 문법을 새로 배워야 한다는 단점이 있긴 하지만, 지도는 그래프로 환원될 수 없는 고유한 특성이 있고, tmap패키지는 이러한 지도의 고유한 특성을 잘 반영하고 있다. 좀 더 복잡한 tmap의 문법을 사용한 지도 제작은 맨 뒤에서 다루기로 한다.\n\nlibrary(tmap)\nqtm(sigungu_shp)\n\n\n\n\n\n\n\n지역소멸위험지수 데이터를 불러온다. 아래 코드는 지난번 실습 때 rds 파일 포맷으로 저장해 둔 것을 가정한 것이다. 실습의 편의를 위해 파일을 제공하니 프로젝트 폴더에 저장한 후, 아래의 코드를 통해 불러온다.\n\ndata_sigungu &lt;- read_rds(\"data_sigungu.rds\")\n\n도형 데이터(korea_sgg)와 속성 데이터(data_sigungu)를 공통 키(key)를 활용하여 결합한다.\n\nsigungu_data &lt;- sigungu_shp |&gt; \n  left_join(\n    data_sigungu, join_by(SGG1_CD == C1)\n  )\n\n이제 ggplot2 패키지를 이용하여 지도를 제작한다. ’Lab07: 데이터 수집하기’에서 인구소멸위험지수의 시도별 그래프를 제작한 것과 비교해 보라. 그 유사함에 깜짝 놀랄 수도 있다. ggplot2에서는 그래프와 지도의 구분이 없다. 이것은 ggplot2의 장점이자 단점이다.\n\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index_class = case_when(\n      index &lt; 0.2 ~ \"1\",\n      index &gt;= 0.2 & index &lt; 0.5 ~ \"2\",\n      index &gt;= 0.5 & index &lt; 1.0 ~ \"3\",\n      index &gt;= 1.0 & index &lt; 1.5 ~ \"4\",\n      index &gt;= 1.5 ~ \"5\"\n    ),\n    index_class = fct(index_class, levels = as.character(1:5))\n  )\n\nclass_color &lt;- c(\"1\" = \"#d7191c\", \"2\" = \"#fdae61\",\n                 \"3\" = \"#ffffbf\", \"4\" = \"#a6d96a\", \n                 \"5\" = \"#1a9641\")\nggplot() +\n  geom_sf(data = sigungu_data, aes(fill = index_class), show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(name = \"Classes\", \n                    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \n                               \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n                    values = class_color, drop = FALSE)",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: 지리공간적 시각화"
    ]
  },
  {
    "objectID": "exec_10.html#인터랙티브-지도-제작",
    "href": "exec_10.html#인터랙티브-지도-제작",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n3 인터랙티브 지도 제작",
    "text": "3 인터랙티브 지도 제작\n위에서 사용한 plotly 패키지의 ggplotly() 함수를 활용하면 반응형 지도를 생성할 수 있다. 앞의 코드 둘째 줄에 aes()에 text = name_long이 설정되어 있는데, 마우스로 국가를 가리킬 때 이름이 나타날 수 있게 조치한 것이다.\n\nlibrary(plotly)\nggplotly(world_map)\n\n\n\n\n\n지도 위에서 plotly 가 제공하는 다양한 기능을 적용해 볼 필요가 있다. 인터랙티브 그래프에 비해 인터랙티브 지도의 유용성이 더 높아 보인다.\n우리나라 지도는 다른 방식으로 반응형으로 만들어 본다. 여기서는 ggiraph 패키지를 사용한다. 처음 사용하는 경우라면 먼저 패키지를 인스톨해야 한다. 코드의 전반부는 커서를 특정 시군구 위에 올렸을 때 나타나는 정보를 좀 더 다양하게 하려는 조치이다. 중간의 코드가 핵심인데, 찬찬히 살펴보면 그렇게 복잡하지 않다. 마지막은 완전히 지엽적인 것인데, 커서를 특정 시군구 위에 올렸을 때 색이 회색으로 변하게 하기 위한 것이다.\n\nlibrary(ggiraph)\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = format(index, digits = 4, nsmall = 4),\n    my_tooltip = str_c(\"Name: \", SGG1_FNM, \"\\n Index: \", index)\n  )\ngg &lt;- ggplot() +\n  geom_sf_interactive(\n    data = sigungu_data, \n    aes(\n      fill = index_class, \n      tooltip = my_tooltip, \n      data_id = SGG1_FNM\n      ), \n    show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(\n    name = \"Classes\", \n    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n    values = class_color, drop = FALSE) \ngirafe(ggobj = gg) |&gt; \n  girafe_options(\n    opts_hover(css = \"fill: gray\")\n  )\n\n\n\n\n\n그러나 반응형 지도 제작에 가장 널리 쓰이는 것은 leaflet이다. leaflet은 웹 상의 반응형 지도 제작에 특화된 JavaScript 라이브러리이다. 이 라이브러리를 R에서 쓸 수 있게 도와주는 래퍼 패키지가 leaflet 패키지이다. 패키지 홈페이지가 매우 상세하게 잘 되어 있다. 숙독하기를 권한다.\n\nlibrary(leaflet)\n\n매우 단순한 인터랙티브 지도를 만들어 본다. 자신이 원하는 경위도값과 설명문으로 수정하면 된다.\n\nleaflet() |&gt; \n  addTiles() |&gt; \n  addPopups(126.955184, 37.460422, \"Sang-Il's Office\",\n            options = popupOptions(closeButton = FALSE))\n\n\n\n\n\n\n위에서 작성했던 TFR 세계지도를 leaflet 패키지의 다양한 함수와 아규먼트를 활용하여 인터랙티브 지도를 제작해 본다.\n\nworld_data &lt;- world_data |&gt; filter(!is.na(TFR))\n\nbins &lt;- c(0, 1.5, 2.1, 3, 4, 5, Inf)\npal &lt;- colorBin(\"YlOrRd\", domain = world_data$TFR, bins = bins)\nlabels &lt;- sprintf(\"&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g\",\n  world_data$name_long, world_data$TFR) |&gt; lapply(htmltools::HTML)\n\nleaflet(world_data) |&gt; \n  addProviderTiles(providers$Esri.WorldTopoMap) |&gt; \n  addPolygons(\n    fillColor = ~pal(TFR),\n    weight =  2, \n    opacity = 1,\n    color = \"white\",\n    dashArray = \"3\",\n    fillOpacity = 0.6,\n    highlightOptions = highlightOptions(\n      weight = 5,\n      color = \"#666\",\n      dashArray = \"\",\n      fillOpacity = 0.6,\n      bringToFront = TRUE),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n      textsize = \"15px\",\n      direction = \"auto\")\n  ) |&gt; \n  addLegend(\n    pal = pal, values = ~TFR, opacity = 0.6, title = NULL,\n    position = \"bottomright\"\n  )\n\n\n\n\n\n\n우리나라 시군구 단위의 인구소멸위험지수에 대한 지도를 반응형으로 만들어 본다. 여기서는 tmap을 활용한다. 해당 시군구 위에 클릭하면 지역소멸위험지수가 나타난다.\n\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = as.numeric(index)\n  )\ntmap_mode(mode = \"view\")\nmy_tmap &lt;- tm_shape(sigungu_data) + \n  tm_polygons(\n    col = \"index\",\n    palette = class_color, \n    breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n    labels = c(\"&lt; 0.2\", \"0.2~0.5\", \"0.5~1.0\", \"1.0~1.5\", \"&gt;= 1.5\"),\n    title = \"Classes\", \n    popup.vars=c(\"지역소멸위험지수: \" = \"index\"), \n    popup.format = list(index = list(digits = 3)), \n    id = \"SGG1_FNM\", \n    alpha = 0.6, \n    border.alpha = 0.5\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 2)\nmy_tmap\n\n\n\n\n\ntmap_save(my_tmap, \"지방소멸위험지수.html\")",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: 지리공간적 시각화"
    ]
  },
  {
    "objectID": "lab_09_2025.html",
    "href": "lab_09_2025.html",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "",
    "text": "여기서는 대시보드의 구성 요소로 활용할 수 있는 다양한 시각화 기법을 익힌다. 우리는 지금까지 도표(차트, 플롯, 그래프, 테이블)를 중심으로 데이터 시각화 기법을 다루었다. 특히 ggplot2 패키지는 이러한 과정에서 핵심적인 역할을 했다. 그런데 지금까지의 모든 도표는 정적(static) 이라는 특징이 있다. 많은 경우 도표는 정적으로 표현될 수 밖에 없으며, 또한 많은 경우 도표는 정적인 것으로 충분하며, 어떤 경우에는 동적인 것보다 더 낳다.\n소통을 위한 시각화 재료로서 정적인 도표가 가지는 절대적인 중요성에도 불구하고, 상호작용성(interactivity)과 생동감(animatedness)이 부가된 도표는 어떤 상항에서는 소통의 본질적 가치를 고양하는데 많은 도움을 줄 수 있다.\n먼저, Quarto Document를 만들고 YAML 해더를 작성한다.\n---\ntitle: \"Interactive Visualizetion\"\nauthor: Your_Name\nformat: \n  dashboard:\n    scrolling: true\ntheme: cosmo\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\ngapminder 데이터를 실습의 여러 곳에서 활용할 것이다. 우선 tidyverse와 gapminder패키지를 불러온다.\n\nlibrary(tidyverse)\nlibrary(gapminder)",
    "crumbs": [
      "R 실습: 2025/2",
      "소통하기: 인터랙티브 시각화"
    ]
  },
  {
    "objectID": "lab_09_2025.html#개요",
    "href": "lab_09_2025.html#개요",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "",
    "text": "여기서는 대시보드의 구성 요소로 활용할 수 있는 다양한 시각화 기법을 익힌다. 우리는 지금까지 도표(차트, 플롯, 그래프, 테이블)를 중심으로 데이터 시각화 기법을 다루었다. 특히 ggplot2 패키지는 이러한 과정에서 핵심적인 역할을 했다. 그런데 지금까지의 모든 도표는 정적(static) 이라는 특징이 있다. 많은 경우 도표는 정적으로 표현될 수 밖에 없으며, 또한 많은 경우 도표는 정적인 것으로 충분하며, 어떤 경우에는 동적인 것보다 더 낳다.\n소통을 위한 시각화 재료로서 정적인 도표가 가지는 절대적인 중요성에도 불구하고, 상호작용성(interactivity)과 생동감(animatedness)이 부가된 도표는 어떤 상항에서는 소통의 본질적 가치를 고양하는데 많은 도움을 줄 수 있다.\n먼저, Quarto Document를 만들고 YAML 해더를 작성한다.\n---\ntitle: \"Interactive Visualizetion\"\nauthor: Your_Name\nformat: \n  dashboard:\n    scrolling: true\ntheme: cosmo\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\ngapminder 데이터를 실습의 여러 곳에서 활용할 것이다. 우선 tidyverse와 gapminder패키지를 불러온다.\n\nlibrary(tidyverse)\nlibrary(gapminder)",
    "crumbs": [
      "R 실습: 2025/2",
      "소통하기: 인터랙티브 시각화"
    ]
  },
  {
    "objectID": "lab_09_2025.html#임베딩",
    "href": "lab_09_2025.html#임베딩",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n1 임베딩",
    "text": "1 임베딩\n동적, 반응형 시각화를 직접 제작하는 과정을 배우기 전에 대시보드에 동적, 반응형 시각화를 실현하는 가장 쉬운 방법은 동적, 반응형 시각화가 구현되어 있는 웹사이트를 대시보드에 불러오는 것일 것이다. 이것을 임베딩(embedding)이라고 하는데, HTML의 iframe 태그를 사용한다.\n통계청의 통계놀이터는 다양한 주제에 대해 동적, 반응형 시각화를 제작하여 이용자들에게 제공하고 있다. 해당 홈페이지의 [비주얼 통계]에서 “우리나라 출생아 수와 합계 출산율의 변화”를 검색하면 동적, 반응형 시각화가 구현된 웹페이지를 볼 수 있다. [공유]를 눌러 URL을 복사하고, 아래와 같은 코드를 Quarto 문서에 삽입하면 해당 웹페이지를 임베딩할 수 있다. src=\"\" 부분에 복사한 URL를 붙여 넣는다는 것을 쉽게 알 수 있을 것이다. 여기에 다른 URL을 교체해 넣으면 대부분의 웹사이트를 임베딩할 수 있는데, 임베딩이 불가능하게 막아 뒀거나 광고가 많이 붙어 있는 웹사이트는 잘 안된다. style=\"\" 부분을 적절히 수정하면 임베딩된 웹사이트의 외견을 바꿔볼 수 있다.\n&lt;iframe src=\"https://kosis.kr/edu/share.do?shareID=S0500_16\" \nloading=\"lazy\" style=\"width: 100%; height: 600px; border: \n0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;\n\n\n\n\nOur World in Data는 아름다운 인터랙티브 시각화 자료를 제공하는 것으로 유명하다. 심지어 [공유] 버턴을 눌렀을 때 &lt;/&gt; Embed 라는 옵션이 나타나는 데, 이것을 누르면 위와 같은 iframe 태그 내용이 그대로 나타나기 때문에 복사하여 붙이기만 하면 된다. Chart 탭 뿐만 아니라 Table 탭과 Map 탭도 있으니 눌러서 내용을 확인할 수 있다. 아마도 ECharts 자바스크립트 라이브러리를 사용한 것으로 보인다.\n&lt;iframe src=\"https://ourworldindata.org/grapher/child-mortality?time=earliest..latest&tab=chart\" \nloading=\"lazy\" style=\"width: 100%; height: 600px; border: 0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;\n\n\n\n\n\n\n그림 1: 임베딩 사례: Our World in Data\n\n\nOur World in Data에서 제공하는 다양한 인터랙티브 시각화 자료를 임베딩하는 절차를 요약하면 다음과 같다.\n\nOur World in Data에 접속한다.\n첫 화면의 하단에 있는 ’Data explorers’의 네 개 박스로 이동한다. 인구 관련 데이터에 관심이 있다면 ’Population & Demography’를 선택한다.\n’Population & Demography Data Explorer’에서 제공된 다양한 옵션을 이용해 원하는 인터랙티브 시각화 자료를 완성한다.\n‘Share’를 클릭하고’&lt;/&gt; Embed’를 선택한 후 URL을 복사한다. 흥미로운 점은 위에서 어떤 옵션을 어떻게 설정했느냐에 따라 URL이 달라진다는 사실이다.\niframe 태그의 “src=”에 붙여 넣어 임베딩을 완수한다.",
    "crumbs": [
      "R 실습: 2025/2",
      "소통하기: 인터랙티브 시각화"
    ]
  },
  {
    "objectID": "lab_09_2025.html#테이블",
    "href": "lab_09_2025.html#테이블",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n2 테이블",
    "text": "2 테이블\n우리는 지금까지 테이블(table)의 중요성에 대해 거의 다루지 않았다. 그러나 상호작용형 테이블 혹은 대화형 테이블이 되었을 때, 많은 경우, 테이블은 가장 효과적인 정보 전달 도구가 된다. 특히, 데이터 변형하기를 통해 새로운 요약 테이블을 생성하고, 그것을 대화형으로 제시하는 것은 매우 중요한 데이터사이언스의 과정이다. 여기서는 DT 패키지를 활용하여 간단한 인터랙티브 테이블을 만들어 본다. 웹에서 인터렉티브 테이블을 생성할 수 있게 해주는 다양한 종류의 JavaScript 라이브러리가 존재한다. 예를 들어 DataTables, FlexTable, React Table 등이 있는데, DT 패키지는 DataTables를 쓸 수 있게 해주는 래퍼 패키지이다.\n\nlibrary(DT)\n\n그리고 gapminder 데이터를 datatable() 함수를 통해 불러온다. R 코드를 실행하려면 반드시 코드 청크 안에 코드를 넣어야 한다. 청크 안의 코드는 R이 인식하여 실행하고, 결과를 문서에 출력한다.\n\ndatatable(gapminder)\n\n\n\n\n\n\n결과를 좀 더 크게 보기 위해, ‘Render’ 버튼 바로 오른편에 있는 아이콘을 클릭해 ’Chunk Output in Console’를 선택할 수 있다. 결과 테이블을 이리저리 살펴본다. 언뚯 보면 View() 함수를 활용해 데이터프레임을 살펴보는 것과 유사한 것처럼 보이지만, 부가적인 기능이 제공된다.\nDT 패키지는 테이블의 상호작용성과 관련하여 몇 가지 기능을 제공한다.\n\nPagination: 페이지를 이동할 수 있는 기능\nInstant search: 즉각적인 찾기 기능(Search에 타이핑하기 시작하면 즉각적으로 검색 결과 보여줌)\nMulti-column ordering: 다중 컬럼 정렬 기능(컬럼 하나를 선택한 후 ctrl을 누른 상태에서 다른 컬럼을 선택)\nFiltering: 값을 정렬할 수 있는 기능\nEditable: 셀 값을 수정할 수 있는 기능\nButtons: 셀 숨기기, CSV, PDF, XLSX 등의 확장자로 내보내기 등을 수행하는 버튼 생성 기능\n\n그 중 몇 가지 기능을 여기에서 살펴본다. 자세한 사항은 DT 패키지 홈페이지에 잘 정리되어 있다.\n\n2.1 테이블 CSS 클래스\ndatatable() 함수의 class 인수를 통해 테이블의 외관을 바꿀 수 있다. 다음과 같은 옵션이 가능하다.\n\n\n\n\n\n\nClass name\nDescription\n\n\n\ndisplay\n\nstripe, hover, row-border, order-column을 동시 적용한 디폴트\n\n\ncell-border\n모든 셀의 상하좌우에 경계선 표시\n\n\ncompact\n여백 축소\n\n\nhover\n마우스의 위치에 따라 점멸 효과\n\n\nnowrap\n줄바꿈 없이 텍스트 표시\n\n\norder-column\n정렬의 키가 되는 컬럼에 하이라이트 표시\n\n\nrow-border\n행별 경계선 표시\n\n\nstripe\n행을 스트라이프로 표시\n\n\n\n아래와 같이 cell-border과 compact를 함께 실행해 보고 테이블의 변화를 확인한다.\n\ndatatable(head(gapminder), class = \"cell-border compact\")\n\n\n\n\n\n\n또한 특정 컬럼의 정렬 방식(왼편, 오른편, 중앙)을 변경할 수 있다. 사용가능한 옵션은 다음과 같다.\n\n\nClass name\nDescription\n\n\n\ndt[-head|-body]-left\n왼편 정렬\n\n\ndt[-head|-body]-center\n가운데 정렬\n\n\ndt[-head|-body]-right\n오른편 정렬\n\n\ndt[-head|-body]-justify\n양쪽 맞춤\n\n\ndt[-head|-body]-nowrap\n줄바꿈 없는 맞춤\n\n\n\n아래는 첫 번째와 두 번째 컬럼(country, continent)의 내용(body)을 가운데 정렬로 나타낸다.\n\ndatatable(head(gapminder),\n          options = list(\n            columnDefs = list(list(className = \"dt-body-center\", targets = 1:2))\n          ))\n\n\n\n\n\n\n2.2 테이블 에디팅\neditable 인수를 통해 테이블의 값을 수정할 수 있게 만들 수 있다. 테이블의 특정 셀에 더블클릭하면 수정할 수 있다.\n\ndatatable(head(gapminder), editable = \"cell\")\n\n\n\n\n\n\n2.3 컬럼 필터\n다음과 같은 방식으로 필터를 설정할 수 있다.\n\ndatatable(gapminder, filter = \"top\", \n          options = list(\n            pageLength = 5, \n            autoWidth = TRUE\n          ))\n\n\n\n\n\n\n2.4 버튼 기능\nextenstion에 Buttons, dom에 Bftip, buttons에 c(\"copy\", \"excel\", \"pdf\", \"print\")를 입력하면 버튼 기능을 활성화할 수 있다. 각 인수가 무엇을 의미하는지는 다음의 웹사이트를 참고할 수 있다.\n\ndatatable(gapminder, filter = \"top\",\n          extensions = \"Buttons\",\n          options = list(\n            pageLength = 5,\n            autoWidth = TRUE,\n            dom = \"Bfrtip\",\n            buttons = c(\"copy\", \"excel\", \"pdf\", \"print\")\n          ))",
    "crumbs": [
      "R 실습: 2025/2",
      "소통하기: 인터랙티브 시각화"
    ]
  },
  {
    "objectID": "lab_09_2025.html#그래프",
    "href": "lab_09_2025.html#그래프",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n3 그래프",
    "text": "3 그래프\n\n3.1 인터랙티브 그래프\n인터랙티브 시각화 도구로 최근 널리 각광을 받고 있는 Plotly이다. Plotly는 사실 캐나다 퀘백에 본사를 두고 있는 데이터 시각화 전문 회사 이름이다. 그러나 보통 데이터 시각화용 JavaScript 라이브러리를 일컽는다. 이 라이버러리는 다양한 오픈소스 프로그래밍 언어에서 사용가능하며(이기준 2023), R의 랩퍼 프로그램이 plotly 패키지이다.\n\nlibrary(plotly)\n\ngapminder 데이터를 이용하여 간단한 그래프를 그려보자. 문법이 ggplot2와 크게 다르지 않음을 알 수 있다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  plot_ly(x = ~gdpPercap, y = ~lifeExp, color = ~continent,\n          text = ~paste(\"Country: \", country, \n                        \"&lt;br&gt;GDP per capita: \", gdpPercap, \n                        \"$&lt;br&gt;Life Expectancy at Birth:\", lifeExp))\n\n\n\n\n\n\n줌(zoom), 팬(pan), 박스 선택(box select), 라소 선택(Lasso select), 줌인(zome in), 줌 아웃(zoom out) 등과 같은 상호작용 기능을 확인할 수 있다. 또 그래프 상의 데이터 포인트 위에 마우스를 올리면 text 인수를 통해 설정한 내용을 볼 수 있다. 그리고 범례를 클릭하면 특정 continent의 국가를 나타나지 않게 할 수 있다.\n이와 같이 plotly 패키지를 직접 사용하면 다양한 기능을 활용할 수 있겠지만, plotly 패키지가 제공하는 ggplotly() 함수를 활용하면 ggplot2로 만들어진 그래프를 단숨에 plotly 그래프로 바꿀 수 있다. 물론 정확히 같지는 않다.\n\nP &lt;- gapminder |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() + \n  scale_color_brewer(palette = \"Set2\") +\n  theme_minimal()\nggplotly(P)\n\n\n\n\n\n\n다음 예제 역시 반응형이지만 바로 다음에서 다룰 동적인 특성도 동시에 가지고 있는 그래프를 만드는 것이다. 역시 plotly 패키지를 이용한다.\n\ngapminder |&gt; \n  plot_ly(x = ~log10(gdpPercap), y = ~lifeExp,\n          text = ~paste(\"Country: \", country)) |&gt; \n  add_markers(color = ~continent, size = ~pop, frame = ~year, \n              marker = list(sizeref = 0.2, sizemode = \"area\"))\n\n\n\n\n\n\n하단에 있는 ‘Play’ 버튼을 누르면 연도에 따라 그래프가 바뀌면서 동적인 효과가 나타나게 된다.\n\n3.2 애니메이션 그래프\n이 실습에서는 gganimate 패키지를 활용하여, 움직이는 그래프를 만드는 방법을 익히도록 한다. 물론 움직인다고 해서 인터랙티브한 그래프인 것은 아니다. gganimate 패키지를 설치한 후 불러온다.\n\nlibrary(gganimate)\n\n우선 정적인 그래프를 그린다.\n\nP &lt;- gapminder |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, color = continent)) +\n  geom_point(show.legend = FALSE, alpha = 0.7) +\n  scale_x_log10() +\n  scale_size(range = c(2, 12))\nP\n\n\n\n\n\n\n\n이 그래프는 두 변수 간에 양적인 관련성이 있다는 사실은 명백히 보여주지만, 데이터 변형의 측면에서는 잘못된 것이다. 모든 연도(1952~2007년간 5년 단위)가 나타나 있어서 한 국가가 그래프에 12번 등장한다.\n이를 해결하기 위해 ggplot2 패키지의 facet_wrap() 함수를 활용한다.\n\nP + facet_wrap(~year)\n\n\n\n\n\n\n\n이 그래프는 두 변수간의 양적인 상관관계가 12개 모두의 연도에서 나타난다는 사실을 명확히 보여준다. 그러나 그래프를 세세히 살펴보면 알 수 있듯이, 두 변수의 관련성이라는 측면에서 개별 국가가 시간의 흐름에 따라 어떻게 변화해 나가는지에 대한 사항을 파악하기는 매우 어렵다.\ngganimate 패키지의 transition_time() 함수를 활용하여 동적인 그래프를 작성해 본다.\n\nP + transition_time(year) +\n  labs(title = \"Year: {frame_time}\")\n\n\n\n\n\n\n\n대륙별로 분할하여 표현할 수도 있다.\n\nP + facet_wrap(~continent) +\n  transition_time(year) +\n  labs(title = \"Year: {frame_time}\")\n\n\n\n\n\n\n\n움직임을 조금 더 역동적이게 만들어 볼 수 있다.\n\nP + transition_time(year) +\n  labs(title = \"Year: {frame_time}\") +\n  shadow_wake(wake_length = 0.1, alpha = FALSE)\n\n\n\n\n\n\n\n그래프를 저장하고 싶으면 anim_save() 함수를 활용할 수 있다. ggsave() 함수와 동일한 문법을 갖는다.",
    "crumbs": [
      "R 실습: 2025/2",
      "소통하기: 인터랙티브 시각화"
    ]
  },
  {
    "objectID": "exec_02.html",
    "href": "exec_02.html",
    "title": "R과 데이터사이언스 과정",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 전 과정을 개괄적으로 이해하도록 한다. 특히 그림 1 에 나타나 있는 데이터사이언스 과정 중 특히 네 부분, 데이터 불러오기(importing), 정리하기(tidying), 변형하기(transforming), 시각화하기(visualizing)에 초첨을 둔다. 보통 데이터 정리하기와 변형하기를 합쳐 ’데이터와 씨름하기(data wrangling)’이라고 부르고, 변형하기와 시각화하기를 합쳐 ’데이터 탐색하기(data exploration)’라고 한다. 데이터를 살펴보기 위해 모델링을 사용하는 경우, 일부 모델링하기도 탐색하기에 포함되는 것으로 볼 수도 있다.\n\n\n\n\n\n그림 1: 데이터사이언스의 과정(https://r4ds.hadley.nz/intro.html)\n\n\n데이터사이언스의 다양한 과업을 수행하기 위해 Base R의 함수들이 사용되고 있지만, 보통은 이와 함께 다양한 패키지(package)들이 널리 사용되고 있다. 따라서 본 실습에서는 우선 패키지의 사용과 관련된 부분을 다루고 뒤를 이어 데이터사이언스의 네 과제가 어떻게 이루어지는지 대략적으로 다룰 것이다.\n\n패키지와 tidyverse\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#개요",
    "href": "exec_02.html#개요",
    "title": "R과 데이터사이언스 과정",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 전 과정을 개괄적으로 이해하도록 한다. 특히 그림 1 에 나타나 있는 데이터사이언스 과정 중 특히 네 부분, 데이터 불러오기(importing), 정리하기(tidying), 변형하기(transforming), 시각화하기(visualizing)에 초첨을 둔다. 보통 데이터 정리하기와 변형하기를 합쳐 ’데이터와 씨름하기(data wrangling)’이라고 부르고, 변형하기와 시각화하기를 합쳐 ’데이터 탐색하기(data exploration)’라고 한다. 데이터를 살펴보기 위해 모델링을 사용하는 경우, 일부 모델링하기도 탐색하기에 포함되는 것으로 볼 수도 있다.\n\n\n\n\n\n그림 1: 데이터사이언스의 과정(https://r4ds.hadley.nz/intro.html)\n\n\n데이터사이언스의 다양한 과업을 수행하기 위해 Base R의 함수들이 사용되고 있지만, 보통은 이와 함께 다양한 패키지(package)들이 널리 사용되고 있다. 따라서 본 실습에서는 우선 패키지의 사용과 관련된 부분을 다루고 뒤를 이어 데이터사이언스의 네 과제가 어떻게 이루어지는지 대략적으로 다룰 것이다.\n\n패키지와 tidyverse\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#패키지와-tidyverse-패키지",
    "href": "exec_02.html#패키지와-tidyverse-패키지",
    "title": "R과 데이터사이언스 과정",
    "section": "\n1 패키지와 tidyverse 패키지",
    "text": "1 패키지와 tidyverse 패키지\n\n1.1 패키지\n패키지는 유사한 과업을 수행하는데 도움을 주는 함수들의 묶음 정도로 정의할 수 있다. 현재 CRAN(The Comprehensive R Archive Network)에는 20,000개 정도의 패키지가 등록되어 있다고 한다. CRAN에 패키지를 등록하는게 쉽지 않은 일이기 때문에 GitHub과 같은 곳을 통해 접근 가능한 패키지까지 합치면 도대체 몇 개의 R 패키지가 세상에 존재하는지 알기 어렵다.\n패키지를 사용하기 위해서는 해당 패키지가 사용자의 디바이스에 물리적으로 인스톨되어 있어야 하고, R 세션에서 패키지를 불러와야 한다. 패키지를 인스톨하는 방법은 두 가지 이다. 스크립트 내에서 패키지를 반복해서 인스톨하는 것은 합리적이지 않기 때문에 전자의 관행을 추천한다.\n\nOutput 창의 Packages 탭 선택: Install 아이콘을 클릭하고 패키지 이름 입력\n스크립트 내에서 인스톨하기: install.packages(\"패키지명\")\n\n쌍따옴표 속에 패키지 이름을 타이핑해야 한다. 한번 인스톨이 되면 업데이트하지 않는 한 새롭게 패키지를 인스톨할 필요가 없다. 인스톨된 패키지를 사용하려면 스크립트 내에서 다음과 같이 타이핑하고 실행한다.\n\nlibrary(패키지명)\n\n괄호 속에 패키지명을 기입해야 한다.\n\n\n\n\n\n\n노트\n\n\n\n\n\ninstall.packages()함수에서는 반드시 패키지명을 쌍따옴표로 싸야하지만, library()함수에서는 그렇지 않다. 불러온 패키지는 R 세션이 유지되는 동안 내내 사용할 수 있지만, R 세션을 끝내고 다시 시작하면 다시 library()함수를 이용해 다시 불러와야 한다. 그래서 R 스크립트 파일의 시작 부분에는 패키지를 불러오는 코드를 위치시키고, 다시 스크립트 파일을 열 때마다 그 부분을 재실행하는 것이 좋은 습관이다.\n\n\n\n\n1.2 tidyverse 패키지\n데이터사이언스 과정의 각 단계는 특징적인 과업으로 구성되어 있고, 거기에 맞춰 특징적인 함수들을 장착한 패키지들이 개발되어 왔다. 그런데 최근 RStudio는 데이터사이언스와 밀접히 관련된 패키지들을 모아 일종의 엄브렐러 패키지인 tidyverse를 만들어 제공하고 있다. tidyverse 패키지는 패키지의 패키지인데, 핵심적인 구성 패키지에 다음과 같은 것들이 있다.\n\nggplot2: 시각화하기\ndplyr: 변형하기\ntidyr:정리하기\nreadr: 불러오기\ntibble: 데이터 프레임 관련\nstringr: 문자열 처리 관련\nforcats: 범주 변수(팩터) 처리 관련\npurrr: 함수형 프로그래밍(functional programming) 관련\nlubridate: 일시 및 시간 처리 관련\n\n\n\n\n\n\n그림 2: tidyverse의 핵심 패키지(https://www.tidyverse.org/)\n\n\ntidyverse패키지를 사용하는 것의 장점은 이 패키지만 불러오면 구성 패키지까지 한꺼번에 사용할 수 있게 된다는 점이다. 스크립트 내에서 다음과 같은 코드를 실행한다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#시각화하기",
    "href": "exec_02.html#시각화하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n2 시각화하기",
    "text": "2 시각화하기\n\n2.1 데이터 살펴보기\n이 실습을 위해 남극 파머군도(Palmer Archipelago)에 서식하는 펭귄 성체의 신체 계측 데이터를 사용한다. 이 데이터는 palmerpenguins라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다.\n\nlibrary(palmerpenguins)\n\n이제 이 페키지에 포함되어 있는 penguins라는 이름의 데이터를 불러온다.\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n데이터를 자세히 살펴보면 몇 가지를 알 수 있다.\n\n티블(tibble)이라는 형식의 데이터 프레임이다. 티블은 tidyverse의 공식 데이터 프레임 포맷이다.\n관측개체는 344개, 변수는 8개이다.\nspecies, island, sex 변수의 유형은 팩트형(fctr)이고, bill_length_mm, bill_depth_mm은 실수형(dbl)이고, 나머지는 정수형(int)이다.\n\n변수가 많아지면 전체 데이터를 조망하기 어렵기 때문에, 최초의 tidyverse 함수인 glimpse()를 사용하여 데이터의 행과 열을 바꾸어 보자. 변수 위주로 데이터를 개관하고자 할 때 매우 유용하다.\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\n\n\n\n\n힌트\n\n\n\npenguins데이터 내 속성들에 대한 설명을 보고싶다면 Console에 help(penguins) 또는 ?penguins를 입력한 뒤 실행한다.\n\n\n\n2.2 그래프 만들기\n이 penguins 데이터와 ggplot2 패키지를 이용하여 “펭귄의 날개 길이와 몸무게의 관계”를 표현하는 그래프를 작성해 보자. ggplot2의 문법에 대한 사항은 따로 공부할 기회가 있으므로 여기서는 제작 과정을 한 번 따라가 본다.\n\n2.2.1 플롯 객체의 지정\nggplot()이라는 함수를 통해 플롯 제작을 개시하는 단계이며, 어떤 데이터를 사용할지를 지정한다.\n\nggplot(data = penguins)\n\n\n\n\n\n\n\n\n2.2.2 플롯의 시각속성 매핑\n데이터가 어떤 시각속성(aesthetics)으로 표현될 것인가를 지정한다. 여기서는 간단히 어떤 변수들이 x-축과 y-축에 나타나는지만 지정한다. mapping = aes() 아규먼트가 핵심이다. 보통 mapping은 생략하고 aes()만 쓴다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n\n\n\n\n\n\n\n2.2.3 플롯의 기하객체 지정\n데이터가 어떤 기하객체(geometric object)로 표현될 것인가 혹은 어떤 그래프 유형으로 표현될 것이가를 지정한다. geom 아규먼트가 핵심인데, geom_point()는 데이터를 포인트라고 하는 기하객체로 표현한다는 것을 지정한 것으로 결국 산포도(scatterplot)라는 그래프 유형을 산출하게 된다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n2.2.4 시각속성의 첨가\n이러한 관련성이 펭귄의 종족에 따라 다르게 나타나는지를 탐색하기 위해 color 라는 시각속성을 species라는 변수에 적용한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n2.2.5 기하객체 레이어의 첨가\n두 변수의 관련성을 보여주는 선형 기하객체를 첨가한다. 여기서는 geom_smooth()를 이용하여 OLS 회귀선을 첨가한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n2.2.6 라벨링 등 마무리 작업\nlabs()를 이용하여 그래프의 제목(title), 부제목(subtitle), 축이름, 범례 표제 등을 지정한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\"\n  )",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#변형하기",
    "href": "exec_02.html#변형하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n3 변형하기",
    "text": "3 변형하기\n변형하기와 관련된 함수들은 대부분 dplyr 패키지에 포함되어 있다.\n\n3.1 데이터 살펴보기\n이 실습을 위해 미국 교통통계국(U.S. Bureau of Transportation)이 제공하는 데이터를 사용하는데, 이것은 2013년 한 해 동안 미국 뉴욕시를 출발한 336,776대의 항공기에 대한 정보를 담고 있다. 이 데이터는 nycflights13 이라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다. 그리고 나서 패키지에 포함되어 있는 flights라는 이름의 데이터를 불러온다.\n\nlibrary(nycflights13)\nglimpse(flights)\n\nRows: 336,776\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n\n\n\n\n\n\n힌트\n\n\n\nflights데이터 내 속성들에 대한 설명을 보고싶다면 Console에 help(flights) 또는 ?flights를 입력한 뒤 실행한다.\n\n\n\n3.2 주요 함수\n여기서는 가장 널리 사용되는 6개 함수에 대해서만 개략적으로 다룬다. 그 6개 함수는 select(), filter(), arrange(), mutate(), group_by(), summerize()이다. 조교의 도움을 받아 각 함수가 무슨 일을 한 것인지 이해한다.\n\n3.2.1 select() 함수\n열(변수) 중 일부를 솎아낸다. 즉, 변수의 갯수를 줄인다.\n\nselect(flights, year, month, day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\n\n3.2.2 filter() 함수\n특정 열(변수)에 의거해 조건을 만족하는 행을 솎아낸다. 즉 관측개체의 갯수를 줄인다.\n\nfilter(flights, month == 1 & day == 1)\n\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.3 arrange() 함수\n특정 열(변수)에 의거해 행의 순서를 바꾼다.\n\narrange(flights, year, month, day)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.4 mutate() 함수\n기존의 열(변수)을 변형하여 새로운 열(변수)을 생성한다.\n\nmutate(flights,\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, gain &lt;dbl&gt;, speed &lt;dbl&gt;\n\n\n\n3.2.5 group_by() 함수\n열(변수)(범주형 변수, categorical variables)에 의거해 전체 행을 그룹으로 분할한다. 데이터 프레임이 내부적으로 12개의 달로 분할된다.\n\ngroup_by(flights, month)\n\n# A tibble: 336,776 × 19\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.6 summerize() 함수\n열(변수)의 통계량을 산출하여 새로운 데이터 프레임의 새로운 열(변수)에 저장한다. 모든 항공기의 평균출발지연시간을 계산한 것이다.\n\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  delay\n  &lt;dbl&gt;\n1  12.6\n\n\n위의 group_by() 함수와 결합하면, 그룹별로 열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장할 수 있다. 일단위로 평균출발지연시간을 계산한 것이다.\n\nby_day &lt;- group_by(flights, year, month, day)\nsummarize(by_day, delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day delay\n   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n 1  2013     1     1 11.5 \n 2  2013     1     2 13.9 \n 3  2013     1     3 11.0 \n 4  2013     1     4  8.95\n 5  2013     1     5  5.73\n 6  2013     1     6  7.15\n 7  2013     1     7  5.42\n 8  2013     1     8  2.55\n 9  2013     1     9  2.28\n10  2013     1    10  2.84\n# ℹ 355 more rows",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#정리하기",
    "href": "exec_02.html#정리하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n4 정리하기",
    "text": "4 정리하기\n정리하기와 관련된 함수들은 대부분 tidyr 패키지에 포함되어 있다. 많은 함수가 있지만 가장 중요한 두 개의 함수에만 집중한다.\n\n4.1 데이터 살펴보기\n이 실습에서는 tidyverse 패키지에 포함되어 있는 매우 단순한 데이터를 사용한다. 이 두 데이터는 정돈된 데이터(tidy data)가 아니다. 정돈된 데이터가 무엇인지에 대해서는 다음 장에서 다룬다. 여기서는 정돈되지 않은 데이터를 정돈된 데이터로 만드는 과정을 맛본다.\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n\n\n\n4.2 주요 함수\n\n4.2.1 pivot_longer() 함수\ntable4a에서 1999과 2000은 변수명일 수 없다. year라는 변수의 속성이어야 한다.\n\npivot_longer(\n  table4a, \n  cols = c(`1999`, `2000`),\n  names_to = \"year\",\n  values_to = \"cases\"\n)\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\n\n4.2.2 pivot_wider() 함수\ntable2에서 type 변수는 두 개의 변수명을 포함하고 있다. 즉, cases와 population은 속성값이라기 보다는 변수명이다.\n\npivot_wider(\n  table2, \n  names_from = \"type\",\n  values_from = \"count\"\n)\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#불러오기",
    "href": "exec_02.html#불러오기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n5 불러오기",
    "text": "5 불러오기\n불러오기와 관련된 함수들은 대부분 readr 패키지에 포함되어 있다. 여러 유형의 파일을 불러오기 위해 여러 함수가 존재하지만, 콤마분리값(comma-separated values, CSV) 형식의 데이터를 불러오는 함수(read_csv())만 실습한다.\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\nglimpse(students)\n\nRows: 6\nColumns: 5\n$ `Student ID`   &lt;dbl&gt; 1, 2, 3, 4, 5, 6\n$ `Full Name`    &lt;chr&gt; \"Sunil Huffmann\", \"Barclay Lynn\", \"Jayendra Lyne\", \"Leo…\n$ favourite.food &lt;chr&gt; \"Strawberry yoghurt\", \"French fries\", \"N/A\", \"Anchovies…\n$ mealPlan       &lt;chr&gt; \"Lunch only\", \"Lunch only\", \"Breakfast and lunch\", \"Lun…\n$ AGE            &lt;chr&gt; \"4\", \"5\", \"7\", NA, \"five\", \"6\"",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#파이프-연산자pipe-operator",
    "href": "exec_02.html#파이프-연산자pipe-operator",
    "title": "R과 데이터사이언스 과정",
    "section": "\n6 파이프 연산자(pipe operator)",
    "text": "6 파이프 연산자(pipe operator)\n우리는 이전 실습에서 할당 연산자(&lt;-)에 대해 배웠다. 오늘 살펴본 다양한 변형의 결과를 다른 데이터 프레임에 담고 싶으면 다음과 같이 할당 연산자를 사용할 수 있다.\n\nflights_day1 &lt;- filter(flights, month == 1 & day == 1)\nglimpse(flights_day1)\n\nRows: 842\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n앞으로 할당 연산자보다 훨씬 더 빈번하게 사용하게 될 연산자를 소개하려고 한다. 그것은 파이프 연산자(pipe operator)라는 것으로, %&gt;% 혹은 |&gt;로 표시하는 것이다. 원래 이 연산자의 원리는 magrittr 패키지에서 처음 소개되었는데, 차츰 R 커뮤니티에 파급되더니 급기야는 대세로 자리잡았다. 그래서 특정 패키지를 깔지 않아도 파이프 연산자를 사용할 수 있게 하기 위해 Base R에 도입되었고(이것을 네이티브 파이프 연산자(native pipe operator)라고 부른다), 부호로 %&gt;% 대신 |&gt;를 사용한다. 둘 사이에 차이는 거의 없지만, 후자가 점점 표준이 되고 있기 때문에 본 수업에서는 그것을 사용한다. 다음의 두 가지에 유의한다.\n\n현재 RStudio의 디폴트는 %&gt;%로 설정되어 있다. 이것을 Tools &gt; Global Options &gt; Code에 가서 ’Use native pipe operator, |&gt; (requires R 4.1+)’를 선택해 주어야 한다. 아래의 그림 3 를 참고하라.\n\n\n\n\n\n\n그림 3: 파이프 연산자(https://r4ds.hadley.nz/data-transform)\n\n\n\n단축키는 Crtl + Shift + M이다. 다른 건 몰라도 이 단축키만은 반드시 기억해야 한다.\n\n다음의 세 코드를 비교해 보라. 우선 아래의 경우는 flights1과 flights2와 같은 중간 변수가 계속 생성되어 메모리를 차지하게 된다.\n\nflights1 &lt;- filter(flights, dest == \"IAH\")\nflights2 &lt;- mutate(flights1, speed = distance / air_time * 60)\nflights3 &lt;- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n혹은 다음과 같이 함수가 다른 함수 속에 계속 포함되는 형식으로 만들 수 있는데, 코드가 매우 복잡해 진다.\n\narrange(\n  select(\n    mutate(\n      filter(\n        flights, \n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n다음은 위 두 경우와 달리 파이프 연산자를 사용한 경우이다. 동일한 결과를 가져다 주지만 훨씬 더 간결하고 직관적이고 이해하기 쉽다. 파이프 연산자의 사용 원리는 뒤에서 자세히 배운다.\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  mutate(speed = distance / air_time * 60) |&gt; \n  select(year:day, dep_time, carrier, flight, speed) |&gt; \n  arrange(desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_03.html",
    "href": "exec_03.html",
    "title": "소통하기: Quarto로 대시보드 만들기",
    "section": "",
    "text": "여기서는 데이터사이언스 과정의 ‘소통(communication)’ 단계 혹은 ’데이터로 소통하기’를 위한 핵심 도구로서의 Quarto를 다룬다. 그리고 더 나아가 Quarto를 활용해 대시보드를 만드는 과정에 대해 설명한다.\n\n\n\n\n\n\n힌트\n\n\n\nQuarto는 한글로 ’쿼토’라고 읽는다.",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: Quarto로 대시보드 만들기"
    ]
  },
  {
    "objectID": "exec_03.html#개요",
    "href": "exec_03.html#개요",
    "title": "소통하기: Quarto로 대시보드 만들기",
    "section": "",
    "text": "여기서는 데이터사이언스 과정의 ‘소통(communication)’ 단계 혹은 ’데이터로 소통하기’를 위한 핵심 도구로서의 Quarto를 다룬다. 그리고 더 나아가 Quarto를 활용해 대시보드를 만드는 과정에 대해 설명한다.\n\n\n\n\n\n\n힌트\n\n\n\nQuarto는 한글로 ’쿼토’라고 읽는다.",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: Quarto로 대시보드 만들기"
    ]
  },
  {
    "objectID": "exec_03.html#quarto-입문",
    "href": "exec_03.html#quarto-입문",
    "title": "소통하기: Quarto로 대시보드 만들기",
    "section": "\n1 Quarto 입문",
    "text": "1 Quarto 입문\n\n1.1 Quarto란?\nQuarto는 “과학적, 기술적 출판을 위한 오픈소스 시스템(an open-source scientific and technical publishing system)”으로 정의되는데, 다양한 형식의 저작물(연구 논문, 프레젠테이션, 대시보드, 웹사이트, 블로그, 서적 등)을 다양한 디지털 포맷(HTML, PDF, MS Word, ePub 등)으로 출판할 수 있게 해준다.\nQuarto는 연구 노트, 레포트, 블로그 등을 작성할 수 있게 해준다는 측면에서 ‘개인적’ 도구이지만, 다양한 규모의 프로젝트의 원할한 진행을 도와준다는 측면에서 ‘협업’ 도구이며, 더 나아가 과학 커뮤니티 전체의 재현성(reproducibility) 고양에 도움을 줄 수 있다는 측면에서 ‘사회적’ 도구이기도 하다.\n원래 R 커뮤니티에는 유사한 기능을 수행하는 RMarkdown이라는 도구가 존재했고 여전히 많은 사람들이 사용하고 있다. Quarto는 기존의 RMarkdown에 ’통합’이라는 키워드를 적용시켜 보다 발전된 형태의 저작 시스템으로 거듭난 것이다. 우선 Quarto는 다양한 오픈소스 프로그래밍 언어에서 사용될 수 있다(R, Python, Julia, Observable). 둘째, Quarto는 출판물의 다양한 형식에 구애되지 않는 일관성있는 저작 시스템을 제공한다.\n\n\n\n\n\n그림 1: Quarto의 기본 개념(https://rstudio.github.io/cheatsheets/html/quarto.html)\n\n\nQuarto 다큐먼트의 기본 구문은 마크다운(markdown), 혹은 마크다운의 보다 특수한 형태로서의 팬독(pandoc) 마크다운이다. 마크다운 언어는 마크업(markup) 언어의 일종인데, 마크업 언어는 다큐먼트의 구조와 포맷을 관장하는 텍스트-엔코딩 시스템이다. 그런데 마크업 언어는 배우기 어렵다. 예를 들어, 대표적인 마크업 언어인 HTML은 수많은 태그의 복잡한 위계 구조를 가지고 있어 사용자 입장에서는 읽기도 어렵고, 쓰기도 어렵다. 마크다운 언어는 사용자가 보다 사용하기 쉬운 구문 구조를 제공함으로써 동일한 웹 결과물을 보다 용이하게 제작할 수 있게 도와준다. Quarto는 이러한 마크다운 언어에 기반하고 있다.\n프로그래밍 언어와의 관련성이라는 측면에서 보면, Quarto 다큐먼트는 기본적으로 워드프로세서에 프로그래밍 언어가 부가된 것으로 이해할 수 있다. 워드프로세서가 기본적으로 제공하는 텍스트 작성, 테이블 작성, 그래픽 삽입 등의 기능 외에 코드 편집, 코드 실행, 실행 결과 삽입 등의 기능이 함께 포함되어 있다. 이렇게 작성된 Quarto 다큐먼트는 .qmd라는 확장자를 갖는다. Quarto 다큐먼트를 렌더링하면 knitr 패키지가 마크다운 파일(.md)을 생성하고, pandoc이 그것들을 다양한 포맷의 산출물로 변환한다.\n\n\n\n\n\n그림 2: Quarto의 작동 방식(https://quarto.org/docs/get-started/hello/rstudio.html)\n\n\n\n1.2 Quarto 다큐먼트의 기본 구조\n그림 3 을 바탕으로 Quarto다큐먼트의 기본 구조를 설명하고자 한다. 왼쪽은 비주얼 에디터(visual editor)를 사용한 것이고, 오른쪽은 소스 에디터(source editor)를 사용한 것이다. 소스 에디터는 마크다운 구문을 그대로 사용하는 것이므로 마크다운의 기본 형식에 대한 이해가 선행되어야 한다. 이에 반해 비주얼 에디터는 마치 워드프로세서를 다루듯 메뉴 형식으로 Quarto 다큐먼트를 작성할 수 있다. 비주얼 에디터에 대해서는 뒤에서 상세히 다루기로 한다.\n\n\n\n\n\n그림 3: Quarto의 기본 구조와 비주얼 에디터\n\n\n그림 3 의 왼쪽 그림에서 보다 잘 드러나는 것처럼, Quarto 다큐먼트는 크게 세 부분으로 나뉘어진다.\n\nYAML 헤더(header)\n코드 청크(code chunk)\n마크다운 텍스트\n\n\n1.2.1 YAML 헤더\nYAML 헤더는 Quarto 다큐먼트의 최상단에 위치하는 것으로, 일종의 메타데이터로 다큐먼트의 전반적인 사항을 관장한다. YAML 헤더 부분은 세 개의 대시 부호(- - -)를 통해 다른 부분과 구분된다.\n\n\n\n\n\n\n힌트\n\n\n\nYAML은 YAML Ain’t Markup Language의 약자이며, 한글로 ’예믈’이라고 읽는다.\n\n\nYAML 헤더의 모든 요소는 기본적으로 key: value의 행태를 띤다. key는 항목이고, value는 해당 항목에 대한 옵션값이다. 위의 예에는 title, format, editor의 세 key가 사용되었는데, 제목은 “Hello, Quarto”이며, 산출 포맷은 HTML이며, Quarto 다큐먼트 작성을 비주얼 에디터를 통해 할 것이라는 점을 명시하고 있다.\n다양한 key를 설정할 수 있으며, 다음의 것들이 중요하다.\n\n\n표 1: YAML 헤더의 다양한 key\n\n\n\n\n\n\n\nkey\n설명\n\n\n\ntitle\n다큐먼트 제목\n\n\ndate\n다큐먼트 작성 날짜\n\n\nauthor\n다큐먼트 저자 이름\n\n\nformat\n다양한 포맷 관련 사항의 지정\n\n\ntoc\n목차 삽입\n\n\nnumber-section\n섹션 제목에 자동 번호 부여 여부\n\n\nexecute: echo\n소스 코드의 포함 여부를 글로벌하게 설정, 보통 true\n\n\nexecute: warning\n경고 메시지를 산출물에 나타나게 할지를 글로벌하게 설정, 보통 false\n\n\neditor\n비주얼 에디터와 소스 에디터 중 선택, 보통 visual\n\n\n\n\n\n\n\n1.2.2 코드 청크\n코드 청크는 프로그래밍 언어의 코드가 들어가는 부분이다. R를 사용하는 경우 {r}로 시작한다. 데이터 불러오기, 정리하기, 변형하기, 시각화하기, 탐색하기, 수집하기와 관련된 모든 종류의 코드가 여기에 들어갈 수 있다. 보통 하나의 Quarto 다큐먼트에 다수의 코드 정크가 포함된다. 각 코드 청크 내에서 코드를 실행할 수 있다. 한 단위씩 실행할 때는 Ctrl + Enter 단축기를 사용하지만 한 코드 청크 내 모든 코드를 실행하고자 할 때는 Ctrl + Shift + Enter 단축기를 사용한다.\n각 코드 청크의 앞 부분에 해당 코드 정크와 관련된 다양한 옵션을 #| 형태로 삽입할 수 있다. YAML 헤더에서처럼, key: value의 행태를 띤다. 가장 중요한 옵션은 코드 청크의 내용이나 실행 결과 등이 산출물에 어떻게 표현되는지를 결정하는 것들이다. 다음의 표는 코드를 실행할지의 여부, 코드를 보여줄지의 여부, 코드의 결과를 보여줄지의 여부, 생성되는 플롯을 보여줄지의 여부, 메시지나 경고문을 보여줄지의 여부 등을 관장하는 다양한 옵션을 정리한 것이다.\n\n\n표 2: 다양한 코드 청크 옵션\n\n\n\n\n\n\n\n\n\n\n\n\nOption\nRun code\nShow code\nOutput\nPlots\nMessages\nWarnings\n\n\n\neval: false\nX\n\nX\nX\nX\nX\n\n\ninclude: false\n\nX\nX\nX\nX\nX\n\n\necho: false\n\nX\n\n\n\n\n\n\nresults: hide\n\n\nX\n\n\n\n\n\nfig-show: hide\n\n\n\nX\n\n\n\n\nmessage: false\n\n\n\n\nX\n\n\n\nwarning: false\n\n\n\n\n\nX\n\n\n\n\n\n\n\n1.2.3 마크다운 텍스트\n워드프로세서처럼 텍스트를 작성한다. 섹션 헤더, 하이퍼링크(hyperlink), 이미지 등을 지정할 수 있고, 인라인 코드 청크(inline code chunk)도 삽입할 수 있다. 마크다운 텍스트의 작성에 비주얼 에디터는 큰 역할을 한다. 비주얼 에디터는 마크다운 언어의 사용자 편이성을 한번 더 강화한 것으로 볼 수 있다.\n비주얼 에디터는 다음의 메뉴로 구성된다. 워드프로세서와 비슷한 형태를 가지고 있음을 알 수 있다. 많이 사용되는 기능은 아이콘을 통해 전면에 배치되어 있다.\n\n\n\n\n\n그림 4: 비주얼 에디터의 메뉴바\n\n\n포맷(Format), 삽입(Insert), 테이블(Table) 메뉴 속에 다양한 하위 기능들이 포함되어 있다. Quarto를 마스트하는데 비주얼 에디터의 기능을 숙달하는 것이 필수적이다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n그림 5: 비주얼 에디터의 메뉴 구성\n\n\n\n1.3 기본 Quarto 다큐먼트의 작성\n\n1.3.1 새 Quarto 다큐먼트 열기\nFile &gt; New File &gt; Quarto Document를 실행한다. Title과 Author란에 적절한 텍스트를 기입하고 아래에 위치한 Create 버튼을 클릭한다.\n\n\n\n\n\n1.3.2 Quarto 다큐먼트의 작성\n비주얼 에디터를 통해 아래와 같은 결과물이 나오도록 Quarto 다큐먼트를 작성해본다.\n\n\n\n\n\n그림 6: 렌더링 결과\n\n\n\n1.3.3 Quarto 다큐먼트의 렌더링\n아래의 그림에 나타나 있는 Render 버튼을 클릭해 다큐먼트를 실행한다. 결과는 오른편 하단의 Viewer 탭에 나타난다. 결과를 그림 6 과 비교한다. 최종적인 html은 프로젝트 파일이 들어있는 폴더에 저장되어 있다.",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: Quarto로 대시보드 만들기"
    ]
  },
  {
    "objectID": "exec_03.html#개인-블로그-만들기",
    "href": "exec_03.html#개인-블로그-만들기",
    "title": "소통하기: Quarto로 대시보드 만들기",
    "section": "\n2 개인 블로그 만들기",
    "text": "2 개인 블로그 만들기\n\n2.1 새로운 Quarto Blog 프로젝트 시작하기\n\n2.1.1 File &gt; New Project &gt; Create Project &gt; Quarto Blog를 선택한다.\n\n\n\n\n\n\n\n\n\n\n디렉토리 이름과 경로를 설정하고, 아래에 위치한 Create Project 버튼을 클릭한다.\n\n\n\n\n\n2.2 렌더링하여 결과를 살펴보기\nRender 버튼을 클릭하여 결과를 확인한다. 결과는 오른쪽 패널의 Viewer 탭에 나타난다. Viewer 탭의 Show in new window 아이콘을 클릭하면 웹브라우저 상에 결과를 나타낼 수 있다.\n\n\n\n\nFiles 탭을 클릭하면 프로젝트 폴더에 다음과 같은 파일들이 생성되어 있음을 확인할 수 있다. 각각의 파일이 어떠한 역할을 하는지 파악한다.\n\n\n표 3: Quarto Blog 프로젝트의 파일 구조\n\n\n\nFile\nDescription\n\n\n\n_quarto.yml\nQuarto 프로젝트 파일\n\n\nindex.qmd\n블로그의 홈페이지\n\n\nabout.qmd\n블로그의 어바우트 페이지\n\n\nposts/\n포스트를 포함하고 있는 폴더\n\n\nposts/_metadata.yml\n포스트가 공유하고 있는 옵션들\n\n\nstyles.css\n웹사이트의 CSS\n\n\n\n\n\n\n\n2.3 구성 요소 수정하기\n구성 요소를 수정하여 자신의 개인 블로그를 만들어 나간다.\n\n2.3.1 메타데이터\n\n블로그의 전체적인 모습은 _quarto.yml 파일에 의해 규정된다. _quarto.yml 파일의 내용을 살펴보고 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히, 25개의 테마를 살펴보고, 그 중 하나를 선택한다.\n\n2.3.2 홈페이지(home page)\n\n블로그의 홈페이지는 포스트 디렉토리에 포함되는 모든 포스트의 리스트를 제공하는 것으로 index.qmd 파일에 의해 규정된다. index.qmd 파일의 내용을 살펴보고 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히 리스팅 유형(listing types) 옵션 세개(default, table, grid)를 살펴보고, 그 중 하나를 선택한다.\n\n2.3.3 어바우트 페이지(about page)\n\n어바우트 페이지는 블로그와 블로그의 저작자에 대한 부가 정보를 제공하는 것으로 about.qmd 파일에 의해 규정된다. about.qmd 파일의 내용을 살펴보고 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히 템플릿(template) 옵션 다섯개(jolla, trestles, solana, marquee, broadside)를 살펴보고, 그 중 하나를 선택한다.\n\n2.3.4 포스트 디렉토리(posts directory)\n\n블로그의 콘텐츠는 포스트 디렉토리 속에 포함되어 있다. 기본적으로 하나의 포스트는 하나의 폴드인데, 개별 폴드 속에는 index.qmd라는 이름의 Quarto 파일이 들어 있다. 그리고 Quarto 다큐먼트에 포함되어 있는 이미지는 images라는 서브 폴드에 저장되어 있다.\n다음의 절차에 따라 새로운 포스트를 생성해 본다.\n\nposts 디렉토리 아래에 새로운 디렉토리를 생성한다. 이름은 날짜와 주제가 결합된 형태로 하면 좋다.\n새로운 디렉토리에 index.qmd 파일을 생성한다. 아래와 같이 YAML 헤더를 수정하고, 실습 1에서처럼 새로운 포스트를 작성한다.\n\n\n---\ntitle: \"I hate May\"\nauthor: \"Your Name Here\"\ndate: \"09/09/2025\"\ndate-modified: last-modified\n---\n\n\n2.4 블로그를 웹 상에 배포하기\n완성된 개인 블로그를 다음의 절차에 따라 웹에 출판한다. 여기서는 Posit에서 제공하는 무료 출판 사이트인 Quarto Pub을 활용한다.\n\nQuarto Pub에 접속하여 계정을 만든다.\nRStudio에서, 왼쪽 하단부의 Terminal 탭을 누른다.\n프롬프트에 다음과 같이 입력하고 실행한다: quarto publish quarto-pub\n\n다음을 웹사이트를 참고한다.",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: Quarto로 대시보드 만들기"
    ]
  },
  {
    "objectID": "exec_03.html#대시보드-만들기",
    "href": "exec_03.html#대시보드-만들기",
    "title": "소통하기: Quarto로 대시보드 만들기",
    "section": "\n3 대시보드 만들기",
    "text": "3 대시보드 만들기\n여기서는 Quarto를 이용해 데이터 대시보드(dashboard)를 만들어 본다. 대시보드는 단일한 주제에 대한 상호연관된 다양한 정보를 주로 그래픽 형태로 일관성 있게 제시한 것을 말한다. 일반적인 대시보드에서 결국 ’대시보드형 인터랙티브 웹 앱(web app)’을 만드는 것을 지향한다.\n\n3.1 대시보드의 기본 구조\n대시보드는 기본적으로 다섯 가지의 구성요소로 이루어진다. 각각은 메인 바디, 헤더, 내비게이터, 사이드바, 푸터이다.\n\n\n\n\n\n그림 7: 대시보드의 기본 구조(https://blog.zarathu.com/posts/2023-12-11-quarto-dashboard/#tabset)\n\n\n첫째, 메인 바디(main body)는 대시보드의 핵심 요소이다. 메인 바디는 카드(card)라고 불리는 기본 단위들로 구성된다. 개별 카드는 다양한 내용 요소(텍스트, 그래프, 표, 지도, 밸류박스 등)를 가질 수 있다. 즉, 어떤 카드 속에는 그래프가 들어가며, 어떤 카드 속에는 지도가 들어간다. 이러한 카드들은 특정한 레이아웃 요소(페이지, 행, 열, 탭셋 등)를 통해 메인 바디에 배열된다. 페이지(page)는 대시보드 레이아웃 요소 중 최상위 레벨인데, 개별 페이지는 다수의 행(row) 혹은 열(column)로 구성된다. 행 혹은 열을 또다른 행 혹은 열이 아닌 탭 클릭 방식으로 분할하고 싶을 때 탭셋(tabset)이 사용된다.\n둘째, 헤더(header)는 대시보드의 가장 중요한 메타 정보(로고, 제목, 저자 등)를 포함한다.\n셋째, 내비게이터(navigator)는 최상위 레이아웃인 페이지간 이동을 통제한다.\n넷째, 사이드바(sidebar)는 주로 사용자의 인풋(input)을 받을 때 사용되는 것으로, 동적인 대시보드에서 주로 사용된다. Quarto는 사이드바 외에 툴바(toolbar)와 카드인풋(card input)과 같은 옵션을 제공한다.\n다섯째, 푸터(footer)는 헤더와 유사한 기능을 하는데, 주로 부차적인 매타 정도를 포함한다.\n다섯개의 구성 요소 중 가장 중요한 것은 메인 바디, 해더, 내비게이터이다. Quarto는 헤더와 내비게이터를 통합한 내비게이션바(navigation bar)를 제공한다. 사이드바는 Shiny 패키지를 활용한 동적인 대시보드에서는 매우 중요하지만, 이번 실습에서는 사용하지 않는다. 푸터는 가장 지엽적인 요소이다.\n다음의 대시보드를 살펴보자.\n\n\n\n\n\n그림 8: 대시보드의 사례(https://quarto.org/docs/dashboards/)\n\n\n이 대시보드는 크게 내비게이션바와 메인 바디로 구성되어 있다. 네비게이션바에는 다음의 내용이 포함되어 있다.\n\n이 대시보드의 제목(title)은 ’고객이탈(Customer Chrun)’이고 회사 이름은 DEMOCO(로고)이다.\n이 대시보드는 모두 두 개의 페이지(page)로 구성되어 있다. 페이지의 이름은 각각 ’Churn (Standard)’과 ’Data’이다.\n\n메인 바디는 다음과 같은 레이아웃 요소들로 구성되어 있다.\n\n첫 번째 페이지(Churn (Standard))는 세 개의 행(row)으로 구성되어 있다.\n첫 번째 페이지의 첫 번째 행은 세 개의 카드(card)로 구성되어 있는데, 내용 요소는 모두 밸류박스(value box)이다.\n첫 번째 페이지의 두 번째 행은 두 개의 열(즉, 카드)로 구성되어 있는데, 내용 요소는 모두 그래프(graph)이다.\n첫 번째 페이지의 세 번째 행은 단일한 열(즉, 카드)로 구성되어 있는데, 내용 요소는 테이블(table)이다.\n두 번째 페이지에도 다양한 사항이 포함되어 있을 것이다.\n\n3.2 레이아웃 설정\n\n3.2.1 행과 열의 설정\n행(row)과 열(column)은 가장 기본이 되는 레이아웃 요소이다. 기본 원칙은 다음과 같다.\n\n헤더 2(header 2) 레벨이 행과 열의 구분을 일차적으로 결정한다.\n헤더 3(header 3) 레벨이 하위 행과 열의 구분을 이차적으로 결정한다.\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1 \n\n### Column {width=60%}\n\nCard 2-2 \n위와 같이 설정하면 다음과 같은 결과를 얻을 수 있다. Row의 경우는 {height} 태그를 통해서, Column의 경우는 {width}태그를 통해 상대적인 크기를 설정할 수 있다.\n\n\n\n\n\n그림 9: 대시보드의 행렬 구조(https://blog.zarathu.com/posts/2023-12-11-quarto-dashboard/)\n\n\n\n3.2.2 탭셋의 설정\n탭셋(tabset)은 행(row)과 열(column)을 다른 하위 행과 열이 아닌 탭의 설정을 통해 분할하고자 할 때 사용된다.\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30% .tabset}\n\n### Column\n\nCard 2-1 {width=50%}\n\n### Column\n\nCard 2-2 {width=50%}\n위와 같이 설정하면 다음과 같은 결과를 얻을 수 있다. 탭셋의 설정을 위해 {.tabset} 태그가 사용된다는 점에 주의한다.\n\n\n\n\n\n\n\n\n\n\n\n\n그림 10: 대시보드의 탭셋 구조\n\n\n\n3.2.3 페이지의 설정\n페이지(page)는 최상위 레이아웃 요소이다. 기본 원칙은 다음과 같다.\n\n헤더 1(header 1) 레벨이 페이지의 구분을 결정한다.\nQuarto에서는 페이지가 내비게이션바에 나타난다.\n\n# Page A\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1\n\n### Column {width=60%}\n\nCard 2-2\n\n# Page B\n\nCard 3\n위와 같이 설정하면 다음과 같은 결과를 얻을 수 있다. 페이지가 내비게이션바에서 마치 탭셋처럼 존재하는 것에 주의한다.\n\n\n\n\n\n\n\n\n\n\n\n\n그림 11: 대시보드의 페이지 구조\n\n\n\n3.3 내비게이션바와 사이드바의 설정\n\n3.3.1 내비게이션바의 설정\n내비게이션바는 헤더와 내비게이터로 구성된다. 내비게이터는 페이지가 설정된 경우에만 나타나게 된다. 여기서는 헤더에 집중하고자 한다. 대시보드 헤더는 다른 Quarto 다큐먼트와 마찬가지로 YAML 헤더를 통해 통제된다. 다음과 같은 요소들이 중요하다.\n\n제목(title): 대시보드 전체의 이름을 결정한다.\n저자(author): 만든 사람이나 관리 회사의 이름이지만, 부제로 활용되기도 한다.\n\n포맷(format): 기본 설정인 대시보드(dashboard) 하에 다양한 하위 설정이 가능하다.\n\nlogo: 로고 그림 파일을 지정하면 내비게이션바의 왼쪽 끝에 나타난다.\nnav-buttons: github이나 이메일 연결을 설정할 수 있다.\nscrolling: true 설정: 디폴트는 false인데, 레이아웃 요소들의 높이들의 합이 100%가 되도록 일괄적으로 조절된다. true로 지정하면, 개별 내용 요소의 원 크기를 그대로 살리면서 스크롤되게 디자인이 바뀐다. 둘 다를 실험해 보고 자신의 목적에 맞는 것을 고른다.\n\n\n테마(theme): 대시보드의 외관을 한꺼번에 바꿀 수 있다. 모두 25개의 부트스와치(bootswatch) 테마가 존재한다. 여러가지를 실험해 보고 자신의 취향에 맞는 것을 선정한다.\n\n3.3.2 사이드바의 설정\n사이드바(sidebar)는 {.sidebar} 태그를 통해 만들 수 있는데, 헤더 1(header 1) 레벨이므로 특정한 페이지에 종속되지 않는다. 사이드바는 주로 사용자의 투입을 받을 때 사용되기 때문에 동적인 대시보드에 주로 사용된다. 정적인 대시보드의 경우에는 텍스트를 통한 특정 정보의 제공에 사용될 수 있다.\n# {.sidebar}\nSidebar content\n위와 같이 설정하면 다음과 같은 결과를 얻을 수 있다.\n\n\n\n\n\n그림 12: 대시보드의 사이드바 구조(https://blog.zarathu.com/posts/2023-12-11-quarto-dashboard/)\n\n\n\n3.4 카드와 내용 요소\n카드(card)란 특정한 내용 요소(텍스트, 벨류박스, 테이블, 그래프, 지도 등)를 포함하고 있는, 대시보드의 가장 기본적인 단위이다. 다음의 두 가지 사항이 중요하다.\n\n카드의 제목이 중요하다. 완성된 대시보드 상에 등장하기 때문에 이해하기 쉬운 제목이 부여되어야 한다.\n내용 요소에 따라 카드를 작성하는 방법이 조금 다르다.\n\n내용 요소 제작의 세세한 사항은 아래의 “예시 대시보드 만들기”에서 확인한다.\n\n3.4.1 그래프\nQuarto는 그래프 하나를 만들어내는 코드 청크를 하나의 카드로 인식한다. 그래프 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. ggplot2와 같은 정적인 플롯 도구 뿐만 아니라 plotly와 같은 반응형 플롯 도구를 사용하여 그래프 카드를 생성한다.\n\n3.4.2 테이블\nQuarto는 테이블 하나를 디스플레이하는 코드 청크를 하나의 카드로 인식한다. 테이블 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. knitr 패키지의 kable() 함수, gt 패키지의 gt() 함수, DT 패키지의 datatable() 함수 등을 이용해 테이블 카드를 생성한다.\n\n3.4.3 지도\nQuarto는 지도 하나를 디스플레이하는 코드 청크를 하나의 카드로 인식한다. 지도 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. ggplot2와 같은 정적인 지도 제작 도구 뿐만 아니라 leaflet과 같은 반응형 지도 제작 도구를 사용하여 지도 카드를 생성한다.\n\n3.4.4 텍스트\n일종의 텍스트 박스도 하나의 카드로 간주된다. 그래프, 테이블, 지도가 하나의 코드 청크가 하나의 카드로 인식되는데 반해 텍스트 카드는 다른 형식을 취한다. ::: {.card} div를 사용해야 하며 #| title: 옵션을 사용해 제목을 지정해야 한다.\n\n3.4.5 밸류박스\n요약적 수치를 큰 박스 속에 나타내는 것을 밸류박스(value box)라고 하는데, 코드 청크로 표현하지만 형식은 조금 다르다. #| content: valuebox라는 옵션이 반드시 포함되야 하며, 제목을 지정하기 위해 #| title: 옵션도 필요하다. 또한 리스트를 이용해 아이콘(icon), 컬러(color), 수치(value)를 지정해야 한다.\n아이콘은 부트스트랩 아이콘(bootstrap icon)이 사용된다. 적절한 아이콘을 찾고 그 이름을 icon = 옵션을 통해 설정하는 것이 중요하다.\n모든 컬러가 다 사용가능한 것은 아니다. 아래의 표를 참조하여 컬러를 설정해야 한다.\n\n\n표 4: 밸류박스의 컬러 선택\n\n\n\nColor Alias\nDefault Theme Color(s)\n\n\n\nprimary\nBlue\n\n\nsecondary\nGray\n\n\nsuccess\nGreen\n\n\ninfo\nBright Blue\n\n\nwarning\nYellow/Orange\n\n\ndanger\nRed\n\n\nlight\nLight Gray\n\n\ndark\nBlack\n\n\n\n\n\n\n\n3.5 예시 대시보드 만들기\n예시 대시보드(https://sangillee.quarto.pub/my-first-dashboard/)에 접속하여 구성을 살펴본다. 다음의 사항에 주목한다.\n\n내비게이션바에 서울대학교 로고가 있고, 오른쪽 맨 끝애 github 및 이메일 아이콘이 위치해 있다.\n대시보드가 네 개의 페이지(Intro, Graphs, Tables, Maps)로 나뉘어져 있고, 각 페이지마다 행, 열, 탭셋과 같은 레이아웃 요소들이 배치되어 있다.\n\n어떤 식으로 제작할 수 있을지 생각해 본다. 새로운 프로젝트를 생성하고 Quarto 다큐먼트를 생성한다. 아래는 해당 대시보드를 만들기 위해 사용된 코드이다. 참고하여 자신만의 대시보드를 만들어 본다.\n\n3.5.1 YAML 해더\n특히, nav-buttons: 옵션의 지정 형식에 주의한다. scrolling 옵션과 다양한 theme: 옵션을 시험해 본다.\n---\ntitle: \"My First Dashboard\"\nauthor: Sang-Il Lee\nformat: \n  dashboard:\n    logo: snu_logo_2.png\n    nav-buttons: \n      - icon: github\n        href: https://github.com/sangillee66\n        aria-label: GitHub\n      - icon: envelope\n        href: mailto:si_lee@snu.ac.kr\n        aria-label: Mail\n    # scrolling: true\ntheme: default\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n3.5.2 Intro 페이지\nIntro라는 이름의 페이지를 설정한다.\n# Intro\n첫번째 행: Text 카드\n행을 설정하고 행의 상대적인 높이(10%)를 지정한다.\n## Row {height=\"10%\"}\n텍스트 카드를 생성한다. 텍스트 카드를 생성하기 위해 {.card} 태그가 사용되어야 하며, 텍스트 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다.\n::: {.card title=\"Text\"}\nThis is my first dashboard.\n:::\n두번째 행의 탭셋: Histogram of GDP per capita & Table of Mean Values\n행을 설정하고 행의 상대적인 높이(70%)를 지정한다. 탭셋을 생성하기 위해 {.tabset} 태그가 사용되어야 함에 주의한다.\n## Row {.tabset height=\"70%\"}\n그래프 카드를 생성하기 위해 ggplot2 패키지를 활용한다. 그래프 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다.\n#| title: \"Histogram of GDP per capita\"\nlibrary(tidyverse)\nlibrary(gapminder)\ngapminder |&gt; \n  filter(year == 2007) |&gt;\n  ggplot(aes(x = gdpPercap)) +\n  geom_histogram()\n테이블 카드를 생성하기 위해 knitr 패키지의 kable() 함수를 활용한다. 테이블 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다.\n#| title: \"Table of Mean Values\"\nlibrary(knitr)\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  summarize(\n    GDP_percap = mean(gdpPercap),\n    Life_Exp = mean(lifeExp),\n    Population = mean(pop),\n    .by = continent\n  ) |&gt; \n  kable()\n세번째 행의 3개의 밸류박스\n행을 설정하고 행의 상대적인 높이(20%)를 지정한다.\n## Row {height=\"20%\"}\n첫번째 밸류박스를 생성한다. #| content: valuebox 옵션과 #| title: 옵션이 사용됨에 주의한다.\n#| content: valuebox\n#| title: \"Number of Countries\"\nn_countries &lt;- gapminder |&gt; distinct(country) |&gt; nrow()\nlist(\n  icon = \"asterisk\",\n  color = \"primary\",\n  value = n_countries\n)\n두번째 밸류박스를 생성한다.\n#| content: valuebox\n#| title: \"First Year\"\nfirst_year &lt;- gapminder |&gt; distinct(year) |&gt; pull() |&gt; first()\nlist(\n  icon = \"airplane\",\n  color = \"secondary\",\n  value = first_year\n세번째 밸류박스를 생성한다.\n#| content: valuebox\n#| title: \"Last Year\"\nlast_year &lt;- gapminder |&gt; distinct(year) |&gt; pull() |&gt; last()\nlist(\n  icon = \"bank\",\n  color = \"success\",\n  value = last_year\n)\n\n3.5.3 Graphs 페이지\nGraphs라는 이름의 페이지를 설정한다.\n# Graphs\n첫번째 행의 그래프 카드: GDP and Life Expectancy\n행을 설정한다.\n## Row\nggplot2 패키지를 활용하여 그래프 카드를 생성한다.\n#| title: GDP and Life Expectancy\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(aes(x = log10(gdpPercap), y = lifeExp)) +\n  geom_point(aes(color = continent), show.legend = FALSE) +\n  geom_smooth() + \n  facet_wrap(~continent, ncol = 5)\n두번째 행의 그래프 카드: Population & Life Expectancy\n첫번째 그래프(Population)를 위한 열을 설정한다.\n### Column\n그래프 카드를 생성한다.\n#| title: Population\ngapminder |&gt; \n  summarize(\n    sum_pop = sum(pop),\n    .by = c(year, continent)\n  ) |&gt; \n  ggplot(aes(x = year, y = sum_pop)) +\n  geom_area(aes(fill = continent)) +\n  labs(x = \"Year\", y = \"Population\", fill = \"Continents\")\n두번째 그래프(Life Expectancy)를 위한 열을 설정한다.\n### Column\n그래프 카드를 생성한다.\n#| title: Life Expectancy\ngapminder |&gt; \n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line(aes(color = continent, group = country)) +\n  labs(x = \"Year\", y = \"Life Expectancy\", color = \"Continents\")\n\n3.5.4 Tables 페이지\nTables라는 이름의 페이지를 설정한다.\n# Tables\n단일 행을 설정한다.\n## Row\nDT 패키지를 활용하여 테이블 카드를 생성한다.\n#| title: Lookup Table\nlibrary(DT)\ndatatable(gapminder, filter = \"top\", \n          options = list(\n            pageLength = 5, autoWidth = TRUE\n          ))\n\n3.5.5 Maps 페이지\nMaps라는 이름의 페이지를 설정한다.\n# Maps\n단일 행을 설정한다.\n## Row\nleaflet 패키지를 활용하여 지도 카드를 생성한다.\n#| title: A Reference Map \nlibrary(leaflet) \nleaflet() |&gt;  \n  addTiles()\n\n3.6 대시보드를 웹상에 배포하기\n블로그와 마찬가지로 다음의 절차에 따라 완성된 대시보드를 웹 상에 출판한다. 여기서는 Posit에서 제공하는 무료 출판 사이트인 Quarto Pub을 활용한다.\n\nQuarto Pub에 접속하여 계정을 만든다.\nRStudio에서, 왼쪽 하단부의 Terminal 탭을 누른다.\n프롬프트에 다음과 같이 입력하고 실행한다: quarto publish quarto-pub\n나머지 사항에 대해서는 조교의 도움을 받는다.",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: Quarto로 대시보드 만들기"
    ]
  },
  {
    "objectID": "exec_10_old.html",
    "href": "exec_10_old.html",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "",
    "text": "여기서는 대시보드의 구성 요소로 활용할 수 있는 다양한 시각화 기법을 익힌다. 우리는 지금까지 도표(차트, 플롯, 그래프, 테이블)를 중심으로 데이터 시각화 기법을 다루었다. 특히 ggplot2 패키지는 이러한 과정에서 핵심적인 역할을 했다. 그런데 지금까지의 모든 도표는 정적(static) 이라는 특징이 있다. 많은 경우 도표는 정적으로 표현될 수 밖에 없으며, 또한 많은 경우 도표는 정적인 것으로 충분하며, 어떤 경우에는 동적인 것보다 더 낳다.\n소통을 위한 시각화 재료로서 정적인 도표가 가지는 절대적인 중요성에도 불구하고, 상호작용성(interactivity)과 생동감(animatedness)이 부가된 도표는 어떤 상항에서는 소통의 본질적 가치를 고양하는데 많은 도움을 줄 수 있다.\n더 나아가 지금까지는 시각적 도구로서 그래프에 집중한 경향이 있다. 시각적 도구로서 지도(maps)가 가지는 가치에도 불구하고 그래프에 비해 복잡한 측면이 있기 때문에 지금까지 다루지 않았다. 그러나, “지도는 텍스트, 테이블, 챠트와 같은 것들 보다 훨씬 더 효과적으로 정보를 전달할 수 있다.”(Dougherty 와/과 Ilyankou 2021)\ngapminder 데이터를 실습의 여러 곳에서 활용할 것이다. 우선 tidyverse와 gapminder패키지를 불러온다.\n\nlibrary(tidyverse)\nlibrary(gapminder)"
  },
  {
    "objectID": "exec_10_old.html#개요",
    "href": "exec_10_old.html#개요",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "",
    "text": "여기서는 대시보드의 구성 요소로 활용할 수 있는 다양한 시각화 기법을 익힌다. 우리는 지금까지 도표(차트, 플롯, 그래프, 테이블)를 중심으로 데이터 시각화 기법을 다루었다. 특히 ggplot2 패키지는 이러한 과정에서 핵심적인 역할을 했다. 그런데 지금까지의 모든 도표는 정적(static) 이라는 특징이 있다. 많은 경우 도표는 정적으로 표현될 수 밖에 없으며, 또한 많은 경우 도표는 정적인 것으로 충분하며, 어떤 경우에는 동적인 것보다 더 낳다.\n소통을 위한 시각화 재료로서 정적인 도표가 가지는 절대적인 중요성에도 불구하고, 상호작용성(interactivity)과 생동감(animatedness)이 부가된 도표는 어떤 상항에서는 소통의 본질적 가치를 고양하는데 많은 도움을 줄 수 있다.\n더 나아가 지금까지는 시각적 도구로서 그래프에 집중한 경향이 있다. 시각적 도구로서 지도(maps)가 가지는 가치에도 불구하고 그래프에 비해 복잡한 측면이 있기 때문에 지금까지 다루지 않았다. 그러나, “지도는 텍스트, 테이블, 챠트와 같은 것들 보다 훨씬 더 효과적으로 정보를 전달할 수 있다.”(Dougherty 와/과 Ilyankou 2021)\ngapminder 데이터를 실습의 여러 곳에서 활용할 것이다. 우선 tidyverse와 gapminder패키지를 불러온다.\n\nlibrary(tidyverse)\nlibrary(gapminder)"
  },
  {
    "objectID": "exec_10_old.html#임베딩",
    "href": "exec_10_old.html#임베딩",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n1 임베딩",
    "text": "1 임베딩\n동적, 반응형 시각화를 직접 제작하는 과정을 배우기 전에 대시보드에 동적, 반응형 시각화를 실현하는 가장 쉬운 방법은 동적, 반응형 시각화가 구현되어 있는 웹사이트를 대시보드에 불러오는 것일 것이다. 이것을 임베딩(embedding)이라고 하는데, HTML의 iframe 태그를 사용한다.\n통계청의 통계놀이터는 다양한 주제에 대해 동적, 반응형 시각화를 제작하여 이용자들에게 제공하고 있다. 해당 홈페이지의 [비주얼 통계]에서 “우리나라 출생아 수와 합계 출산율의 변화”를 검색하면 동적, 반응형 시각화가 구현된 웹페이지를 볼 수 있다. [공유]를 눌러 URL을 복사하고, 아래와 같은 코드를 Quarto 문서에 삽입하면 해당 웹페이지를 임베딩할 수 있다. src=\"\" 부분에 복사한 URL를 붙여 넣는다는 것을 쉽게 알 수 있을 것이다. 여기에 다른 URL을 교체해 넣으면 대부분의 웹사이트를 임베딩할 수 있는데, 임베딩이 불가능하게 막아 뒀거나 광고가 많이 붙어 있는 웹사이트는 잘 안된다. style=\"\" 부분을 적절히 수정하면 임베딩된 웹사이트의 외견을 바꿔볼 수 있다.\n&lt;iframe src=\"https://kosis.kr/edu/share.do?shareID=S0500_16\" \nloading=\"lazy\" style=\"width: 100%; height: 600px; border: \n0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;\n\n\n\n\nOur World in Data는 아름다운 인터랙티브 시각화 자료를 제공하는 것으로 유명하다. 심지어 [공유] 버턴을 눌렀을 때 &lt;/&gt; Embed 라는 옵션이 나타나는 데, 이것을 누르면 위와 같은 iframe 태그 내용이 그대로 나타나기 때문에 복사하여 붙이기만 하면 된다. Chart 탭 뿐만 아니라 Table 탭과 Map 탭도 있으니 눌러서 내용을 확인할 수 있다. 아마도 ECharts 자바스크립트 라이브러리를 사용한 것으로 보인다.\n&lt;iframe src=\"https://ourworldindata.org/grapher/child-mortality?time=earliest..latest&tab=chart\" \nloading=\"lazy\" style=\"width: 100%; height: 600px; border: 0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;\n\n\n\n\n\n\n그림 1: 임베딩 사례: Our World in Data\n\n\nOur World in Data에서 제공하는 다양한 인터랙티브 시각화 자료를 임베딩하는 절차를 요약하면 다음과 같다.\n\nOur World in Data에 접속한다.\n첫 화면의 하단에 있는 ’Data explorers’의 네 개 박스로 이동한다. 인구 관련 데이터에 관심이 있다면 ’Population & Demography’를 선택한다.\n’Population & Demography Data Explorer’에서 제공된 다양한 옵션을 이용해 원하는 인터랙티브 시각화 자료를 완성한다.\n‘Share’를 클릭하고’&lt;/&gt; Embed’를 선택한 후 URL을 복사한다. 흥미로운 점은 위에서 어떤 옵션을 어떻게 설정했느냐에 따라 URL이 달라진다는 사실이다.\niframe 태그의 “src=”에 붙여 넣어 임베딩을 완수한다."
  },
  {
    "objectID": "exec_10_old.html#테이블",
    "href": "exec_10_old.html#테이블",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n2 테이블",
    "text": "2 테이블\n우리는 지금까지 테이블(table)의 중요성에 대해 거의 다루지 않았다. 그러나 상호작용형 테이블 혹은 대화형 테이블이 되었을 때, 많은 경우, 테이블은 가장 효과적인 정보 전달 도구가 된다. 특히, 데이터 변형하기를 통해 새로운 요약 테이블을 생성하고, 그것을 대화형으로 제시하는 것은 매우 중요한 데이터사이언스의 과정이다. 여기서는 DT 패키지를 활용하여 간단한 인터랙티브 테이블을 만들어 본다. 웹에서 인터렉티브 테이블을 생성할 수 있게 해주는 다양한 종류의 JavaScript 라이브러리가 존재한다. 예를 들어 DataTables, FlexTable, React Table 등이 있는데, DT 패키지는 DataTables를 쓸 수 있게 해주는 래퍼 패키지이다.\n\nlibrary(DT)\n\n그리고 gapminder 데이터를 datatable() 함수를 통해 불러온다.\n\ndatatable(gapminder)\n\n\n\n\n\n\n결과를 좀 더 크게 보기 위해, ‘Render’ 버튼 바로 오른편에 있는 아이콘을 클릭해 ’Chunk Output in Console’를 선택할 수 있다. 결과 테이블을 이리저리 살펴본다. 언뚯 보면 View() 함수를 활용해 데이터프레임을 살펴보는 것과 유사한 것처럼 보이지만, 부가적인 기능이 제공된다.\nDT 패키지는 테이블의 상호작용성과 관련하여 몇 가지 기능을 제공한다.\n\nPagination: 페이지를 이동할 수 있는 기능\nInstant search: 즉각적인 찾기 기능(Search에 타이핑하기 시작하면 즉각적으로 검색 결과 보여줌)\nMulti-column ordering: 다중 컬럼 정렬 기능(컬럼 하나를 선택한 후 ctrl을 누른 상태에서 다른 컬럼을 선택)\nFiltering: 값을 정렬할 수 있는 기능\nEditable: 셀 값을 수정할 수 있는 기능\nButtons: 셀 숨기기, CSV, PDF, XLSX 등의 확장자로 내보내기 등을 수행하는 버튼 생성 기능\n\n그 중 몇 가지 기능을 여기에서 살펴본다. 자세한 사항은 DT 패키지 홈페이지에 잘 정리되어 있다.\n\n2.1 테이블 CSS 클래스\ndatatable() 함수의 class 인수를 통해 테이블의 외관을 바꿀 수 있다. 다음과 같은 옵션이 가능하다.\n\n\n\n\n\n\nClass name\nDescription\n\n\n\ndisplay\n\nstripe, hover, row-border, order-column을 동시 적용한 디폴트\n\n\ncell-border\n모든 셀의 상하좌우에 경계선 표시\n\n\ncompact\n여백 축소\n\n\nhover\n마우스의 위치에 따라 점멸 효과\n\n\nnowrap\n줄바꿈 없이 텍스트 표시\n\n\norder-column\n정렬의 키가 되는 컬럼에 하이라이트 표시\n\n\nrow-border\n행별 경계선 표시\n\n\nstripe\n행을 스트라이프로 표시\n\n\n\n아래와 같이 cell-border과 compact를 함께 실행해 보고 테이블의 변화를 확인한다.\n\ndatatable(head(gapminder), class = \"cell-border compact\")\n\n\n\n\n\n\n또한 특정 컬럼의 정렬 방식(왼편, 오른편, 중앙)을 변경할 수 있다. 사용가능한 옵션은 다음과 같다.\n\n\nClass name\nDescription\n\n\n\ndt[-head|-body]-left\n왼편 정렬\n\n\ndt[-head|-body]-center\n가운데 정렬\n\n\ndt[-head|-body]-right\n오른편 정렬\n\n\ndt[-head|-body]-justify\n양쪽 맞춤\n\n\ndt[-head|-body]-nowrap\n줄바꿈 없는 맞춤\n\n\n\n아래는 첫 번째와 두 번째 컬럼(country, continent)의 내용(body)을 가운데 정렬로 나타낸다.\n\ndatatable(head(gapminder),\n          options = list(\n            columnDefs = list(list(className = \"dt-body-center\", targets = 1:2))\n          ))\n\n\n\n\n\n\n2.2 테이블 에디팅\neditable 인수를 통해 테이블의 값을 수정할 수 있게 만들 수 있다. 테이블의 특정 셀에 더블클릭하면 수정할 수 있다.\n\ndatatable(head(gapminder), editable = \"cell\")\n\n\n\n\n\n\n2.3 컬럼 필터\n다음과 같은 방식으로 필터를 설정할 수 있다.\n\ndatatable(gapminder, filter = \"top\", \n          options = list(\n            pageLength = 5, \n            autoWidth = TRUE\n          ))\n\n\n\n\n\n\n2.4 버튼 기능\nextenstion에 Buttons, dom에 Bftip, buttons에 c(\"copy\", \"excel\", \"pdf\", \"print\")를 입력하면 버튼 기능을 활성화할 수 있다. 각 인수가 무엇을 의미하는지는 다음의 웹사이트를 참고할 수 있다.\n\ndatatable(gapminder, filter = \"top\",\n          extensions = \"Buttons\",\n          options = list(\n            pageLength = 5,\n            autoWidth = TRUE,\n            dom = \"Bfrtip\",\n            buttons = c(\"copy\", \"excel\", \"pdf\", \"print\")\n          ))"
  },
  {
    "objectID": "exec_10_old.html#그래프",
    "href": "exec_10_old.html#그래프",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n3 그래프",
    "text": "3 그래프\n\n3.1 인터랙티브 그래프\n인터랙티브 시각화 도구로 최근 널리 각광을 받고 있는 Plotly이다. Plotly는 사실 캐나다 퀘백에 본사를 두고 있는 데이터 시각화 전문 회사 이름이다. 그러나 보통 데이터 시각화용 JavaScript 라이브러리를 일컽는다. 이 라이버러리는 다양한 오픈소스 프로그래밍 언어에서 사용가능하며(이기준 2023), R의 랩퍼 프로그램이 plotly 패키지이다.\n\nlibrary(plotly)\n\ngapminder 데이터를 이용하여 간단한 그래프를 그려보자. 문법이 ggplot2와 크게 다르지 않음을 알 수 있다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  plot_ly(x = ~gdpPercap, y = ~lifeExp, color = ~continent,\n          text = ~paste(\"Country: \", country, \n                        \"&lt;br&gt;GDP per capita: \", gdpPercap, \n                        \"$&lt;br&gt;Life Expectancy at Birth:\", lifeExp))\n\n\n\n\n\n\n줌(zoom), 팬(pan), 박스 선택(box select), 라소 선택(Lasso select), 줌인(zome in), 줌 아웃(zoom out) 등과 같은 상호작용 기능을 확인할 수 있다. 또 그래프 상의 데이터 포인트 위에 마우스를 올리면 text 인수를 통해 설정한 내용을 볼 수 있다. 그리고 범례를 클릭하면 특정 continent의 국가를 나타나지 않게 할 수 있다.\n이와 같이 plotly 패키지를 직접 사용하면 다양한 기능을 활용할 수 있겠지만, plotly 패키지가 제공하는 ggplotly() 함수를 활용하면 ggplot2로 만들어진 그래프를 단숨에 plotly 그래프로 바꿀 수 있다. 물론 정확히 같지는 않다.\n\nP &lt;- gapminder |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() + \n  scale_color_brewer(palette = \"Set2\") +\n  theme_minimal()\nggplotly(P)\n\n\n\n\n\n\n다음 예제 역시 반응형이지만 바로 다음에서 다룰 동적인 특성도 동시에 가지고 있는 그래프를 만드는 것이다. 역시 plotly 패키지를 이용한다.\n\ngapminder |&gt; \n  plot_ly(x = ~log10(gdpPercap), y = ~lifeExp,\n          text = ~paste(\"Country: \", country)) |&gt; \n  add_markers(color = ~continent, size = ~pop, frame = ~year, \n              marker = list(sizeref = 0.2, sizemode = \"area\"))\n\n\n\n\n\n\n하단에 있는 ‘Play’ 버튼을 누르면 연도에 따라 그래프가 바뀌면서 동적인 효과가 나타나게 된다.\n\n3.2 애니메이션 그래프\n이 실습에서는 gganimate 패키지를 활용하여, 움직이는 그래프를 만드는 방법을 익히도록 한다. 물론 움직인다고 해서 인터랙티브한 그래프인 것은 아니다. gganimate 패키지를 설치한 후 불러온다.\n\nlibrary(gganimate)\n\n우선 정적인 그래프를 그린다.\n\nP &lt;- gapminder |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, color = continent)) +\n  geom_point(show.legend = FALSE, alpha = 0.7) +\n  scale_x_log10() +\n  scale_size(range = c(2, 12))\nP\n\n\n\n\n\n\n\n이 그래프는 두 변수 간에 양적인 관련성이 있다는 사실은 명백히 보여주지만, 데이터 변형의 측면에서는 잘못된 것이다. 모든 연도(1952~2007년간 5년 단위)가 나타나 있어서 한 국가가 그래프에 12번 등장한다.\n이를 해결하기 위해 ggplot2 패키지의 facet_wrap() 함수를 활용한다.\n\nP + facet_wrap(~year)\n\n\n\n\n\n\n\n이 그래프는 두 변수간의 양적인 상관관계가 12개 모두의 연도에서 나타난다는 사실을 명확히 보여준다. 그러나 그래프를 세세히 살펴보면 알 수 있듯이, 두 변수의 관련성이라는 측면에서 개별 국가가 시간의 흐름에 따라 어떻게 변화해 나가는지에 대한 사항을 파악하기는 매우 어렵다.\ngganimate 패키지의 transition_time() 함수를 활용하여 동적인 그래프를 작성해 본다.\n\nP + transition_time(year) +\n  labs(title = \"Year: {frame_time}\")\n\n\n\n\n\n\n\n대륙별로 분할하여 표현할 수도 있다.\n\nP + facet_wrap(~continent) +\n  transition_time(year) +\n  labs(title = \"Year: {frame_time}\")\n\n\n\n\n\n\n\n움직임을 조금 더 역동적이게 만들어 볼 수 있다.\n\nP + transition_time(year) +\n  labs(title = \"Year: {frame_time}\") +\n  shadow_wake(wake_length = 0.1, alpha = FALSE)\n\n\n\n\n\n\n\n그래프를 저장하고 싶으면 anim_save() 함수를 활용할 수 있다. ggsave() 함수와 동일한 문법을 갖는다."
  },
  {
    "objectID": "exec_10_old.html#지도",
    "href": "exec_10_old.html#지도",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n4 지도",
    "text": "4 지도\n\n4.1 벡터 데이터와 sf 패키지\n지도는 간단히 말해 지리공간적(geospatial) 데이터를 그래픽 형태로 나타낸 것이다. 따라서 지리공간적 데이터를 이해하는 것이 지도 제작의 시발점이 되어야 한다. 지리공간적 데이터는 GIS적 관점에서 벡터(vector) 데이터와 래스터(raster) 데이터로 나뉜다. 벡터 데이터는 지리공간적 사상의 기하학적 형태(형상 데이터)와 그것의 다양한 특성(속성 데이터)을 담고 있는 데이터이다.\n벡터 데이터는 지리공간적 사상을 포인트, 라인, 폴리곤 피처로 구분하고, 개별 피처를 형태와 위치를 개별 피처를 구성하고 있는 버택스의 좌표값을 저장함으로써 구현하는데, 이러한 정보를 담고 있는 것을 형상 데이터라고 한다. 예를 들어 우리나라 17개 시도에 대한 디지털 행정구역도가 여기에 해당한다. 이에 반해 속성 데이터는 포인트, 라인, 폴리곤 등으로 재현된 개별 피처의 다양한 특성을 가지고 있는 것으로 보통 테이블 데이터라고 한다. 예를 들어, 우리나라 17개 시도의 인구수, 인구성장률, 순이동률과 같은 것이다. 형상 데이터가 지리공간적 데이터의 특수성을 더 잘 반영하기 때문에 보통 형상 데이터를 공간 데이터라고도 하면, 벡터 데이터에서는 이 두 종류의 데이터가 기본적으로 독립적이며 보통은 느슨한 형태로 결합되어 있다.\n이에 반해 래스터 데이터는 세상을 동일한 크기의 수 많은 그리드 셀(grid cell)로 구성되어 있다고 보며, 개별 그리드 셀에 속성이 저장되어 있는 데이터를 의미한다. 가장 쉬운 예가 인공위성 영상이다. 인공위성 영상의 특정한 공간해상도를 가진 픽셀로 나뉘어져 있고, 개별 픽셀에 특정한 값(특정한 밴드의 반사값)이 들어가 있다. 따라서 래스터 데이터는 벡터 데이터처럼 형상 데이터와 속성 데이터가 분리되어 있는 것이 아니라 일체형이다. 특수한 경우가 아니라면 하나의 래스터 파일에는 하나의 속성만이 들어가 있다. 이에 반해 벡터 데이터의 속성 파일에는 수많은 변수가 포함될 수 있다.\n지도 제작의 원칙은 동일하지만, 지도로 나타낼 데이터가 벡터 데이터인지 래스터 데이터인지에 혹은 둘 다인지에 따라 지도화의 세부 절차는 달라질 수 있다. 여기서는 벡터 데이터에 기반한 지도 제작에 집중하고자 한다. 속성 데이터는 기본적으로 R의 데이터 프레임과 동일한 개념이므로, 데이터사이언스의 기본 과정을 통해 불러오고, 정돈하고, 변형할 수 있다. 따라서 보다 중요한 것은 형상 데이터를 다루는 것이다.\n벡터 데이터 포맷, 보다 정확하게는 형상 데이터의 포맷으로 가장 널리 사용되고 있는 것이 셰이프 파일(shape file)이다. 셰이프 파일(확장자가 .shp인 파일)은 전세계에서 가장 큰 GIS 회사인 ESRI가 오래전에 개발한 벡터 데이터 포맷으로, 현재 표준 포맷의 역할을 하고 있다. 그런데 셰이프 파일은 동일한 이름을 공유하지만 확장자가 서로 다른 몇 개의 파일의 묶음을 지칭한다는 점을 이해할 필요가 있다. 반드시 다음의 네 파일을 함께 가지고 있어야 한다.\n\n*.shp: 버텍스의 좌표값이 포함된 핵심 파일\n*.dbf: 기본 속성 파일\n*.shx: 공간적 인덱싱 파일\n*.prj: 투영 정보 파일\n\n마지막의 *.prj 파일은 없어도 지도로 나타날 수는 있다. 그러나 다른 셰이프 파일과 함께 지도로 나타내거나 축척막대와 같은 지도 요소를 적절하게 나타내기 위해서는 좌표참조계(CRS) 정보가 포함된 *.prj 파일은 가질 필요가 있다.\nR에서 형상 데이터를 다루는데 있어 거의 표준처럼 사용되고 있는 것이 sf 패키지이다. 기본적으로는 셰이프 파일을 불러오기 위한 st_read() 함수를 주로 사용하게 되겠지만, sf 패키지는 벡터-기반 GIS 오퍼레이션을 위한 폭넓은 함수를 제공한다. 중요한 것을 정리하면 다음과 같다.\n\n\n\n\n\n\n\n구분\n함수\n설명\n\n\n\n읽고 쓰기\n\nst_read()\nread_sf()\n\n셰이프 파일 읽어 들이기\n\n\n\nst_write()\n셰이프 파일 저장\n\n\n투영 관련\nst_crs()\nCRS 정보 확인\n\n\n\nst_transform()\nCRS 바꾸기\n\n\n기하 측정\nst_area()\n면적 계산\n\n\n\nst_length()\n길이 계산\n\n\n\nst_perimeter()\n둘레 계산\n\n\n\nst_distance()\n거리 계산\n\n\n기하 변형\nst_centroid()\n센트로이드 생성\n\n\n\nst_buffer()\n버퍼 생성\n\n\n\nst_boundary()\n가장자리 추출\n\n\n\nst_simplify()\n선 피처 단순화 실행\n\n\n기하 생성\nst_point()\n포인트 피처 생성\n\n\n\nst_vironoi()\n보로노이 폴리곤 생성\n\n\n\nst_convex_hull()\n컨벡스 헐 생성\n\n\n\nst_make_grid()\n규칙 그리드 생성\n\n\n기하 검토\nst_is_valid()\n지오메트리가 밸리드한지 여부 검토\n\n\n\nst_make_valid()\n지오메트리를 밸리드하게 만들기\n\n\n기하 중첩\nst_intersection()\n기하 교집합 중첩\n\n\n\nst_union()\n기하 합집합 중첩\n\n\n\nst_crop()\n기하 크롭 중첩\n\n\n기타\nst_coordinates()\n버택스 좌표값 반환\n\n\n\nst_cast()\n다른 피처 유형으로 변환\n\n\n\nst_as_sf()\nsf 객체로 변환\n\n\n\nst_graticule()\n그래티큘 생성\n\n\n\nst_join()\n공간적 조인 실행\n\n\n\n래스터 데이터를 다루는데는 terra 패키지가 가장 널리 사용되고 있으며, stars패키지가 최근 많은 주목을 받고 있다. stars 패키지와 sf 패키지는 모두 에트저르 페베스마(Edzer Pebesma)가 만들었다. 두 패키지에 대한 설명은 페베스마와 로저 비번드(Roger Bivand)가 함께 쓴 ’R을 활용한 공간데이터사이언스(Spatial Data Science With Applications in R)’에 잘 나타나 있다(Pebesma 와/과 Bivand (2023))\n\n4.2 정적 지도 제작\n\n4.2.1 세계 지도\nggplot2 패키지를 이용하여 정적 지도를 그려본다. ggplot2패키지로 지도를 그린다는 것은 ’지도도 그래프다.’라는 접근법에 기반하고 있다. ggplot2의 문법을 지도 제작으로 확장할 수 있고, 막강한 생태계를 고려할 때 충분히 이점이 있는 접근법이다.\n데이터는 지난 실습에서 사용한 WPP 2024(World Population Prospects 2024)이다. 2024년 전세계 국가별 TFR(Total Fertility Rate, 합계출산율) 지도를 그려본다.\n벡터 데이터를 활용한 지도는 형상 데이터와 속성 데이터를 결합해야만 제작할 수 있다. 여기서 형상 데이터는 전세계 국가 경계 데이터이고, 속성 데이터는 TFR이 포함된 WPP 2024 데이터이다. 형상 데이터는 spData 패키지에 들어 있는 world 객체를 사용한다. 벡터 형식의 데이터는 sf 패키지의 st_as_sf() 함수를 통해 sf 객체로 변환하는 것이 좋다.\n\nlibrary(spData)\nlibrary(sf)\ndata(world)\nworld &lt;- st_as_sf(world)\n\nWPP 2024 데이터를 불러와 2025년만 골라낸다.\n\nwpp_2024 &lt;- read_rds(\"wpp_2024.rds\")\nmy_wpp &lt;- wpp_2024 |&gt; \n  filter(year == 2025)\n\n두 데이터를 left_join() 함수를 이용하여 결합한다. 벡터 데이터의 경우는 늘 반드시 형상 데이터를 중심에 두고 left_join() 함수를 통해 속성 데이터를 불러와 합체해야 한다.\n\nworld_data &lt;- world |&gt;\n  left_join(my_wpp, join_by(iso_a2 == ISO2))\n\n로빈슨 도법(Robinson projection)의 지도를 제작한다. ggplot2 패키지로 지도를 그리는 가장 좋은 방법은 기하객체 함수인 geom_sf()와 좌표 변환 함수인 coord_sf()를 결합하는 것이다. scale_x_continuous()와 scale_y_continuous()의 내용은 그래티큘(경위선망)을 원하는 방식대로 지도에 포함시키기 위한 것이다. 그래프를 world_map이라는 이름의 객체로 저장하는 것은 뒤에서 이 지도를 사용하기 때문이다.\n\nworld_map &lt;- ggplot() +\n  geom_sf(data = world_data, aes(fill = TFR, text = name_long)) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_fill_viridis_c() +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.5, seq(-60, 60, 30), 89.5)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\nworld_map\n\n\n\n\n\n\n\n\n4.2.2 우리나라 지도\n우리나라 지도도 그려본다. ’Lab07: 데이터 수집하기’에서 KOSIS의 API를 통해 수집, 정리한 시군구 단위 지역소멸위험지수를 지도화한다. 우선 우리나라 시군구 행정 경계에 대한 도형(형상, 기하) 데이터가 필요하다. GADM(Database of Global Administrative Areas)는 전 세계 국가별, 행정구역 수준별, 고해상도 디지털 경계 파일을 제공한다. 직접 웹사이트를 방문해 파일을 다운로드할 수도 있지만, 여기서는 geodata 패키지의 도움을 받는다. geodata 패키지는 정말 다양한 종류의 공간 데이터를 쉽게 다운로드할 수 있게 도와준다. 1레벨인 시도 단위와 2레벨인 시군구 단위를 다운받는다. path 아규먼트가 반드시 필요한데, 프로젝트 파일의 폴더도 좋고, 앞으로 geodata 패키지를 통해 다운받을 데이터를 모아둘 곳을 따로 정해두어도 좋다. 그렇지만 할당 연산자를 통해 이름을 부여하면 따로 다운로드된 파일을 다시 부르는 수고는 하지 않아도 된다.\n\nlibrary(geodata)\nlibrary(tmap)\n\nkorea_sd &lt;- gadm(country = \"South Korea\", level = 1, path = \"D:/My R/Geodata/\")\nkorea_sd &lt;- korea_sd |&gt; \n  st_as_sf()\nkorea_sgg &lt;- gadm(country = \"South Korea\", level = 2, path = \"D:/My R/Geodata/\")\nkorea_sgg &lt;- korea_sgg |&gt; \n  st_as_sf()\n\n그런데 파일을 열어보고서 경악한다. 행정구역 코드가 없다. 그래서 이 방법은 포기한다.\n행정구역 파일은 통계청의 통계지리정보서비스에서 구할 수 있다. 다운받는 방법을 익히면 좋겠지만, 시간 절약을 위해 다운받아 정리한 파일을 그냥 제공한다. 프로젝트 폴더에 파일을 저장한 후, 아래의 코드를 통해 불러온다.\n\nsido_shp &lt;- st_read(\"sido.shp\", options = \"ENCODING=CP949\")\nsigungu_shp &lt;- read_sf(\"sigungu.shp\", options = \"ENCODING=CP949\")\n\n두 파일에 대해 서로 다른 함수를 적용한 것을 알 수 있다. st_read() 함수는 가장 보편적으로 사용되는 것으로 불러올 때마다 파일에 대한 정보(지오메트리 유형, 바운딩 박스, CRS 등)가 자동으로 디스플레이된다. 이러한 정보는 항상 유익한 것이지만 보이지 않게 하고 싶을 수도 있다. 이 때 read_sf() 함수를 사용할 수 있다.\n불러들인 파일을 바탕으로 시군구 경계를 그려본다. 지도 제작 전문 패키지인 tmap의 qtm() 함수를 이용하여 시군구 경계에 대한 지도를 빠르게 그려본다. tmap패키지로 지도를 그린다는 것은 ’지도는 지도다.’라는 접근법에 기반하고 있다. tmap의 문법을 새로 배워야 한다는 단점이 있긴 하지만, 지도는 그래프로 환원될 수 없는 고유한 특성이 있고, tmap패키지는 이러한 지도의 고유한 특성을 잘 반영하고 있다. 좀 더 복잡한 tmap의 문법을 사용한 지도 제작은 맨 뒤에서 다루기로 한다.\n\nlibrary(tmap)\nqtm(sigungu_shp)\n\n\n\n\n\n\n\n지역소멸위험지수 데이터를 불러온다. 아래 코드는 지난번 실습 때 rds 파일 포맷으로 저장해 둔 것을 가정한 것이다. 실습의 편의를 위해 파일을 제공하니 프로젝트 폴더에 저장한 후, 아래의 코드를 통해 불러온다.\n\ndata_sigungu &lt;- read_rds(\"data_sigungu.rds\")\n\n도형 데이터(korea_sgg)와 속성 데이터(data_sigungu)를 공통 키(key)를 활용하여 결합한다.\n\nsigungu_data &lt;- sigungu_shp |&gt; \n  left_join(\n    data_sigungu, join_by(SGG1_CD == C1)\n  )\n\n이제 ggplot2 패키지를 이용하여 지도를 제작한다. ’Lab07: 데이터 수집하기’에서 인구소멸위험지수의 시도별 그래프를 제작한 것과 비교해 보라. 그 유사함에 깜짝 놀랄 수도 있다. ggplot2에서는 그래프와 지도의 구분이 없다. 이것은 ggplot2의 장점이자 단점이다.\n\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index_class = case_when(\n      index &lt; 0.2 ~ \"1\",\n      index &gt;= 0.2 & index &lt; 0.5 ~ \"2\",\n      index &gt;= 0.5 & index &lt; 1.0 ~ \"3\",\n      index &gt;= 1.0 & index &lt; 1.5 ~ \"4\",\n      index &gt;= 1.5 ~ \"5\"\n    ),\n    index_class = fct(index_class, levels = as.character(1:5))\n  )\n\nclass_color &lt;- c(\"1\" = \"#d7191c\", \"2\" = \"#fdae61\",\n                 \"3\" = \"#ffffbf\", \"4\" = \"#a6d96a\", \n                 \"5\" = \"#1a9641\")\nggplot() +\n  geom_sf(data = sigungu_data, aes(fill = index_class), show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(name = \"Classes\", \n                    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \n                               \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n                    values = class_color, drop = FALSE) \n\n\n\n\n\n\n\n\n4.3 인터랙티브 지도 제작\n위에서 사용한 plotly 패키지의 ggplotly() 함수를 활용하면 반응형 지도를 생성할 수 있다. 앞의 코드 둘째 줄에 aes()에 text = name_long이 설정되어 있는데, 마우스로 국가를 가리킬 때 이름이 나타날 수 있게 조치한 것이다.\n\nggplotly(world_map)\n\n\n\n\n\n지도 위에서 plotly 가 제공하는 다양한 기능을 적용해 볼 필요가 있다. 인터랙티브 그래프에 비해 인터랙티브 지도의 유용성이 더 높아 보인다.\n우리나라 지도는 다른 방식으로 반응형으로 만들어 본다. 여기서는 ggiraph 패키지를 사용한다. 처음 사용하는 경우라면 먼저 패키지를 인스톨해야 한다. 코드의 전반부는 커서를 특정 시군구 위에 올렸을 때 나타나는 정보를 좀 더 다양하게 하려는 조치이다. 중간의 코드가 핵심인데, 찬찬히 살펴보면 그렇게 복잡하지 않다. 마지막은 완전히 지엽적인 것인데, 커서를 특정 시군구 위에 올렸을 때 색이 회색으로 변하게 하기 위한 것이다.\n\nlibrary(ggiraph)\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = format(index, digits = 4, nsmall = 4),\n    my_tooltip = str_c(\"Name: \", SGG1_FNM, \"\\n Index: \", index)\n  )\ngg &lt;- ggplot() +\n  geom_sf_interactive(\n    data = sigungu_data, \n    aes(\n      fill = index_class, \n      tooltip = my_tooltip, \n      data_id = SGG1_FNM\n      ), \n    show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(\n    name = \"Classes\", \n    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n    values = class_color, drop = FALSE) \ngirafe(ggobj = gg) |&gt; \n  girafe_options(\n    opts_hover(css = \"fill: gray\")\n  )\n\n\n\n\n\n그러나 반응형 지도 제작에 가장 널리 쓰이는 것은 leaflet이다. leaflet은 웹 상의 반응형 지도 제작에 특화된 JavaScript 라이브러리이다. 이 라이브러리를 R에서 쓸 수 있게 도와주는 래퍼 패키지가 leaflet 패키지이다. 패키지 홈페이지가 매우 상세하게 잘 되어 있다. 숙독하기를 권한다.\n\nlibrary(leaflet)\n\n매우 단순한 인터랙티브 지도를 만들어 본다. 자신이 원하는 경위도값과 설명문으로 수정하면 된다.\n\nleaflet() |&gt; \n  addTiles() |&gt; \n  addPopups(126.955184, 37.460422, \"Sang-Il's Office\",\n            options = popupOptions(closeButton = FALSE))\n\n\n\n\n\n\n위에서 작성했던 TFR 세계지도를 leaflet 패키지의 다양한 함수와 아규먼트를 활용하여 인터랙티브 지도를 제작해 본다.\n\nworld_data &lt;- world_data |&gt; filter(!is.na(TFR))\n\nbins &lt;- c(0, 1.5, 2.1, 3, 4, 5, Inf)\npal &lt;- colorBin(\"YlOrRd\", domain = world_data$TFR, bins = bins)\nlabels &lt;- sprintf(\"&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g\",\n  world_data$name_long, world_data$TFR) |&gt; lapply(htmltools::HTML)\n\nleaflet(world_data) |&gt; \n  addProviderTiles(providers$Esri.WorldTopoMap) |&gt; \n  addPolygons(\n    fillColor = ~pal(TFR),\n    weight =  2, \n    opacity = 1,\n    color = \"white\",\n    dashArray = \"3\",\n    fillOpacity = 0.6,\n    highlightOptions = highlightOptions(\n      weight = 5,\n      color = \"#666\",\n      dashArray = \"\",\n      fillOpacity = 0.6,\n      bringToFront = TRUE),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n      textsize = \"15px\",\n      direction = \"auto\")\n  ) |&gt; \n  addLegend(\n    pal = pal, values = ~TFR, opacity = 0.6, title = NULL,\n    position = \"bottomright\"\n  )\n\n\n\n\n\n\n우리나라 시군구 단위의 인구소멸위험지수에 대한 지도를 반응형으로 만들어 본다. 여기서는 tmap을 활용한다. 해당 시군구 위에 클릭하면 지역소멸위험지수가 나타난다.\n\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = as.numeric(index)\n  )\ntmap_mode(mode = \"view\")\nmy_tmap &lt;- tm_shape(sigungu_data) + \n  tm_polygons(\n    col = \"index\",\n    palette = class_color, \n    breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n    labels = c(\"&lt; 0.2\", \"0.2~0.5\", \"0.5~1.0\", \"1.0~1.5\", \"&gt;= 1.5\"),\n    title = \"Classes\", \n    popup.vars=c(\"지역소멸위험지수: \" = \"index\"), \n    popup.format = list(index = list(digits = 3)), \n    id = \"SGG1_FNM\", \n    alpha = 0.6, \n    border.alpha = 0.5\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 2)\nmy_tmap\n\n\n\n\n\ntmap_save(my_tmap, \"지방소멸위험지수.html\")"
  },
  {
    "objectID": "exec_12.html",
    "href": "exec_12.html",
    "title": "R과 데이터사이언스 과정",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 전 과정을 개괄적으로 이해하도록 한다. 특히 그림 1 에 나타나 있는 데이터사이언스 과정 중 특히 네 부분, 데이터 불러오기(importing), 정리하기(tidying), 변형하기(transforming), 시각화하기(visualizing)에 초첨을 둔다. 보통 데이터 정리하기와 변형하기를 합쳐 ’데이터와 씨름하기(data wrangling)’이라고 부르고, 변형하기와 시각화하기를 합쳐 ’데이터 탐색하기(data exploration)’라고 한다. 데이터를 살펴보기 위해 모델링을 사용하는 경우, 일부 모델링하기도 탐색하기에 포함되는 것으로 볼 수도 있다.\n\n\n\n\n\n그림 1: 데이터사이언스의 과정(https://r4ds.hadley.nz/intro.html)\n\n\n데이터사이언스의 다양한 과업을 수행하기 위해 Base R의 함수들이 사용되고 있지만, 보통은 이와 함께 다양한 패키지(package)들이 널리 사용되고 있다. 따라서 본 실습에서는 우선 패키지의 사용과 관련된 부분을 다루고 뒤를 이어 데이터사이언스의 네 과제가 어떻게 이루어지는지 대략적으로 다룰 것이다.\n\n패키지와 tidyverse\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기"
  },
  {
    "objectID": "exec_12.html#개요",
    "href": "exec_12.html#개요",
    "title": "R과 데이터사이언스 과정",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 전 과정을 개괄적으로 이해하도록 한다. 특히 그림 1 에 나타나 있는 데이터사이언스 과정 중 특히 네 부분, 데이터 불러오기(importing), 정리하기(tidying), 변형하기(transforming), 시각화하기(visualizing)에 초첨을 둔다. 보통 데이터 정리하기와 변형하기를 합쳐 ’데이터와 씨름하기(data wrangling)’이라고 부르고, 변형하기와 시각화하기를 합쳐 ’데이터 탐색하기(data exploration)’라고 한다. 데이터를 살펴보기 위해 모델링을 사용하는 경우, 일부 모델링하기도 탐색하기에 포함되는 것으로 볼 수도 있다.\n\n\n\n\n\n그림 1: 데이터사이언스의 과정(https://r4ds.hadley.nz/intro.html)\n\n\n데이터사이언스의 다양한 과업을 수행하기 위해 Base R의 함수들이 사용되고 있지만, 보통은 이와 함께 다양한 패키지(package)들이 널리 사용되고 있다. 따라서 본 실습에서는 우선 패키지의 사용과 관련된 부분을 다루고 뒤를 이어 데이터사이언스의 네 과제가 어떻게 이루어지는지 대략적으로 다룰 것이다.\n\n패키지와 tidyverse\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기"
  },
  {
    "objectID": "exec_12.html#지리공간적-데이터와-지도",
    "href": "exec_12.html#지리공간적-데이터와-지도",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n1 지리공간적 데이터와 지도",
    "text": "1 지리공간적 데이터와 지도\n\n1.1 벡터와 래스터 데이터\n지도는 간단히 말해 지리공간적(geospatial) 데이터를 그래픽 형태로 나타낸 것이다. 따라서 지리공간적 데이터를 이해하는 것이 지도 제작의 시발점이 되어야 한다. 지리공간적 데이터는 GIS적 관점에서 벡터(vector) 데이터와 래스터(raster) 데이터로 나뉜다. 벡터 데이터는 지리공간적 사상의 기하학적 형태(형상 데이터)와 그것의 다양한 특성(속성 데이터)을 담고 있는 데이터이다.\n벡터 데이터는 지리공간적 사상을 포인트, 라인, 폴리곤 피처로 구분하고, 개별 피처를 형태와 위치를 개별 피처를 구성하고 있는 버택스의 좌표값을 저장함으로써 구현하는데, 이러한 정보를 담고 있는 것을 형상 데이터라고 한다. 예를 들어 우리나라 17개 시도에 대한 디지털 행정구역도가 여기에 해당한다. 이에 반해 속성 데이터는 포인트, 라인, 폴리곤 등으로 재현된 개별 피처의 다양한 특성을 가지고 있는 것으로 보통 테이블 데이터라고 한다. 예를 들어, 우리나라 17개 시도의 인구수, 인구성장률, 순이동률과 같은 것이다. 형상 데이터가 지리공간적 데이터의 특수성을 더 잘 반영하기 때문에 보통 형상 데이터를 공간 데이터라고도 하면, 벡터 데이터에서는 이 두 종류의 데이터가 기본적으로 독립적이며 보통은 느슨한 형태로 결합되어 있다.\n이에 반해 래스터 데이터는 세상을 동일한 크기의 수 많은 그리드 셀(grid cell)로 구성되어 있다고 보며, 개별 그리드 셀에 속성이 저장되어 있는 데이터를 의미한다. 가장 쉬운 예가 인공위성 영상이다. 인공위성 영상의 특정한 공간해상도를 가진 픽셀로 나뉘어져 있고, 개별 픽셀에 특정한 값(특정한 밴드의 반사값)이 들어가 있다. 따라서 래스터 데이터는 벡터 데이터처럼 형상 데이터와 속성 데이터가 분리되어 있는 것이 아니라 일체형이다. 특수한 경우가 아니라면 하나의 래스터 파일에는 하나의 속성만이 들어가 있다. 이에 반해 벡터 데이터의 속성 파일에는 수많은 변수가 포함될 수 있다.\n지도 제작의 원칙은 동일하지만, 지도로 나타낼 데이터가 벡터 데이터인지 래스터 데이터인지에 혹은 둘 다인지에 따라 지도화의 세부 절차는 달라질 수 있다. 여기서는 벡터 데이터에 기반한 지도 제작에 집중하고자 한다. 속성 데이터는 기본적으로 R의 데이터 프레임과 동일한 개념이므로, 데이터사이언스의 기본 과정을 통해 불러오고, 정돈하고, 변형할 수 있다. 따라서 보다 중요한 것은 형상 데이터를 다루는 것이다.\n\n1.2 셰이프 파일\n벡터 데이터 포맷, 보다 정확하게는 형상 데이터의 포맷으로 가장 널리 사용되고 있는 것이 셰이프 파일(shape file)이다. 셰이프 파일(확장자가 .shp인 파일)은 전세계에서 가장 큰 GIS 회사인 ESRI가 오래전에 개발한 벡터 데이터 포맷으로, 현재 표준 포맷의 역할을 하고 있다. 그런데 셰이프 파일은 동일한 이름을 공유하지만 확장자가 서로 다른 몇 개의 파일의 묶음을 지칭한다는 점을 이해할 필요가 있다. 반드시 다음의 네 파일을 함께 가지고 있어야 한다.\n\n*.shp: 버텍스의 좌표값이 포함된 핵심 파일\n*.dbf: 기본 속성 파일\n*.shx: 공간적 인덱싱 파일\n*.prj: 투영 정보 파일\n\n마지막의 *.prj 파일은 없어도 지도로 나타날 수는 있다. 그러나 다른 셰이프 파일과 함께 지도로 나타내거나 축척막대와 같은 지도 요소를 적절하게 나타내기 위해서는 좌표참조계(CRS) 정보가 포함된 *.prj 파일은 가질 필요가 있다.\n\n1.3 sf 패키지\nR에서 형상 데이터를 다루는데 있어 거의 표준처럼 사용되고 있는 것이 sf 패키지이다. 기본적으로는 셰이프 파일을 불러오기 위한 st_read() 함수를 주로 사용하게 되겠지만, sf 패키지는 벡터-기반 GIS 오퍼레이션을 위한 폭넓은 함수를 제공한다. 중요한 것을 정리하면 다음과 같다.\n\n\n\n\n\n\n\n구분\n함수\n설명\n\n\n\n읽고 쓰기\n\nst_read()\nread_sf()\n\n셰이프 파일 읽어 들이기\n\n\n\nst_write()\n셰이프 파일 저장\n\n\n투영 관련\nst_crs()\nCRS 정보 확인\n\n\n\nst_transform()\nCRS 바꾸기\n\n\n기하 측정\nst_area()\n면적 계산\n\n\n\nst_length()\n길이 계산\n\n\n\nst_perimeter()\n둘레 계산\n\n\n\nst_distance()\n거리 계산\n\n\n기하 변형\nst_centroid()\n센트로이드 생성\n\n\n\nst_buffer()\n버퍼 생성\n\n\n\nst_boundary()\n가장자리 추출\n\n\n\nst_simplify()\n선 피처 단순화 실행\n\n\n기하 생성\nst_point()\n포인트 피처 생성\n\n\n\nst_vironoi()\n보로노이 폴리곤 생성\n\n\n\nst_convex_hull()\n컨벡스 헐 생성\n\n\n\nst_make_grid()\n규칙 그리드 생성\n\n\n기하 검토\nst_is_valid()\n지오메트리가 밸리드한지 여부 검토\n\n\n\nst_make_valid()\n지오메트리를 밸리드하게 만들기\n\n\n기하 중첩\nst_intersection()\n기하 교집합 중첩\n\n\n\nst_union()\n기하 합집합 중첩\n\n\n\nst_crop()\n기하 크롭 중첩\n\n\n기타\nst_coordinates()\n버택스 좌표값 반환\n\n\n\nst_cast()\n다른 피처 유형으로 변환\n\n\n\nst_as_sf()\nsf 객체로 변환\n\n\n\nst_graticule()\n그래티큘 생성\n\n\n\nst_join()\n공간적 조인 실행\n\n\n\n래스터 데이터를 다루는데는 terra 패키지가 가장 널리 사용되고 있으며, stars패키지가 최근 많은 주목을 받고 있다. stars 패키지와 sf 패키지는 모두 에트저르 페베스마(Edzer Pebesma)가 만들었다. 두 패키지에 대한 설명은 페베스마와 로저 비번드(Roger Bivand)가 함께 쓴 ’R을 활용한 공간데이터사이언스(Spatial Data Science With Applications in R)’에 잘 나타나 있다(Pebesma 와/과 Bivand (2023))"
  },
  {
    "objectID": "exec_12.html#정적-지도-제작",
    "href": "exec_12.html#정적-지도-제작",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n2 정적 지도 제작",
    "text": "2 정적 지도 제작\n\n2.1 세계 지도\nggplot2 패키지를 이용하여 정적 지도를 그려본다. ggplot2패키지로 지도를 그린다는 것은 ’지도도 그래프다.’라는 접근법에 기반하고 있다. ggplot2의 문법을 지도 제작으로 확장할 수 있고, 막강한 생태계를 고려할 때 충분히 이점이 있는 접근법이다.\n데이터는 지난 실습에서 사용한 WPP 2024(World Population Prospects 2024)이다. 2024년 전세계 국가별 TFR(Total Fertility Rate, 합계출산율) 지도를 그려본다.\n벡터 데이터를 활용한 지도는 형상 데이터와 속성 데이터를 결합해야만 제작할 수 있다. 여기서 형상 데이터는 전세계 국가 경계 데이터이고, 속성 데이터는 TFR이 포함된 WPP 2024 데이터이다. 형상 데이터는 spData 패키지에 들어 있는 world 객체를 사용한다. 벡터 형식의 데이터는 sf 패키지의 st_as_sf() 함수를 통해 sf 객체로 변환하는 것이 좋다.\n\nlibrary(spData)\nlibrary(sf)\ndata(world)\nworld &lt;- st_as_sf(world)\n\nWPP 2024 데이터를 불러와 2025년만 골라낸다.\n\nwpp_2024 &lt;- read_rds(\"wpp_2024.rds\")\nmy_wpp &lt;- wpp_2024 |&gt; \n  filter(year == 2025)\n\n두 데이터를 left_join() 함수를 이용하여 결합한다. 벡터 데이터의 경우는 늘 반드시 형상 데이터를 중심에 두고 left_join() 함수를 통해 속성 데이터를 불러와 합체해야 한다.\n\nworld_data &lt;- world |&gt;\n  left_join(my_wpp, join_by(iso_a2 == ISO2))\n\n로빈슨 도법(Robinson projection)의 지도를 제작한다. ggplot2 패키지로 지도를 그리는 가장 좋은 방법은 기하객체 함수인 geom_sf()와 좌표 변환 함수인 coord_sf()를 결합하는 것이다. scale_x_continuous()와 scale_y_continuous()의 내용은 그래티큘(경위선망)을 원하는 방식대로 지도에 포함시키기 위한 것이다. 그래프를 world_map이라는 이름의 객체로 저장하는 것은 뒤에서 이 지도를 사용하기 때문이다.\n\nworld_map &lt;- ggplot() +\n  geom_sf(data = world_data, aes(fill = TFR, text = name_long)) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_fill_viridis_c() +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.5, seq(-60, 60, 30), 89.5)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\nworld_map\n\n\n\n\n\n\n\n\n2.2 우리나라 지도\n우리나라 지도도 그려본다. ’Lab07: 데이터 수집하기’에서 KOSIS의 API를 통해 수집, 정리한 시군구 단위 지역소멸위험지수를 지도화한다. 우선 우리나라 시군구 행정 경계에 대한 도형(형상, 기하) 데이터가 필요하다. GADM(Database of Global Administrative Areas)는 전 세계 국가별, 행정구역 수준별, 고해상도 디지털 경계 파일을 제공한다. 직접 웹사이트를 방문해 파일을 다운로드할 수도 있지만, 여기서는 geodata 패키지의 도움을 받는다. geodata 패키지는 정말 다양한 종류의 공간 데이터를 쉽게 다운로드할 수 있게 도와준다. 1레벨인 시도 단위와 2레벨인 시군구 단위를 다운받는다. path 아규먼트가 반드시 필요한데, 프로젝트 파일의 폴더도 좋고, 앞으로 geodata 패키지를 통해 다운받을 데이터를 모아둘 곳을 따로 정해두어도 좋다. 그렇지만 할당 연산자를 통해 이름을 부여하면 따로 다운로드된 파일을 다시 부르는 수고는 하지 않아도 된다.\n\nlibrary(geodata)\nlibrary(tmap)\n\nkorea_sd &lt;- gadm(country = \"South Korea\", level = 1, path = \"D:/My R/Geodata/\")\nkorea_sd &lt;- korea_sd |&gt; \n  st_as_sf()\nkorea_sgg &lt;- gadm(country = \"South Korea\", level = 2, path = \"D:/My R/Geodata/\")\nkorea_sgg &lt;- korea_sgg |&gt; \n  st_as_sf()\n\n그런데 파일을 열어보고서 경악한다. 행정구역 코드가 없다. 그래서 이 방법은 포기한다.\n행정구역 파일은 통계청의 통계지리정보서비스에서 구할 수 있다. 다운받는 방법을 익히면 좋겠지만, 시간 절약을 위해 다운받아 정리한 파일을 그냥 제공한다. 프로젝트 폴더에 파일을 저장한 후, 아래의 코드를 통해 불러온다.\n\nsido_shp &lt;- st_read(\"sido.shp\", options = \"ENCODING=CP949\")\nsigungu_shp &lt;- read_sf(\"sigungu.shp\", options = \"ENCODING=CP949\")\n\n두 파일에 대해 서로 다른 함수를 적용한 것을 알 수 있다. st_read() 함수는 가장 보편적으로 사용되는 것으로 불러올 때마다 파일에 대한 정보(지오메트리 유형, 바운딩 박스, CRS 등)가 자동으로 디스플레이된다. 이러한 정보는 항상 유익한 것이지만 보이지 않게 하고 싶을 수도 있다. 이 때 read_sf() 함수를 사용할 수 있다.\n불러들인 파일을 바탕으로 시군구 경계를 그려본다. 지도 제작 전문 패키지인 tmap의 qtm() 함수를 이용하여 시군구 경계에 대한 지도를 빠르게 그려본다. tmap패키지로 지도를 그린다는 것은 ’지도는 지도다.’라는 접근법에 기반하고 있다. tmap의 문법을 새로 배워야 한다는 단점이 있긴 하지만, 지도는 그래프로 환원될 수 없는 고유한 특성이 있고, tmap패키지는 이러한 지도의 고유한 특성을 잘 반영하고 있다. 좀 더 복잡한 tmap의 문법을 사용한 지도 제작은 맨 뒤에서 다루기로 한다.\n\nlibrary(tmap)\nqtm(sigungu_shp)\n\n\n\n\n\n\n\n지역소멸위험지수 데이터를 불러온다. 아래 코드는 지난번 실습 때 rds 파일 포맷으로 저장해 둔 것을 가정한 것이다. 실습의 편의를 위해 파일을 제공하니 프로젝트 폴더에 저장한 후, 아래의 코드를 통해 불러온다.\n\ndata_sigungu &lt;- read_rds(\"data_sigungu.rds\")\n\n도형 데이터(korea_sgg)와 속성 데이터(data_sigungu)를 공통 키(key)를 활용하여 결합한다.\n\nsigungu_data &lt;- sigungu_shp |&gt; \n  left_join(\n    data_sigungu, join_by(SGG1_CD == C1)\n  )\n\n이제 ggplot2 패키지를 이용하여 지도를 제작한다. ’Lab07: 데이터 수집하기’에서 인구소멸위험지수의 시도별 그래프를 제작한 것과 비교해 보라. 그 유사함에 깜짝 놀랄 수도 있다. ggplot2에서는 그래프와 지도의 구분이 없다. 이것은 ggplot2의 장점이자 단점이다.\n\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index_class = case_when(\n      index &lt; 0.2 ~ \"1\",\n      index &gt;= 0.2 & index &lt; 0.5 ~ \"2\",\n      index &gt;= 0.5 & index &lt; 1.0 ~ \"3\",\n      index &gt;= 1.0 & index &lt; 1.5 ~ \"4\",\n      index &gt;= 1.5 ~ \"5\"\n    ),\n    index_class = fct(index_class, levels = as.character(1:5))\n  )\n\nclass_color &lt;- c(\"1\" = \"#d7191c\", \"2\" = \"#fdae61\",\n                 \"3\" = \"#ffffbf\", \"4\" = \"#a6d96a\", \n                 \"5\" = \"#1a9641\")\nggplot() +\n  geom_sf(data = sigungu_data, aes(fill = index_class), show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(name = \"Classes\", \n                    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \n                               \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n                    values = class_color, drop = FALSE)"
  },
  {
    "objectID": "exec_12.html#인터랙티브-지도-제작",
    "href": "exec_12.html#인터랙티브-지도-제작",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n3 인터랙티브 지도 제작",
    "text": "3 인터랙티브 지도 제작\n위에서 사용한 plotly 패키지의 ggplotly() 함수를 활용하면 반응형 지도를 생성할 수 있다. 앞의 코드 둘째 줄에 aes()에 text = name_long이 설정되어 있는데, 마우스로 국가를 가리킬 때 이름이 나타날 수 있게 조치한 것이다.\n\nlibrary(plotly)\nggplotly(world_map)\n\n\n\n\n\n지도 위에서 plotly 가 제공하는 다양한 기능을 적용해 볼 필요가 있다. 인터랙티브 그래프에 비해 인터랙티브 지도의 유용성이 더 높아 보인다.\n우리나라 지도는 다른 방식으로 반응형으로 만들어 본다. 여기서는 ggiraph 패키지를 사용한다. 처음 사용하는 경우라면 먼저 패키지를 인스톨해야 한다. 코드의 전반부는 커서를 특정 시군구 위에 올렸을 때 나타나는 정보를 좀 더 다양하게 하려는 조치이다. 중간의 코드가 핵심인데, 찬찬히 살펴보면 그렇게 복잡하지 않다. 마지막은 완전히 지엽적인 것인데, 커서를 특정 시군구 위에 올렸을 때 색이 회색으로 변하게 하기 위한 것이다.\n\nlibrary(ggiraph)\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = format(index, digits = 4, nsmall = 4),\n    my_tooltip = str_c(\"Name: \", SGG1_FNM, \"\\n Index: \", index)\n  )\ngg &lt;- ggplot() +\n  geom_sf_interactive(\n    data = sigungu_data, \n    aes(\n      fill = index_class, \n      tooltip = my_tooltip, \n      data_id = SGG1_FNM\n      ), \n    show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(\n    name = \"Classes\", \n    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n    values = class_color, drop = FALSE) \ngirafe(ggobj = gg) |&gt; \n  girafe_options(\n    opts_hover(css = \"fill: gray\")\n  )\n\n\n\n\n\n그러나 반응형 지도 제작에 가장 널리 쓰이는 것은 leaflet이다. leaflet은 웹 상의 반응형 지도 제작에 특화된 JavaScript 라이브러리이다. 이 라이브러리를 R에서 쓸 수 있게 도와주는 래퍼 패키지가 leaflet 패키지이다. 패키지 홈페이지가 매우 상세하게 잘 되어 있다. 숙독하기를 권한다.\n\nlibrary(leaflet)\n\n매우 단순한 인터랙티브 지도를 만들어 본다. 자신이 원하는 경위도값과 설명문으로 수정하면 된다.\n\nleaflet() |&gt; \n  addTiles() |&gt; \n  addPopups(126.955184, 37.460422, \"Sang-Il's Office\",\n            options = popupOptions(closeButton = FALSE))\n\n\n\n\n\n\n위에서 작성했던 TFR 세계지도를 leaflet 패키지의 다양한 함수와 아규먼트를 활용하여 인터랙티브 지도를 제작해 본다.\n\nworld_data &lt;- world_data |&gt; filter(!is.na(TFR))\n\nbins &lt;- c(0, 1.5, 2.1, 3, 4, 5, Inf)\npal &lt;- colorBin(\"YlOrRd\", domain = world_data$TFR, bins = bins)\nlabels &lt;- sprintf(\"&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g\",\n  world_data$name_long, world_data$TFR) |&gt; lapply(htmltools::HTML)\n\nleaflet(world_data) |&gt; \n  addProviderTiles(providers$Esri.WorldTopoMap) |&gt; \n  addPolygons(\n    fillColor = ~pal(TFR),\n    weight =  2, \n    opacity = 1,\n    color = \"white\",\n    dashArray = \"3\",\n    fillOpacity = 0.6,\n    highlightOptions = highlightOptions(\n      weight = 5,\n      color = \"#666\",\n      dashArray = \"\",\n      fillOpacity = 0.6,\n      bringToFront = TRUE),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n      textsize = \"15px\",\n      direction = \"auto\")\n  ) |&gt; \n  addLegend(\n    pal = pal, values = ~TFR, opacity = 0.6, title = NULL,\n    position = \"bottomright\"\n  )\n\n\n\n\n\n\n우리나라 시군구 단위의 인구소멸위험지수에 대한 지도를 반응형으로 만들어 본다. 여기서는 tmap을 활용한다. 해당 시군구 위에 클릭하면 지역소멸위험지수가 나타난다.\n\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = as.numeric(index)\n  )\ntmap_mode(mode = \"view\")\nmy_tmap &lt;- tm_shape(sigungu_data) + \n  tm_polygons(\n    col = \"index\",\n    palette = class_color, \n    breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n    labels = c(\"&lt; 0.2\", \"0.2~0.5\", \"0.5~1.0\", \"1.0~1.5\", \"&gt;= 1.5\"),\n    title = \"Classes\", \n    popup.vars=c(\"지역소멸위험지수: \" = \"index\"), \n    popup.format = list(index = list(digits = 3)), \n    id = \"SGG1_FNM\", \n    alpha = 0.6, \n    border.alpha = 0.5\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 2)\nmy_tmap\n\n\n\n\n\ntmap_save(my_tmap, \"지방소멸위험지수.html\")"
  },
  {
    "objectID": "exec_12.html#패키지와-tidyverse-패키지",
    "href": "exec_12.html#패키지와-tidyverse-패키지",
    "title": "R과 데이터사이언스 과정",
    "section": "\n1 패키지와 tidyverse 패키지",
    "text": "1 패키지와 tidyverse 패키지\n\n1.1 패키지\n패키지는 유사한 과업을 수행하는데 도움을 주는 함수들의 묶음 정도로 정의할 수 있다. 현재 CRAN(The Comprehensive R Archive Network)에는 20,000개 정도의 패키지가 등록되어 있다고 한다. CRAN에 패키지를 등록하는게 쉽지 않은 일이기 때문에 GitHub과 같은 곳을 통해 접근 가능한 패키지까지 합치면 도대체 몇 개의 R 패키지가 세상에 존재하는지 알기 어렵다.\n패키지를 사용하기 위해서는 해당 패키지가 사용자의 디바이스에 물리적으로 인스톨되어 있어야 하고, R 세션에서 패키지를 불러와야 한다. 패키지를 인스톨하는 방법은 두 가지 이다. 스크립트 내에서 패키지를 반복해서 인스톨하는 것은 합리적이지 않기 때문에 전자의 관행을 추천한다.\n\nOutput 창의 Packages 탭 선택: Install 아이콘을 클릭하고 패키지 이름 입력\n스크립트 내에서 인스톨하기: install.packages(\"패키지명\")\n\n쌍따옴표 속에 패키지 이름을 타이핑해야 한다. 한번 인스톨이 되면 업데이트하지 않는 한 새롭게 패키지를 인스톨할 필요가 없다. 인스톨된 패키지를 사용하려면 스크립트 내에서 다음과 같이 타이핑하고 실행한다.\n\nlibrary(패키지명)\n\n괄호 속에 패키지명을 기입해야 한다.\n\n\n\n\n\n\n노트\n\n\n\n\n\ninstall.packages()함수에서는 반드시 패키지명을 쌍따옴표로 싸야하지만, library()함수에서는 그렇지 않다. 불러온 패키지는 R 세션이 유지되는 동안 내내 사용할 수 있지만, R 세션을 끝내고 다시 시작하면 다시 library()함수를 이용해 다시 불러와야 한다. 그래서 R 스크립트 파일의 시작 부분에는 패키지를 불러오는 코드를 위치시키고, 다시 스크립트 파일을 열 때마다 그 부분을 재실행하는 것이 좋은 습관이다.\n\n\n\n\n1.2 tidyverse 패키지\n데이터사이언스 과정의 각 단계는 특징적인 과업으로 구성되어 있고, 거기에 맞춰 특징적인 함수들을 장착한 패키지들이 개발되어 왔다. 그런데 최근 RStudio는 데이터사이언스와 밀접히 관련된 패키지들을 모아 일종의 엄브렐러 패키지인 tidyverse를 만들어 제공하고 있다. tidyverse 패키지는 패키지의 패키지인데, 핵심적인 구성 패키지에 다음과 같은 것들이 있다.\n\nggplot2: 시각화하기\ndplyr: 변형하기\ntidyr:정리하기\nreadr: 불러오기\ntibble: 데이터 프레임 관련\nstringr: 문자열 처리 관련\nforcats: 범주 변수(팩터) 처리 관련\npurrr: 함수형 프로그래밍(functional programming) 관련\nlubridate: 일시 및 시간 처리 관련\n\n\n\n\n\n\n그림 2: tidyverse의 핵심 패키지(https://www.tidyverse.org/)\n\n\ntidyverse패키지를 사용하는 것의 장점은 이 패키지만 불러오면 구성 패키지까지 한꺼번에 사용할 수 있게 된다는 점이다. 스크립트 내에서 다음과 같은 코드를 실행한다.\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "exec_12.html#시각화하기",
    "href": "exec_12.html#시각화하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n2 시각화하기",
    "text": "2 시각화하기\n\n2.1 데이터 살펴보기\n이 실습을 위해 남극 파머군도(Palmer Archipelago)에 서식하는 펭귄 성체의 신체 계측 데이터를 사용한다. 이 데이터는 palmerpenguins라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다.\n\nlibrary(palmerpenguins)\n\n이제 이 페키지에 포함되어 있는 penguins라는 이름의 데이터를 불러온다.\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n데이터를 자세히 살펴보면 몇 가지를 알 수 있다.\n\n티블(tibble)이라는 형식의 데이터 프레임이다. 티블은 tidyverse의 공식 데이터 프레임 포맷이다.\n관측개체는 344개, 변수는 8개이다.\nspecies, island, sex 변수의 유형은 팩트형(fctr)이고, bill_length_mm, bill_depth_mm은 실수형(dbl)이고, 나머지는 정수형(int)이다.\n\n변수가 많아지면 전체 데이터를 조망하기 어렵기 때문에, 최초의 tidyverse 함수인 glimpse()를 사용하여 데이터의 행과 열을 바꾸어 보자. 변수 위주로 데이터를 개관하고자 할 때 매우 유용하다.\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\n\n\n\n\n힌트\n\n\n\npenguins데이터 내 속성들에 대한 설명을 보고싶다면 Console에 help(penguins) 또는 ?penguins를 입력한 뒤 실행한다.\n\n\n\n2.2 그래프 만들기\n이 penguins 데이터와 ggplot2 패키지를 이용하여 “펭귄의 날개 길이와 몸무게의 관계”를 표현하는 그래프를 작성해 보자. ggplot2의 문법에 대한 사항은 따로 공부할 기회가 있으므로 여기서는 제작 과정을 한 번 따라가 본다.\n\n2.2.1 플롯 객체의 지정\nggplot()이라는 함수를 통해 플롯 제작을 개시하는 단계이며, 어떤 데이터를 사용할지를 지정한다.\n\nggplot(data = penguins)\n\n\n\n\n\n\n\n\n2.2.2 플롯의 시각속성 매핑\n데이터가 어떤 시각속성(aesthetics)으로 표현될 것인가를 지정한다. 여기서는 간단히 어떤 변수들이 x-축과 y-축에 나타나는지만 지정한다. mapping = aes() 아규먼트가 핵심이다. 보통 mapping은 생략하고 aes()만 쓴다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n\n\n\n\n\n\n\n2.2.3 플롯의 기하객체 지정\n데이터가 어떤 기하객체(geometric object)로 표현될 것인가 혹은 어떤 그래프 유형으로 표현될 것이가를 지정한다. geom 아규먼트가 핵심인데, geom_point()는 데이터를 포인트라고 하는 기하객체로 표현한다는 것을 지정한 것으로 결국 산포도(scatterplot)라는 그래프 유형을 산출하게 된다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n2.2.4 시각속성의 첨가\n이러한 관련성이 펭귄의 종족에 따라 다르게 나타나는지를 탐색하기 위해 color 라는 시각속성을 species라는 변수에 적용한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n2.2.5 기하객체 레이어의 첨가\n두 변수의 관련성을 보여주는 선형 기하객체를 첨가한다. 여기서는 geom_smooth()를 이용하여 OLS 회귀선을 첨가한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n2.2.6 라벨링 등 마무리 작업\nlabs()를 이용하여 그래프의 제목(title), 부제목(subtitle), 축이름, 범례 표제 등을 지정한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\"\n  )"
  },
  {
    "objectID": "exec_12.html#변형하기",
    "href": "exec_12.html#변형하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n3 변형하기",
    "text": "3 변형하기\n변형하기와 관련된 함수들은 대부분 dplyr 패키지에 포함되어 있다.\n\n3.1 데이터 살펴보기\n이 실습을 위해 미국 교통통계국(U.S. Bureau of Transportation)이 제공하는 데이터를 사용하는데, 이것은 2013년 한 해 동안 미국 뉴욕시를 출발한 336,776대의 항공기에 대한 정보를 담고 있다. 이 데이터는 nycflights13 이라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다. 그리고 나서 패키지에 포함되어 있는 flights라는 이름의 데이터를 불러온다.\n\nlibrary(nycflights13)\nglimpse(flights)\n\nRows: 336,776\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n\n\n\n\n\n\n힌트\n\n\n\nflights데이터 내 속성들에 대한 설명을 보고싶다면 Console에 help(flights) 또는 ?flights를 입력한 뒤 실행한다.\n\n\n\n3.2 주요 함수\n여기서는 가장 널리 사용되는 6개 함수에 대해서만 개략적으로 다룬다. 그 6개 함수는 select(), filter(), arrange(), mutate(), group_by(), summerize()이다. 조교의 도움을 받아 각 함수가 무슨 일을 한 것인지 이해한다.\n\n3.2.1 select() 함수\n열(변수) 중 일부를 솎아낸다. 즉, 변수의 갯수를 줄인다.\n\nselect(flights, year, month, day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\n\n3.2.2 filter() 함수\n특정 열(변수)에 의거해 조건을 만족하는 행을 솎아낸다. 즉 관측개체의 갯수를 줄인다.\n\nfilter(flights, month == 1 & day == 1)\n\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.3 arrange() 함수\n특정 열(변수)에 의거해 행의 순서를 바꾼다.\n\narrange(flights, year, month, day)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.4 mutate() 함수\n기존의 열(변수)을 변형하여 새로운 열(변수)을 생성한다.\n\nmutate(flights,\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, gain &lt;dbl&gt;, speed &lt;dbl&gt;\n\n\n\n3.2.5 group_by() 함수\n열(변수)(범주형 변수, categorical variables)에 의거해 전체 행을 그룹으로 분할한다. 데이터 프레임이 내부적으로 12개의 달로 분할된다.\n\ngroup_by(flights, month)\n\n# A tibble: 336,776 × 19\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.6 summerize() 함수\n열(변수)의 통계량을 산출하여 새로운 데이터 프레임의 새로운 열(변수)에 저장한다. 모든 항공기의 평균출발지연시간을 계산한 것이다.\n\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  delay\n  &lt;dbl&gt;\n1  12.6\n\n\n위의 group_by() 함수와 결합하면, 그룹별로 열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장할 수 있다. 일단위로 평균출발지연시간을 계산한 것이다.\n\nby_day &lt;- group_by(flights, year, month, day)\nsummarize(by_day, delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day delay\n   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n 1  2013     1     1 11.5 \n 2  2013     1     2 13.9 \n 3  2013     1     3 11.0 \n 4  2013     1     4  8.95\n 5  2013     1     5  5.73\n 6  2013     1     6  7.15\n 7  2013     1     7  5.42\n 8  2013     1     8  2.55\n 9  2013     1     9  2.28\n10  2013     1    10  2.84\n# ℹ 355 more rows"
  },
  {
    "objectID": "exec_12.html#정리하기",
    "href": "exec_12.html#정리하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n4 정리하기",
    "text": "4 정리하기\n정리하기와 관련된 함수들은 대부분 tidyr 패키지에 포함되어 있다. 많은 함수가 있지만 가장 중요한 두 개의 함수에만 집중한다.\n\n4.1 데이터 살펴보기\n이 실습에서는 tidyverse 패키지에 포함되어 있는 매우 단순한 데이터를 사용한다. 이 두 데이터는 정돈된 데이터(tidy data)가 아니다. 정돈된 데이터가 무엇인지에 대해서는 다음 장에서 다룬다. 여기서는 정돈되지 않은 데이터를 정돈된 데이터로 만드는 과정을 맛본다.\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n\n\n\n4.2 주요 함수\n\n4.2.1 pivot_longer() 함수\ntable4a에서 1999과 2000은 변수명일 수 없다. year라는 변수의 속성이어야 한다.\n\npivot_longer(\n  table4a, \n  cols = c(`1999`, `2000`),\n  names_to = \"year\",\n  values_to = \"cases\"\n)\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\n\n4.2.2 pivot_wider() 함수\ntable2에서 type 변수는 두 개의 변수명을 포함하고 있다. 즉, cases와 population은 속성값이라기 보다는 변수명이다.\n\npivot_wider(\n  table2, \n  names_from = \"type\",\n  values_from = \"count\"\n)\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583"
  },
  {
    "objectID": "exec_12.html#불러오기",
    "href": "exec_12.html#불러오기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n5 불러오기",
    "text": "5 불러오기\n불러오기와 관련된 함수들은 대부분 readr 패키지에 포함되어 있다. 여러 유형의 파일을 불러오기 위해 여러 함수가 존재하지만, 콤마분리값(comma-separated values, CSV) 형식의 데이터를 불러오는 함수(read_csv())만 실습한다.\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\nglimpse(students)\n\nRows: 6\nColumns: 5\n$ `Student ID`   &lt;dbl&gt; 1, 2, 3, 4, 5, 6\n$ `Full Name`    &lt;chr&gt; \"Sunil Huffmann\", \"Barclay Lynn\", \"Jayendra Lyne\", \"Leo…\n$ favourite.food &lt;chr&gt; \"Strawberry yoghurt\", \"French fries\", \"N/A\", \"Anchovies…\n$ mealPlan       &lt;chr&gt; \"Lunch only\", \"Lunch only\", \"Breakfast and lunch\", \"Lun…\n$ AGE            &lt;chr&gt; \"4\", \"5\", \"7\", NA, \"five\", \"6\""
  },
  {
    "objectID": "exec_12.html#파이프-연산자pipe-operator",
    "href": "exec_12.html#파이프-연산자pipe-operator",
    "title": "R과 데이터사이언스 과정",
    "section": "\n6 파이프 연산자(pipe operator)",
    "text": "6 파이프 연산자(pipe operator)\n우리는 이전 실습에서 할당 연산자(&lt;-)에 대해 배웠다. 오늘 살펴본 다양한 변형의 결과를 다른 데이터 프레임에 담고 싶으면 다음과 같이 할당 연산자를 사용할 수 있다.\n\nflights_day1 &lt;- filter(flights, month == 1 & day == 1)\nglimpse(flights_day1)\n\nRows: 842\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n앞으로 할당 연산자보다 훨씬 더 빈번하게 사용하게 될 연산자를 소개하려고 한다. 그것은 파이프 연산자(pipe operator)라는 것으로, %&gt;% 혹은 |&gt;로 표시하는 것이다. 원래 이 연산자의 원리는 magrittr 패키지에서 처음 소개되었는데, 차츰 R 커뮤니티에 파급되더니 급기야는 대세로 자리잡았다. 그래서 특정 패키지를 깔지 않아도 파이프 연산자를 사용할 수 있게 하기 위해 Base R에 도입되었고(이것을 네이티브 파이프 연산자(native pipe operator)라고 부른다), 부호로 %&gt;% 대신 |&gt;를 사용한다. 둘 사이에 차이는 거의 없지만, 후자가 점점 표준이 되고 있기 때문에 본 수업에서는 그것을 사용한다. 다음의 두 가지에 유의한다.\n\n현재 RStudio의 디폴트는 %&gt;%로 설정되어 있다. 이것을 Tools &gt; Global Options &gt; Code에 가서 ’Use native pipe operator, |&gt; (requires R 4.1+)’를 선택해 주어야 한다. 아래의 그림 3 를 참고하라.\n\n\n\n\n\n\n그림 3: 파이프 연산자(https://r4ds.hadley.nz/data-transform)\n\n\n\n단축키는 Crtl + Shift + M이다. 다른 건 몰라도 이 단축키만은 반드시 기억해야 한다.\n\n다음의 세 코드를 비교해 보라. 우선 아래의 경우는 flights1과 flights2와 같은 중간 변수가 계속 생성되어 메모리를 차지하게 된다.\n\nflights1 &lt;- filter(flights, dest == \"IAH\")\nflights2 &lt;- mutate(flights1, speed = distance / air_time * 60)\nflights3 &lt;- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n혹은 다음과 같이 함수가 다른 함수 속에 계속 포함되는 형식으로 만들 수 있는데, 코드가 매우 복잡해 진다.\n\narrange(\n  select(\n    mutate(\n      filter(\n        flights, \n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n다음은 위 두 경우와 달리 파이프 연산자를 사용한 경우이다. 동일한 결과를 가져다 주지만 훨씬 더 간결하고 직관적이고 이해하기 쉽다. 파이프 연산자의 사용 원리는 뒤에서 자세히 배운다.\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  mutate(speed = distance / air_time * 60) |&gt; \n  select(year:day, dep_time, carrier, flight, speed) |&gt; \n  arrange(desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows"
  },
  {
    "objectID": "exec_12.html#기본-구조",
    "href": "exec_12.html#기본-구조",
    "title": "R과 데이터사이언스 과정",
    "section": "1 기본 구조",
    "text": "1 기본 구조\nShiny는 크게 세 부분으로 나뉘어 진다(그림 1).\n첫째, ui(혹은 ux) 부분이다. 프론트엔트(front-end) 부분으로 입력을 받고 출력을 표출하는 부분이다.\n둘째, server 부분이다. 백엔드(back-end) 부분으로 받은 입력으로 출력을 산출하는 부분이다.\n셋째, 결합 부분이다. ui와 server 부분을 결합해 웹 앱을 실행하는 부분이다.\n\n\n\n\n\n\n그림 1: Shiny의 구조(https://bookdown.org/hneth/i2ds/shiny.html)\n\n\n\n이건 좀 이상해. 정말 이상해.\n다시 한번\n또 이상일"
  },
  {
    "objectID": "exec_11.html#기본-동작",
    "href": "exec_11.html#기본-동작",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n1 기본 동작",
    "text": "1 기본 동작\n\n1.1 기본 구조\nShiny는 크게 세 부분으로 나뉘어 진다(그림 1).\n첫째, UI(혹은 UX) 부분이다. 프론트엔트(front-end) 부분으로 입력을 받고, Server에서 산출된 출력을 표출하는 부분이다.\n둘째, Server 부분이다. 백엔드(back-end) 부분으로 UI에서 받은 입력에 기반하여 출력을 산출하는 부분이다.\n셋째, 결합 및 실행 부분이다. UI와 Server 부분을 결합해 웹 앱을 실행하는 부분이다. 결합 및 실행은 단일 파일 속에 UI와 Server를 함께 다루는 방식과, 두 개의 파일로 분할하여 다루는 방식으로 나뉜다. 여기서는 전자를 중심으로 설명한다.\n\n\n\n\n\n그림 1: Shiny의 구조(https://bookdown.org/hneth/i2ds/shiny.html)\n\n\n\n1.2 Shiny 프로젝트의 생성\n여기서는 RStudio에서 Shiny 프로젝트를 생성하는 방법에 대해 배운다. New Project &gt; New Directory &gt; Shiny Application을 선택한다. 그림 2 에서 Directory name과 Subdirectory의 위치를 설정한다.\n\n\n\n\n\n그림 2: Shiny 프로젝트의 생성\n\n\n이렇게 하면 Shiny 프로젝트가 생성되고, 자동적으로 app.R이라는 스크립트 파일이 생성된다.\n\n1.3 웹 앱의 생성\napp.R에서 스크립트 윈도우 오른쪽 상단에 위치한 Run App 버튼을 클릭하면 그림 3 같은웹 앱이 새로운 윈도우에 생성된다. 왼쪽의 슬라이더바를 움직이면 오른쪽의 히스토그램이 변한다는 점을 확인한다. 즉 빈(bin)의 개수를 달리하면서 데이터 분포를 탐색해보기 위한 단순한 웹 앱이 만들어진 것이다.\n\n\n\n\n\n그림 3: 단순한 웹 앱\n\n\n이 단순한 웹 앱을 살펴본다. 다음과 같은 점을 확인할 수 있다.\n첫째, 크게 두 부분으로 구성되어 있는데, 왼편의 슬라이더바가 있는 부분과 오른편의 히스토그램이 있는 부분으로 나뉜다. 부차적으로 상단에 제목(“Old Faithful Geyser Data”)이 있는 부분도 존재한다. 이 모든 것이 UI를 구성한다. 위에서 UI는 입력을 받고 출력을 표출한다고 했다. 왼편의 슬라이더바가 입력을 받는 부분이고, 오른편의 플롯 영역이 출력을 표출하는 부분이다.\n둘째, 사용자의 입력은 빈(bin)의 갯수이고, Server는 이 값을 바탕으로 히스토그램이라는 출력을 생성한다. 생성된 출력은 UI로 이동하여 표출된다. 사용자의 입력값이 바뀌면 이 과정이 반복되고 히스토그램이 바뀌게 된다.",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#함수의-종류",
    "href": "exec_11.html#함수의-종류",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n2 함수의 종류",
    "text": "2 함수의 종류\n\n2.1 입력 함수\n입력 함수 혹은 입력 위젯 생성 함수의 종류는 다양한데, R Shiny Components 웹페이지 기준으로 대략 25개 정도이다. 그림 4 은 그 중 일부를 보여주고 있다.\n\n\n\n\n\n그림 4: 입력 위젯의 종류(https://shiny.posit.co/r/getstarted/build-an-app/reactive-flow/ui-inputs.html)\n\n\n몇 가지 주목할 사항이 있다.\n첫째, 모든 함수의 이름이 *Input() 형식인 것은 아니다. 특히 버튼 형식의 경우 *Button() 혹은 *Buttons() 형식을 띤다. 이 외에 *Link(), *switch()로 끝나는 함수도 있다.\n둘째, 입력 함수에 따라 인수의 종류가 다르다. 자세한 사항은 R Shiny Components 웹페이지를 참조한다.\n\n2.2 출력 함수: 출력 표출 함수와 출력 생성 함수\n출력 함수는 서버에서 생성된 출력을 UI에서 표출해주는 출력 표출(바인딩) 함수와 서버에서 실질적으로 출력을 창출하는 출력 생성 함수로 구분된다. 출력 함수의 종류는 출력의 형식(플롯, 테이블, 텍스트, 이미지 등)에 의해 결정되기 때문에 기본적인 출력의 종류에 따라 출력 표출 함수와 출력 생성 함수가 쌍을 이룰 수 밖에 없다.\n다음은 다섯 가지 기본 출력 함수를 보여준다. 출력 표출 함수는 *Output()의 형식을, 출력 생성 함수는 render*({})의 형식을 취한다.\n\n\n\n\n\n\n\n형식\n출력 표출 함수\n출력 생성 함수\n\n\n\n플롯\nplotOutput(outputID = \"\")\nrenderPlot()\n\n\n테이블\ntableOutput(outputID = \"\")\nrenderTable()\n\n\n일반 텍스트\ntextOutput(outputID = \"\")\nrenderText()\n\n\n사전 포맷된 텍스트\nverbatimeTextOutput(outputID = \"\")\nrenderPrint()\n\n\n이미지\nimageOutput(outputID = \"\")\nrenderImage()\n\n\n\n그런데 특히 주요 시각화 패키지들은 Shiny 웹 앱 구축을 염두에 두고 개별적인 출력 표출 함수와 출력 생성 함수를 제공하고 있다. 중요한 패키지에 대해 이를 정리하면 다음과 같다. 모두 패키지명Output()형식과 render패키지명({})의 형식을 띤다.\n\n\n패키지\n출력 표출 함수\n출력 생성 함수\n\n\n\nDT\nDTOutput(outputID = \"\")\nrenderDT({})\n\n\nreactable\nreactableOutput(outputID = \"\")\nrenderReactable({})\n\n\nplotly\nplotlyOutput(outputID = \"\")\nrenderPlotyl({})\n\n\necharts4r\necharts4rOutput(outputID = \"\")\nrenderEcharts4r({})\n\n\nleaflet\nleafletOutput(outputID = \"\")\nrenderLeaflet({})\n\n\ntmap\ntmapOutput(outputID = \"\")\nrenderTmap({})\n\n\n\nR Shiny Components 웹페이지 기준으로 대략 12개 정도이다.\n출력 형식이 패키지마다 다를 수 있기 때문에 개별 패키지 특수적 함수까지 포함하면",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#입출력-함수의-종류",
    "href": "exec_11.html#입출력-함수의-종류",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n3 입출력 함수의 종류",
    "text": "3 입출력 함수의 종류\n\n3.1 입력 함수\n앞에서 언급한 것처럼, 입력 함수 혹은 입력 위젯 생성 함수의 종류는 다양하다. R Shiny Components 웹페이지 기준으로 대략 25개 정도이다. 그림 4 은 그 중 일부를 보여주고 있다.\n\n\n\n\n\n그림 4: 입력 위젯의 종류(https://shiny.posit.co/r/getstarted/build-an-app/reactive-flow/ui-inputs.html)\n\n\n몇 가지 주목할 사항이 있다.\n첫째, 모든 함수의 이름이 *Input() 형식인 것은 아니다. 특히 버튼 형식의 경우 *Button() 혹은 *Buttons() 형식을 띤다. 이 외에 *Link(), *switch()로 끝나는 함수도 있다.\n둘째, 입력 함수의 인수에 주목할 필요가 있다. 이름을 부여하는 inputID 인수와 입력 위젯의 설명 글귀를 지정하는 label 인수는 공통이다. 그러나 나머지 인수는 입력 함수에 따라 달라진다. 위의 예에서 sliderInput() 입력 함수는 min, max, value라는 추가적인 인수를 갖는데, min과 max는 슬라이더의 최대 및 최소값을, value는 위젯에 기본값을 지정하는 인수이다. 입력 함수별 인수에 대한 자세한 사항은 R Shiny Components 웹페이지를 참조한다.\n\n3.2 출력 함수: 출력 표출 함수와 출력 생성 함수\n출력 함수는 서버에서 생성된 출력을 UI에서 표출해주는 출력 표출(바인딩) 함수와 서버에서 실질적으로 출력을 창출하는 출력 생성 함수(렌더링 함수)로 구분된다. 출력 함수의 종류는 출력의 형식(플롯, 테이블, 텍스트, 이미지 등)에 의해 결정되기 때문에 기본적인 출력의 종류에 따라 출력 표출 함수와 출력 생성 함수가 쌍을 이룰 수 밖에 없다.\n다음은 다섯 가지 기본 출력 함수의 쌍을 보여준다. 출력 표출 함수는 *Output()의 형식을, 출력 생성 함수는 render*({})의 형식을 취한다.\n\n\n\n\n\n\n\n형식\n출력 표출 함수\n출력 생성 함수\n\n\n\n플롯\nplotOutput(outputID = \"\")\nrenderPlot()\n\n\n테이블\ntableOutput(outputID = \"\")\nrenderTable()\n\n\n일반 텍스트\ntextOutput(outputID = \"\")\nrenderText()\n\n\n사전 포맷된 텍스트\nverbatimeTextOutput(outputID = \"\")\nrenderPrint()\n\n\n이미지\nimageOutput(outputID = \"\")\nrenderImage()\n\n\n\n그런데 특히 주요 시각화 패키지들은 Shiny 웹 앱 구축을 염두에 두고 개별적인 출력 표출 함수와 출력 생성 함수를 제공하고 있다. 중요한 패키지에 대해 이를 정리하면 다음과 같다. 모두 패키지명Output()형식과 render패키지명({})의 형식을 띤다.\n\n\n패키지\n출력 표출 함수\n출력 생성 함수\n\n\n\nDT\nDTOutput(outputID = \"\")\nrenderDT({})\n\n\nreactable\nreactableOutput(outputID = \"\")\nrenderReactable({})\n\n\nplotly\nplotlyOutput(outputID = \"\")\nrenderPlotyl({})\n\n\necharts4r\necharts4rOutput(outputID = \"\")\nrenderEcharts4r({})\n\n\nleaflet\nleafletOutput(outputID = \"\")\nrenderLeaflet({})\n\n\ntmap\ntmapOutput(outputID = \"\")\nrenderTmap({})\n\n\n\nShiny 웹 앱에서의 활용을 염두에 둔 패키지들은 모두 이러한 출력 함수의 쌍을 제공하고 있다. 따라서 출력 함수는 굉장히 많을 수 있다. R Shiny Components 웹페이지는 기본 5개의 함수쌍에 주요 패키지를 포함하는 12개 정도의 출력 함수쌍을 예시로 제시하고 있다.",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#shiny의-기본-문법-체계",
    "href": "exec_11.html#shiny의-기본-문법-체계",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n2 Shiny의 기본 문법 체계",
    "text": "2 Shiny의 기본 문법 체계\n이제 그림 3 웹 앱을 생성한 코드를 살펴보도록 한다. 코드 속에는 다양한 설명이 포함되어 있는데 그것을 제거하고 코드만 남기면 결국 다음과 같다. 문법이 tidyverse와는 많이 다르다는 점을 금방 인식할 수 있다. 따라서 shiny의 문법 체계는 따로 익힐 수 밖에 없다.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n    titlePanel(\"Old Faithful Geyser Data\"),\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(inputId = \"bins\",\n                        label = \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n        mainPanel(\n           plotOutput(outputId = \"distPlot\")\n        )\n    )\n)\n\nserver &lt;- function(input, output) {\n    output$distPlot &lt;- renderPlot({\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\nshinyApp(ui = ui, server = server)\n\n코드를 자세히 살펴보자. 우선 shiny라는 R 패키지를 불러와야 한다. 코드가 ui, server, shinyApp의 세 부분으로 나뉘어져 있다는 것을 알 수 있고, 이것이 위에서 설명한 UI 부분, Server 부분, 결합 및 실행 부분을 담당한다는 점을 쉽게 이해할 수 있다.\n\n2.1 UI 부분\nUI 부분은 다양한 함수들이 위계 구조를 이루고 있는데, 전체 구조를 결정하는 레이아웃 함수가 마치 컨테이너처럼 존재하고 그 속에 입출력 함수가 포함되어 있는 구조이다.\n첫째, 레이아웃 함수가 위계 구조를 이루고 있다. 최상위 fluidPage() 함수는 titlePanel()과 sidebarLayout()로 구성되고, sidebarLayout()은 다시 sidebarPanel()과 mainPanel()로 구성된다. 하나씩 위계적으로 살펴보면 다음과 같다.\n\n\nfluidPage() : UI의 최상위 컨테이너로서 전체 레이아웃을 관장하며, 브라우저 화면 크기에 따라 자동으로 늘어나고 줄어드는 반응형 레이아웃을 제공한다. 이러한 특성 때문에 ’fluid’라는 이름이 붙었다. 고정 폭을 가진 레이아웃은 fixedPage()를 통해 정의할 수 있다. Shiny 앱에서는 기본적으로 fluidPage()를 사용한다고 생각하면 된다.\n\ntitlePanel() : 제목이 들어가는 부분이다. 생략가능하다.\n\nsidebarLayout(): UI의 핵심 부분으로, 가장 전형적인 “사이드바 + 메인 영역” 레이아웃을 fluidPage() 내에 생성할 수 있게 해준다.\n\nsidebarPanel(): 입력을 받는 부분으로, 입력 함수 혹은 입력 위젯(widget)을 담는 컨테이너이다.\nmainPanel() : 출력을 표출하는 부분으로, 서버에서 생성된 출력 객체가 UI에 표시될 수 있도록 출력 표출(바인딩) 함수를 담는 컨테이너이다.\n\n\n\n\n\n둘째, sidebarPanel() 내의 sliderInput()은 특정한 입력 함수 혹은 입력 위젯 생성 함수이다. 여기서는 슬라이더바 형태의 입력을 받기 때문에 sliderInput() 함수가 사용된 것이다. 입력의 형태에 따라 다양한 입력 함수가 존재하며, 일반적으로 *Input() 형식을 띤다. 뒤에서 자세히 다룬다. 개별 함수는 상호작용형 인터페이스 컴포넌트로 미리 만들어져 있기 때문에 위젯이라고 부른다. sliderInput()은 다양한 인수로 구성되어 있는데, 가장 중요한 것이 inputId 인수이다. 입력 함수는 위젯을 통해 입력값을 받고 그 입력값은 Server의 input 객체의 한 요소가 되는데 inputId 인수는 input 객체에서 해당 요소를 참조할 ’이름’을 지정한다.\n셋째, mainPanel() 내의 plotOutput()은 특정한 출력 표출 함수 혹은 출력 바인딩(binding) 함수이다. 이것은 Server에서 전달받은 출력 즉 output 객체의 요소를 표출한다. 바인딩 함수라고 부르는 것은 출력 요소와 브라우저의 특정 UI 영역을 ’연결(바인드)’하기 때문이다. 출력의 형태가 플롯(plot)이기 때문에 plotOutput() 함수가 사용된 것이다. 출력의 형태에 따라 다양한 출력 표출 함수가 존재하며, 일반적으로 *Output()의 형식을 띤다. 뒤에서 자세히 다룬다. plotOutput() 함수의 가장 중요한 인수는 outputId로 표출할 output 객체의 요소의 ’이름’을 지정한다. plotOutput(outputId = \"distPlot\")는 서버에서 만들어진 \"distPlot\"라는 이름의 플롯(output 객체의 한 요소)을 해당 위치에 표출한다는 의미이다.\n\n결국 UI는 입력을 받고 출력을 표출하는 두 가지 일을 하는데, 전자는 sliderInput()과 같은 입력 함수를 통해 이루어지며, 후자는 plotOutput()과 같은 출력 표출 함수를 통해 이루어진다. 이들 함수는 출력과 입력의 형식에 따라 일반적으로 *Input()과 *Output()의 형태를 띤다.\n\n\n2.2 Server 부분\nServer 부분은 다음과 같은 구조를 가지고 있다.\n첫째, Server 부분은 반드시 함수로 정의되며, 일반적으로 function(input, output){} 혹은 function(input, output, session){}의 형식을 갖는다(input과 output은 필수이지만 session은 부가적으로 정의될 수 있다). 반드시 함수로 정의되어야 하는 것은 input과 output(부가적으로 session)을 인수로 받아, 입력 변화에 따라 반응형 출력이 생성 및 갱신되는 로직을 정의하기 때문입니다.\n둘째, 출력물은 renderPlot({})과 같은 출력 생성 함수(렌더링 함수)를 통해 이루어진다. 이렇게 생성된 출력은 ’이름’이 지정되어 Server의 output 객체의 한 원소로 저장된다. 예를 들어, 코드에서 output$distPlot은 생성된 출력에 \"distPlot\"이라는 이름을 부여하고 이를 output 객체에 저장함을 의미한다. 이 이름은 UI의 출력 표출 함수 plotOutput(outputId = \"distPlot\")에서 사용되며, 이를 통해 해당 출력이 UI에 표출된다.\n셋째, 출력의 형태가 플롯이기 때문에 renderPlot({}) 함수가 사용된 것이다. 출력의 형태에 따라 다양한 출력 생성 함수가 존재하며, 일반적으로 render*({})의 형식을 띤다. 뒤에서 자세히 다룬다.\n넷째, 입력 함수로부터 전달되어 Server의 input 객체의 요소로 저장된 입력값은 출력 생성 함수 내부에서 사용된다. 예를 들어, seq(min(x), max(x), length.out = input$bins + 1)에서 sliderInput() 함수로부터 전달된 bins라는 입력값(즉, input 객체의 한 요소)이 seq() 함수 내부에서 사용된다. 입력값이 달라짐에 따라 히스토그램의 모양이 달라지는 이유가 여기에 있다.\n\n결국 Server는 UI에서 전달된 입력에 기반하여 출력을 산출한다. 구체적으로, input$* 형식의 입력값을 Server 내부에서 사용하여 renderPlot({})와 같은 출력 생성 함수를 통해 출력을 생성하고, 그 결과를 output$* 형식으로 저장함으로써 UI에 표출될 수 있도록 한다.\n\n\n2.3 결합 및 실행 부분\nUI와 server 부분은 결합되어 하나의 Shiny 웹 앱을 구성하며, 이를 실행하기 위해 shinyApp() 함수가 사용된다. shinyApp(ui = ui, server = server)에서 볼 수 있듯이, shinyApp() 함수에 UI 부분과 Server 부분을 지정함으로써 Shiny 웹 앱이 생성되고 실행된다.\n이것은 단일 파일 방식으로 결합 및 실행을 하는 것이다. 콘솔창에서 실행하고자 한다면 다음과 같이하면 된다. 파일명에 app.R과 같은 UI와 Server 부분이 모두 포함된 파일의 이름을 지정하면 된다.\n\nrunApp(\"파일명\")\n\n만일 UI와 Server 부분을 다른 파일로 구성하는 분리 파일 방식인 경우는 다음과 같이 진행한다. 우선 UI 부분의 파일을 따로 만든다. 예를 들어 ui.R이라는 스크립트 파일을 다음과 같이 생성한다. 단일 파일 방식과 달리 UI 부분을 ui 객체에 할당하지 않아도 된다.\n\nlibrary(shiny)\n\nfluidPage(\n    titlePanel(\"Old Faithful Geyser Data\"),\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(inputId = \"bins\",\n                        label = \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n        mainPanel(\n           plotOutput(outputId = \"distPlot\")\n        )\n    )\n)\n\n마찬가지로 Server 부분의 파일을 따로 만든다. 예를 들어 server.R이라는 스크립트 파일을 다음과 같이 생성한다. 단일 파일 방식과 달리 Server 부분을 server라는 객체에 할당하지 않아도 된다.\n\nlibrary(shiny)\n\nfunction(input, output) {\n    output$distPlot &lt;- renderPlot({\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\n콘솔 창에서 다음과 같이 실행한다. 이때 지정한 폴더에는 UI 부분을 정의한 파일(예: ui.R)과 server 부분을 정의한 파일(예: server.R)이 포함되어 있어야 한다. 이름은 반드시 ui.R과 server.R이어야 한다.\n\nrunApp(\"폴더명\")\n\n위의 두 가지 방식을 결합한 제3의 길도 있다. 우선 위의 분리 파일 방식과 같이 UI와 Server 부분에 대한 파일을 개별적을 생성한다. 차이점은 반드시 ui와 server 객체를 할당하는 방식으로 이러우져야 한다는 점이다. my_ui.R의 내용은 다음과 같다. 이 방식에서는 UI 부분의 파일 이름이 반드시 ui.R일 필요가 없다.\n\nui &lt;- fluidPage(\n    titlePanel(\"Old Faithful Geyser Data\"),\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(inputId = \"bins\",\n                        label = \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n        mainPanel(\n           plotOutput(outputId = \"distPlot\")\n        )\n    )\n)\n\nmy_server.R의 내용은 다음과 같다. 마찬가지로 Server 부분의 파일의 이름이 server.R일 필요가 없다.\n\nserver &lt;- function(input, output) {\n    output$distPlot &lt;- renderPlot({\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\n그리고 나서 단일 파일 방식과 같이 app.R 파일을 통해 결합한다. app.R 파일의 내용은 다음과 같다.\n\nlibrary(shiny)\n\nsource(\"my_ui.R\")\nsource(\"my_server.R\")\n\nshinyApp(ui = ui, server = server)\n\nUI 파일과 Server 파일을 분리하는 방식은 코드가 매우 복잡할 때 사용하는 것으로 보통은 단일 파일 방식을 사용한다.",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#반응성-함수",
    "href": "exec_11.html#반응성-함수",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n4 반응성 함수",
    "text": "4 반응성 함수\n\n4.1 정의\nShiny의 반응성(reactivity)이란, 입력값의 변화에 따라 관련된 계산과 출력이 자동으로 재실행ㆍ갱신되는 메커니즘을 의미한다. 좀 더 기술적으로 표현하면 반응성은 입력(input)의 변화가 의존 관계(dependency)를 따라 전파되어, 반응형 표현식과 출력이 자동으로 갱신되는 실행 모델이다.\n반응성 함수란, 입력값에 대한 의존성을 추적하고 입력 변화 시 자동으로 재실행되는 함수를 말한다. 따라서 Shiny에서 반응성 함수는 공통적으로 다음 특징을 갖는다.\n\ninput$*에 의존\n입력이 바뀌면 자동으로 재실행\n사용자가 직접 호출하지 않음\nShiny의 반응성 그래프(dependency graph)에 의해 관리됨\n\n4.2 종류\nShiny의 반응성 함수는 역할에 따라 크게 세 부류로 나눌 수 있다.\n\n4.2.1 출력 생성 함수: render* 계열\n출력 생성 함수는 반응형 계산을 통해 출력물을 생성하고, 그 결과를 output 객체의 요소로 저장하는 함수이다. 일반 형식은 다음과 같다.\n\nrender*({\n  # 반응형 코드\n})\n\n반드시 output$이름 &lt;- render*({ ... }) 형태로 사용되며, 출력의 “최종 종착점”이며, UI의 *Output()과 1:1로 대응된다. 예시는 다음과 같다.\n\noutput$distPlot &lt;- renderPlot({\n  hist(x, breaks = input$bins)\n})\n\n\n4.2.2 반응형 표현식 함수: reactive({})\n\nreactive({})는 입력값에 따라 달라지는 계산 결과를 반응형 객체로 생성하는 함수이다. 입력을 받아 ’반응성 표현식(reactive expression)’을 생성한다. 여기서 반응성 표현식이란 단순히 최종 산출물(값이나 객체)만을 의미하지 않고, 그 산출물을 관리하는 메커니즘(종속성 추적, 지연 실행, 캐싱 등) 포함하는 동적인 객체를 의미한다. 따라서 반드시 함수 형태로 표기한다.\n하나의 입력이 여러 개의 출력 함수(출력 생성 함수)와 결부되는 경우에 주로 사용되는데 동일한 입력의 중복 사용을 회피하기 위해 해당 입력을 반응성 표현식으로 전환하여 다수의 출력 생성 함수에 입력으로 투입할 수 있다.\n일반 형식은 다음과 같다.\n\nr &lt;- reactive({\n  # 반응형 계산\n})\n\n출력이 아니라 중간 계산 결과를 생성하며, 반환값은 반응형 객체가 되고, 값에 접근할 때는 함수 형식으로 반드시 () 를 사용해야 한다. 예시는 다음과 같다.\n\nbins &lt;- reactive({\n  seq(min(x), max(x), length.out = input$bins + 1)\n})\n\noutput$distPlot &lt;- renderPlot({\n  hist(x, breaks = bins())\n})\n\n입력 함수를 통해 받은 input$bins를 읽어 bins라는 새로운 반응형 객체를 생성하고, 그것을 출력 생성 함수에서 투입하는 방식을 보여주고 있다. 반응형 객체는 반드시 bins()처럼 함수 형식으로 호출해야만 한다.\n그런데, 여기서는 사실 reactive({}) 함수가 반드시 필요한 것은 아니다. 즉, 다음과 같이 해도 무방하다.\n\nbins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\noutput$distPlot &lt;- renderPlot({\n  hist(x, breaks = bins)\n})\n\n그러나 출력 생성 함수가 여러 개 사용되고 거기에 bins가 여러 번 사용된다면 위와 같이 하는 것이 훨씬 효율적이다.\n\n4.2.3 반응형 관찰자 함수: observe*() 계열\n반응형 관찰자 함수는 입력 변화에 반응하여 특정 동작(side effect)을 수행하는 함수이다. 대표적인 함수는 다음과 같다.\n\nobserve()\nobserveEvent()\neventReactive() (중간적 성격)\n\n특징은 값을 반화하지 않고, 출력 생성이 목적도 아니다. 주로 상태 변경, 메시지 출력, UI 업데이트에 사용된다. 다음에 예시가 있다.\n\nobserveEvent(input$go, {\n  cat(\"버튼이 눌렸습니다\\n\")\n})\n\n입력 함수 actionButton(inputID = \"go\", ...)로부터 버튼을 누를 때 마다 \"go\"라는 입력 요소의 값(input$go)이 1씩 증가하고, input$go값이 변할 때마다(즉, 버튼이 눌릴 때마다) Server에서 { } 속의 내용을 실행한다. 위의 예시의 경우 버튼을 클리할 때마다 콘솔에 “버튼이 눌렸습니다”가 출력된다.\n좀 더 현실적인 예시를 제시하면 다음과 같다. 버튼 클릭시 계산을 실행하게 할 수 있다.\n\nobserveEvent(input$go, {\n  result &lt;- heavy_calculation()\n  print(result)\n})\n\nUI 요소를 업데이트하게 할 수 있다.\n\nobserveEvent(input$go, {\n  updateSliderInput(session, \"bins\", value = 20)\n})\n\n파일을 저장하게 할 수 있다.\n\nobserveEvent(input$save, {\n  write.csv(data, \"result.csv\")\n})\n\n사실 observeEvent() 함수는 observe() 함수와 매우 유사하다. 아래는 동일하게 작동한다.\n\nobserve({\n  input$go\n  cat(\"버튼이 눌렸습니다\\n\")\n})\n\n그러나 observeEvent()는 이벤트 중심이고, 의존성을 명확히 분리하며, 가독성과 안전성을 높이는 장점이 있다. 따라서 버튼 처리에는 observeEvent()가 권장된다.",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#웹-앱-배포deployment",
    "href": "exec_11.html#웹-앱-배포deployment",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n5 웹 앱 배포(deployment)",
    "text": "5 웹 앱 배포(deployment)\n웹 앱을 배포하는 방법은 다양할 수 있지만 여기서는 shinyapp.io를 이용하는 방법에 대해 배운다.\n첫째, 해당 홈페이지(https://www.shinyapps.io/)에 접속한다.\n둘째, 계정을 생성한다.\n\n로그인 후 상단 오른쪽 끝 메뉴 “Tokens” 페이지로 이동\n페이지에서 Show를 통해 인증 토큰(Token)과 Secret 확보: Show secret를 클릭하여 secret까지 보이게 한 후 복사하기\n\n셋째, RStudio에 토큰을 설정한다. 단 한 번만 하면 된다.\n\nR 콘솔에 위에서 복사한 내용 붙여넣기 및 실행\n\n넷째, Publish 버튼 클릭\n\n스크립트 윈도우의 오른쪽 상단에 있는 Publish 버튼 클릭\n배포를 원하는 R 파일만 선택\n\n다섯째, URL을 얻는다. 다음의 형식으로 생성된다.\n\nhttps://userid.shinyapps.io/project_name/",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#웹-앱의-공유",
    "href": "exec_11.html#웹-앱의-공유",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n6 웹 앱의 공유",
    "text": "6 웹 앱의 공유\n\n6.1 웹 앱 배포(deployment)\n웹 앱을 배포하는 방법은 다양할 수 있지만 여기서는 shinyapp.io를 이용하는 방법에 대해 배운다.\n첫째, 해당 홈페이지(https://www.shinyapps.io/)에 접속한다.\n둘째, 계정을 생성한다.\n\n로그인 후 상단 오른쪽 끝 메뉴 “Tokens” 페이지로 이동\n페이지에서 Show를 통해 인증 토큰(Token)과 Secret 확보: Show secret를 클릭하여 secret까지 보이게 한 후 복사하기\n\n셋째, RStudio에 토큰을 설정한다. 단 한 번만 하면 된다.\n\nR 콘솔에 위에서 복사한 내용 붙여넣기 및 실행\n\n넷째, Publish 버튼 클릭\n\n스크립트 윈도우의 오른쪽 상단에 있는 Publish 버튼 클릭\n배포를 원하는 R 파일만 선택\n\n다섯째, URL을 얻는다. 다음의 형식으로 생성된다.\n\nhttps://userid.shinyapps.io/project_name/\n\n6.2 Quarto와 Shiny의 결합\n\n상황: Quarto 대시보드의 일부 영역에서 Shiny 사용\n\n두 가지 접근\n\n\nShiny 중심 방식: Shiny 웹 앱의 생성\n\nQuarto 대시보드 내에서 Quarto 문법으로 Shiny 웹 앱 구축\nQuarto 대시보드 전체가 Shiny 웹 앱화: shinyapps.io를 통해 배포\n사례: https://sangillee.shinyapps.io/Dashboard_Example/\n\n\n\nQuarto 중심 방식: Quarto 대시보드의 유지\n\nQuarto 대시보드 속에 독립적으로 구축된 Shiny 웹 앱 임베딩\n여전히 Quarto 대시보드: Quarto Pub을 통해 배포\n사례: https://sangillee.snu.ac.kr/dashboard_examples/\n\n\n\n\n\n\n6.2.1 Shiny 중심 방식\n\n\n옵션 1: Quarto를 Shiny 웹 앱의 레이아웃 설정 도구로 사용\n\n\nshiny 패키지: fluidPage()\n\n\ntitlePanel(), SidebarLayout(), sidebarPanel(), mainPanel()\n\n\n\n\nbslib 패키지: page_sidebar()\n\n\nsidebar = sidebar(), card()\n\n\n\n\n\n옵션 2: Quarto 대시보드 내에서 Shiny 웹 앱 구축\nhttps://quarto.org/docs/dashboards/interactivity/shiny-r.html\nYAML 헤더에 다음 첨가: server: shiny\n\nui 부분: 기본적으로는 r 코드 청크 속에 포함, 사이드바와 메인 병렬\n\n사이드바: 레이아웃 구성요소에 넣고 {.sidebar} CSS 클래스 지정 가능\n메인: 사이드바와 다른 레이아웃 구성요소에 넣기 가능\n\n\n\nserver 부분: r 코드 청크 속에 포함, 다음 지정\n\n\n#| context: server 지정\n\n\n\n기타(패키지, 데이터 등) 부분: r 코드 청크 속에 포함, 다음 지정\n\n#| context: setup\n#| include: false\n\n\n\n6.2.2 Quarto 중심 방식\n\n보통 하나의 row에 임베딩\nsrc=\"\" 부분만 교체\n\n&lt;iframe src=\"https://...\" loading=\"lazy\" style=\"width: 100%; height: 600px; border: 0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#고차-주제",
    "href": "exec_11.html#고차-주제",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n7 고차 주제",
    "text": "7 고차 주제\n\n7.1 LLM-기반 ChatBot 웹 앱",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#bslib-패키지의-활용",
    "href": "exec_11.html#bslib-패키지의-활용",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n5 bslib 패키지의 활용",
    "text": "5 bslib 패키지의 활용",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  }
]