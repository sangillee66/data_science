[
  {
    "objectID": "exec_11.html",
    "href": "exec_11.html",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "",
    "text": "여기서는 웹 앱 개발 도구로서의 Shiny에 대해 배운다. Shiny는 서버-기반의 웹 앱을 개발하기 위한 프레임워크를 제공한다. 원래 R 패키지로 개발되었으나 이제는 R과 Python 모두를 위한 웹 앱 개발 도구로 발전하고 있다.\n\nShiny for R\nShiny for Python\n\nShiny를 배우기 위한 다양한 리소스가 존재한다. 가장 중요한 리소스는 Shiny for R 홈페이지이다. Get Started를 살펴본 후 Gallery의 다양한 예제를 살펴보는 것으로 시작하는 것이 좋다. 이 홈페이지의 내용만으로도 Shiny의 기본 구조와 문법을 익히기에 충분하다.\n좀 더 종합적으로 Shiny을 이해하려면 다음의 웹 북을 활용할 수 있다. 첫 번째가 바이블이라고 할 수 있다.\n\nMastering Shiny by Hadley Wickham\nOutstanding User Interfaces with Shiny\nEngineering Production-Grade Shiny Apps\nInteractive Web-Based Data Visualization with R, plotly, and shiny\nR Shiny Applications in Finance, Medicine Pharama and Education Industry\nIntroduction to Data Science: 25 Shiny Applications\n데이터 사이언스를 위한 R 프로그래밍: 14 shiny",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "exec_11.html#개요",
    "href": "exec_11.html#개요",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "",
    "text": "여기서는 웹 앱 개발 도구로서의 Shiny에 대해 배운다. Shiny는 서버-기반의 웹 앱을 개발하기 위한 프레임워크를 제공한다. 원래 R 패키지로 개발되었으나 이제는 R과 Python 모두를 위한 웹 앱 개발 도구로 발전하고 있다.\n\nShiny for R\nShiny for Python\n\nShiny를 배우기 위한 다양한 리소스가 존재한다. 가장 중요한 리소스는 Shiny for R 홈페이지이다. Get Started를 살펴본 후 Gallery의 다양한 예제를 살펴보는 것으로 시작하는 것이 좋다. 이 홈페이지의 내용만으로도 Shiny의 기본 구조와 문법을 익히기에 충분하다.\n좀 더 종합적으로 Shiny을 이해하려면 다음의 웹 북을 활용할 수 있다. 첫 번째가 바이블이라고 할 수 있다.\n\nMastering Shiny by Hadley Wickham\nOutstanding User Interfaces with Shiny\nEngineering Production-Grade Shiny Apps\nInteractive Web-Based Data Visualization with R, plotly, and shiny\nR Shiny Applications in Finance, Medicine Pharama and Education Industry\nIntroduction to Data Science: 25 Shiny Applications\n데이터 사이언스를 위한 R 프로그래밍: 14 shiny",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "exec_11.html#기본-구조",
    "href": "exec_11.html#기본-구조",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "1 기본 구조",
    "text": "1 기본 구조\nShiny는 크게 세 부분으로 나뉘어 진다(그림 1).\n첫째, ui(혹은 ux) 부분이다. 프론트엔트(front-end) 부분으로 입력을 받고 출력을 표출하는 부분이다.\n둘째, server 부분이다. 백엔드(back-end) 부분으로 받은 입력으로 출력을 산출하는 부분이다.\n셋째, 결합 부분이다. ui와 server 부분을 결합해 웹 앱을 실행하는 부분이다.\n\n\n\n\n\n\n그림 1: Shiny의 구조(https://bookdown.org/hneth/i2ds/shiny.html)\n\n\n\n이건 좀 이상하다. 이상일 이상일",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "웹사이트 소개",
    "section": "",
    "text": "이 웹사이트는 데이터사이언스(Data Science)를 위한 개인 공부방으로 디자인되었다 .\n하지만 서울대학교에서 내가 개설한 데이터사이언스 관련 교과목의 보충 웹사이트로 활용될 수도 있다.\n\n2025/2 M3449.000300 AI 융합교육을 위한 인문사회 콘텐츠 설계 (Designing Human and Social Education Contents for AI Convergence Education)\n2024/1 M3450.001400 AI 융합교육을 위한 인문사회 컨텐츠 설계 (Designing Human and Social Education Contents for AI Convergence Education)",
    "crumbs": [
      "웹사이트 소개"
    ]
  },
  {
    "objectID": "index.html#웹사이트의-목적",
    "href": "index.html#웹사이트의-목적",
    "title": "웹사이트 소개",
    "section": "",
    "text": "이 웹사이트는 데이터사이언스(Data Science)를 위한 개인 공부방으로 디자인되었다 .\n하지만 서울대학교에서 내가 개설한 데이터사이언스 관련 교과목의 보충 웹사이트로 활용될 수도 있다.\n\n2025/2 M3449.000300 AI 융합교육을 위한 인문사회 콘텐츠 설계 (Designing Human and Social Education Contents for AI Convergence Education)\n2024/1 M3450.001400 AI 융합교육을 위한 인문사회 컨텐츠 설계 (Designing Human and Social Education Contents for AI Convergence Education)",
    "crumbs": [
      "웹사이트 소개"
    ]
  },
  {
    "objectID": "index.html#웹사이트의-구조",
    "href": "index.html#웹사이트의-구조",
    "title": "웹사이트 소개",
    "section": "웹사이트의 구조",
    "text": "웹사이트의 구조\n\n데이터 사이언스 관련 내용을 모두 10개의 하위 섹션으로 나누었다.\n각 하위 섹션은 세 개의 콘텐츠를 갖는다.\n\n내용 강의\n실습 강의\n실습",
    "crumbs": [
      "웹사이트 소개"
    ]
  },
  {
    "objectID": "index.html#참고문헌",
    "href": "index.html#참고문헌",
    "title": "웹사이트 소개",
    "section": "참고문헌",
    "text": "참고문헌\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund, 2023, R for Data Science: Import, Tidy, Transform, Visualize, and Model Data, 2nd edition, Boston: O’Reilly. \n\n이 사이트의 내용은 위의 책에 많은 토대를 두고 있다.\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. 1st edition. Sebastopol, CA: O’Reilly. (김설기ㆍ최혜민 옮김, 2019, R을 활용한 데이터 과학: 데이터 불러오기, 정리하기, 변형하기, 시각화하기, 모델링하기, 1판, 서울: 인사이트.)\nBonnell, Jerry, and Mitsunori Ogihara. 2023. Exploring Data Science with R and the Tidyverse. 1st edition. Chapman; Hall/CRC.\nIrizarry, Rafael A. 2024. Introduction to Data Science: Data Wrangling and Visualization with R. 2nd edition, Boca Raton: CRC Press.\nIrizarry, Rafael A. 2024. Introduction to Data Science: Statistics and Prediction Algorithms Through Case Studies. Boca Raton: CRC Press.\nIrizarry, Rafael A. 2020. Introduction to Data Science: Data Analysis and Prediction Algorithms with R. Boca Raton: CRC Press.\nAlexander, R., 2023, Telling Stories with Data: With Applications in R, Boca Raton: CRC Press.\nGrolemund, Garrett. 2014. Hands-On Programming with R: Write Your Own Functions and Simulations. O’Reilly Media, Inc..\nStauffer, R., Chimiak-Opoka, Joanna, Rodríguez-R, Luis Miguel, Simon, Thorsten, Zeileis, Achim, 2024, Introduction to Programming with R, 웹북\nDouglas, Alex, Roos, Deon, Mancini, Francesca, Couto Ana, Lusseau, David, 2024, An Introduction to R, 웹북\nBatra, Neale, ed., 2024, The Epidemiologist R Handbook, 웹북\nDoser, Jeffrey W., Finley, Andrew O., Melfi, Vince, 2022, R Programming for Data Sciences, 웹북\nBonnin, Sarah, 2020, Introduction to R 2021, 웹북\nGrolemund, Garrett, 2020, The Tidyverse Cookbook, 웹북\nAnsell, Brendan R. E. , Introduction to R - tidyverse, 웹북\nSarafian, Ron, Introduction to Data Science, 웹북\nIntroduction to R, 웹북\nData Analysis and Visualization in R for Ecologists, 웹북\nR for Epidemiology, 웹북\nRStudio IDE User Guide (https://docs.posit.co/ide/user/)\n한국알사용자회, 데이터 과학을 지탱하는 기본기, 웹북\n한국알사용자회, 데이터 시각화, 웹북\n한국알사용자회ㆍ이광춘, 2024, 챗GPT쿼토: 인공지능 시대 과학기술 저작 도구, 웹북\n김기환, 2023, R 프로그래밍(개정판), 웹북\n백영민. 2023. R 기반 데이터 과학: 타이디버스(tidyverse) 접근. 서울: 한나래아카데미.\n차영준ㆍ박진표, 2022, 데이터과학 입문을 위한 R과 타이디버스, 파주: 자유아카데미.\n곽기영, 2022, R 기초와 활용, 서울: 청람.\n강전희ㆍ엄동란, 2018, 처음 시작하는 R 데이터 분석, 서울: 한빛미디어.\n김영우, 2017, 쉽게 배우는 R 데이터 분석, 서울: 이지스퍼블리싱.",
    "crumbs": [
      "웹사이트 소개"
    ]
  },
  {
    "objectID": "lab_04.html",
    "href": "lab_04.html",
    "title": "Lab04: 데이터 변형하기",
    "section": "",
    "text": "아래의 함수들을 활용하여 데이터를 적절하게 변형할 수 있다.\n\n\n행 함수\n열 함수\n그룹 함수",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_04.html#실습의-목표",
    "href": "lab_04.html#실습의-목표",
    "title": "Lab04: 데이터 변형하기",
    "section": "",
    "text": "아래의 함수들을 활용하여 데이터를 적절하게 변형할 수 있다.\n\n\n행 함수\n열 함수\n그룹 함수",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_04.html#실습-준비",
    "href": "lab_04.html#실습-준비",
    "title": "Lab04: 데이터 변형하기",
    "section": "\n1 실습 준비",
    "text": "1 실습 준비\n\nlibrary(tidyverse)\n\n사용할 데이터는 World Bank가 gapmider.org를 통해 무료로 배포하는 것으로 gapmider 패키지에 포함되어 있다. gapmider 패키지를 인스톨하고 불러온다. 데이터가 어떻게 구성되어 있는지 살펴본다.\n\nlibrary(gapminder)\nView(gapminder)",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_04.html#행-함수",
    "href": "lab_04.html#행-함수",
    "title": "Lab04: 데이터 변형하기",
    "section": "\n2 행 함수",
    "text": "2 행 함수\n\n2.1 filter() 함수\n특정 열(변수)과 관련된 조건을 만족하는 행을 선정한다. 행의 길이가 준다.\n\n# continent의 값이 Europe인 행만 선택\ngapminder |&gt; \n  filter(continent == \"Europe\") \n\n# A tibble: 360 × 6\n   country continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Albania Europe     1952    55.2 1282697     1601.\n 2 Albania Europe     1957    59.3 1476505     1942.\n 3 Albania Europe     1962    64.8 1728137     2313.\n 4 Albania Europe     1967    66.2 1984060     2760.\n 5 Albania Europe     1972    67.7 2263554     3313.\n 6 Albania Europe     1977    68.9 2509048     3533.\n 7 Albania Europe     1982    70.4 2780097     3631.\n 8 Albania Europe     1987    72   3075321     3739.\n 9 Albania Europe     1992    71.6 3326498     2497.\n10 Albania Europe     1997    73.0 3428038     3193.\n# ℹ 350 more rows\n\n\n\n # pop이 5천만, gdpPercap이 3만을 초과하는 행만 선택\ngapminder |&gt; \n  filter(pop &gt; 50000000 & gdpPercap &gt; 30000)\n\n# A tibble: 9 × 6\n  country        continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;          &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 France         Europe     2007    80.7  61083916    30470.\n2 Germany        Europe     2002    78.7  82350671    30036.\n3 Germany        Europe     2007    79.4  82400996    32170.\n4 Japan          Asia       2007    82.6 127467972    31656.\n5 United Kingdom Europe     2007    79.4  60776238    33203.\n6 United States  Americas   1992    76.1 256894189    32004.\n7 United States  Americas   1997    76.8 272911760    35767.\n8 United States  Americas   2002    77.3 287675526    39097.\n9 United States  Americas   2007    78.2 301139947    42952.\n\n\n\n# year이 2007이고, lifeExp가 82를 초과하거나 gdpPercap이 4만을 초과하는 행만 선택\ngapminder |&gt; \n  filter(year == 2007 & (lifeExp &gt; 82 | gdpPercap &gt; 40000))\n\n# A tibble: 7 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Hong Kong, China Asia       2007    82.2   6980412    39725.\n2 Ireland          Europe     2007    78.9   4109086    40676.\n3 Japan            Asia       2007    82.6 127467972    31656.\n4 Kuwait           Asia       2007    77.6   2505559    47307.\n5 Norway           Europe     2007    80.2   4627926    49357.\n6 Singapore        Asia       2007    80.0   4553009    47143.\n7 United States    Americas   2007    78.2 301139947    42952.\n\n\n\n2.2 slice() 함수\nfilter() 함수와 마찬가지로 행의 숫자를 줄인다. slice() 함수는 slice_head(), slice_tail(), slice_max(), slice_min()과 같은 패밀리 함수가 더 널리 사용된다. 그런데 이 함수들은 작동 방식에 따라 두 가지로 구분된다.\n\n특정 열(변수)과 관계 없이, 행의 위치에 의거해 행을 선정: slice(), slice_head(), slice_tail()\n특정 열(변수)에 따른, 행의 위치에 의거해 행을 선정: slice_max(), slice_min()\n\n몇 번째에서 몇 번째 사이의 행만을 골라낸다.\n\n# 1~5행만을 선택\ngapminder |&gt; \n  slice(1:5)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n\n\n가장 앞에 위치한 몇 개(n)의 행만을 골라낸다. 실질적으로 위와 동일하다.\n\n# 가장 앞의 5개 행을 선택\ngapminder |&gt; \n  slice_head(n = 5)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n\n\n\n\n\n\n\n\n힌트\n\n\n\nBase R 함수인 head()또한 같은 역할을 할 수 있다.\n\ngapminder |&gt; \n  head(5)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n\n\n\n\n가장 뒤에 위치한 몇 개(n)의 행만을 골라낸다.\n\n# 가장 뒤의 5개 행을 선택\ngapminder |&gt; \n  slice_tail(n = 5)\n\n# A tibble: 5 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Zimbabwe Africa     1987    62.4  9216418      706.\n2 Zimbabwe Africa     1992    60.4 10704340      693.\n3 Zimbabwe Africa     1997    46.8 11404948      792.\n4 Zimbabwe Africa     2002    40.0 11926563      672.\n5 Zimbabwe Africa     2007    43.5 12311143      470.\n\n\n\n\n\n\n\n\n힌트\n\n\n\nBase R 함수인 tail()또한 같은 역할을 할 수 있다.\n\ngapminder |&gt; \n  tail(5)\n\n# A tibble: 5 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Zimbabwe Africa     1987    62.4  9216418      706.\n2 Zimbabwe Africa     1992    60.4 10704340      693.\n3 Zimbabwe Africa     1997    46.8 11404948      792.\n4 Zimbabwe Africa     2002    40.0 11926563      672.\n5 Zimbabwe Africa     2007    43.5 12311143      470.\n\n\n\n\n특정 열(변수)에 따라 값이 가장 큰 몇 개(n)의 행만을 골라낸다.\n\n# 2007년에 gdpPercap이 가장 큰 5개국 찾기\ngapminder |&gt; \n  filter(year == 2007) |&gt; # year이 2007인 행만 선택\n  slice_max(gdpPercap, n = 5) # gdpPercap이 가장 큰 5개 행 선택\n\n# A tibble: 5 × 6\n  country       continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Norway        Europe     2007    80.2   4627926    49357.\n2 Kuwait        Asia       2007    77.6   2505559    47307.\n3 Singapore     Asia       2007    80.0   4553009    47143.\n4 United States Americas   2007    78.2 301139947    42952.\n5 Ireland       Europe     2007    78.9   4109086    40676.\n\n\n특정 열(변수)에 따라 값이 가장 작은 것들 중 주어진 비중(prop)에 해당하는 행만을 골라낸다.\n\n# 2007년 아시아에서 lifeExp가 하위 10%인 국가 찾기\ngapminder |&gt; \n  filter(year == 2007 & continent == \"Asia\") |&gt; # year이 2007이고 continent가 Asia인 행만 선택\n  slice_min(lifeExp, prop = 0.1) # lifeExp가 작은 순으로 10% 행만 선택\n\n# A tibble: 3 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       2007    43.8 31889923      975.\n2 Iraq        Asia       2007    59.5 27499638     4471.\n3 Cambodia    Asia       2007    59.7 14131858     1714.\n\n\n\n2.3 arrange() 함수\n특정 열(변수)과 관련된 조건에 의거해 행의 순서를 바꾼다. 행의 길이에는 변화가 없다.\n\n# lifeExp 오름차순으로 행 정렬\ngapminder |&gt; \n  arrange(lifeExp)\n\n# A tibble: 1,704 × 6\n   country      continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Rwanda       Africa     1992    23.6 7290203      737.\n 2 Afghanistan  Asia       1952    28.8 8425333      779.\n 3 Gambia       Africa     1952    30    284320      485.\n 4 Angola       Africa     1952    30.0 4232095     3521.\n 5 Sierra Leone Africa     1952    30.3 2143249      880.\n 6 Afghanistan  Asia       1957    30.3 9240934      821.\n 7 Cambodia     Asia       1977    31.2 6978607      525.\n 8 Mozambique   Africa     1952    31.3 6446316      469.\n 9 Sierra Leone Africa     1957    31.6 2295678     1004.\n10 Burkina Faso Africa     1952    32.0 4469979      543.\n# ℹ 1,694 more rows\n\n\ndesc() 도우미 함수(helper function)는 내림차순으로 행을 배열한다.\n\n# year 오름차순으로 행 정렬 후 같은 year 안에서 lifeExp 내림차순으로 행 정렬\ngapminder |&gt; \n  arrange(year, desc(lifeExp))\n\n# A tibble: 1,704 × 6\n   country        continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;          &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Norway         Europe     1952    72.7  3327728    10095.\n 2 Iceland        Europe     1952    72.5   147962     7268.\n 3 Netherlands    Europe     1952    72.1 10381988     8942.\n 4 Sweden         Europe     1952    71.9  7124673     8528.\n 5 Denmark        Europe     1952    70.8  4334000     9692.\n 6 Switzerland    Europe     1952    69.6  4815000    14734.\n 7 New Zealand    Oceania    1952    69.4  1994794    10557.\n 8 United Kingdom Europe     1952    69.2 50430000     9980.\n 9 Australia      Oceania    1952    69.1  8691212    10040.\n10 Canada         Americas   1952    68.8 14785584    11367.\n# ℹ 1,694 more rows\n\n\n\n2.4 distinct() 함수\n특정 열(변수)에 의거해 중복이 없이 고유한 행만을 골라낸다. 행의 길이가 준다.\n\n# country 변수 안에 어떤 값들이 포함되어 있는지 확인\ngapminder |&gt; \n  distinct(country)\n\n# A tibble: 142 × 1\n   country    \n   &lt;fct&gt;      \n 1 Afghanistan\n 2 Albania    \n 3 Algeria    \n 4 Angola     \n 5 Argentina  \n 6 Australia  \n 7 Austria    \n 8 Bahrain    \n 9 Bangladesh \n10 Belgium    \n# ℹ 132 more rows\n\n\n.keep_all 아규먼트를 이용하면 나머지 열도 함께 나타낼 수 있다. 같은 값을 가진 행이 다수 존재한다면 가장 앞선 행을 보여준다.\n\n# continent 변수 안에 어떤 값들이 포함되어 있는지 나머지 열과 함께 확인\ngapminder |&gt; \n  distinct(continent, .keep_all = TRUE)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Albania     Europe     1952    55.2  1282697     1601.\n3 Algeria     Africa     1952    43.1  9279525     2449.\n4 Argentina   Americas   1952    62.5 17876956     5911.\n5 Australia   Oceania    1952    69.1  8691212    10040.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_04.html#열-함수",
    "href": "lab_04.html#열-함수",
    "title": "Lab04: 데이터 변형하기",
    "section": "\n3 열 함수",
    "text": "3 열 함수\n\n3.1 select() 함수\n열(변수)의 일부를 선택한다. 열의 길이가 준다.\n\n# year, country, gdpPercap 변수만 선택\ngapminder |&gt; \n  select(year, country, gdpPercap)\n\n# A tibble: 1,704 × 3\n    year country     gdpPercap\n   &lt;int&gt; &lt;fct&gt;           &lt;dbl&gt;\n 1  1952 Afghanistan      779.\n 2  1957 Afghanistan      821.\n 3  1962 Afghanistan      853.\n 4  1967 Afghanistan      836.\n 5  1972 Afghanistan      740.\n 6  1977 Afghanistan      786.\n 7  1982 Afghanistan      978.\n 8  1987 Afghanistan      852.\n 9  1992 Afghanistan      649.\n10  1997 Afghanistan      635.\n# ℹ 1,694 more rows\n\n\n열(변수)의 일부를 선택하지 않는다. 역시 열의 길이가 준다. 실질적으로 위와 동일하다.\n\n# lifeExp, continent, pop을 제외한 변수들만 선택\ngapminder |&gt; \n  select(-c(lifeExp, continent, pop))\n\n# A tibble: 1,704 × 3\n   country      year gdpPercap\n   &lt;fct&gt;       &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan  1952      779.\n 2 Afghanistan  1957      821.\n 3 Afghanistan  1962      853.\n 4 Afghanistan  1967      836.\n 5 Afghanistan  1972      740.\n 6 Afghanistan  1977      786.\n 7 Afghanistan  1982      978.\n 8 Afghanistan  1987      852.\n 9 Afghanistan  1992      649.\n10 Afghanistan  1997      635.\n# ℹ 1,694 more rows\n\n\nstarts_with(), ends_with(), contains()와 같은 도우미 함수를 잘 활용하면 효율적으로 필요한 변수만을 선정할 수 있다.\n\n# 이름이 \"c\"로 시작하는 변수들만 선택\ngapminder |&gt; \n  select(starts_with(\"c\"))\n\n# A tibble: 1,704 × 2\n   country     continent\n   &lt;fct&gt;       &lt;fct&gt;    \n 1 Afghanistan Asia     \n 2 Afghanistan Asia     \n 3 Afghanistan Asia     \n 4 Afghanistan Asia     \n 5 Afghanistan Asia     \n 6 Afghanistan Asia     \n 7 Afghanistan Asia     \n 8 Afghanistan Asia     \n 9 Afghanistan Asia     \n10 Afghanistan Asia     \n# ℹ 1,694 more rows\n\n\n\n3.2 mutate() 함수\n기존의 열(변수)에 기반하여 새로운 변수를 생성한다. 열의 길이가 는다.\n\n# 새롭게 정의한 gdp_billion 변수 추가\ngapminder |&gt; \n  mutate(\n    gdp_billion = gdpPercap * pop / 10^9\n  )\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap gdp_billion\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.        6.57\n 2 Afghanistan Asia       1957    30.3  9240934      821.        7.59\n 3 Afghanistan Asia       1962    32.0 10267083      853.        8.76\n 4 Afghanistan Asia       1967    34.0 11537966      836.        9.65\n 5 Afghanistan Asia       1972    36.1 13079460      740.        9.68\n 6 Afghanistan Asia       1977    38.4 14880372      786.       11.7 \n 7 Afghanistan Asia       1982    39.9 12881816      978.       12.6 \n 8 Afghanistan Asia       1987    40.8 13867957      852.       11.8 \n 9 Afghanistan Asia       1992    41.7 16317921      649.       10.6 \n10 Afghanistan Asia       1997    41.8 22227415      635.       14.1 \n# ℹ 1,694 more rows\n\n\n여러개의 변수를 동시에 생성할 수 있다. row_number() 도우미 함수는 값에 순위를 부여하는 것이고, .keep = \"used\"는 결과에 변수 생성에 동원된 변수만을 포함시키게 해 준다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; # year이 2007인 행만 선택 \n  mutate(\n    gdpPercap_rank = row_number(gdpPercap), # gdpPercap에 순위 부여\n    lifeExp_highlow = lifeExp &gt; 30, # lifeExp가 30을 넘으면 TRUE, 아니면 FALSE\n    .keep = \"used\" # 새로운 변수 생성에 사용한 변수들만 표시\n  )\n\n# A tibble: 142 × 4\n   lifeExp gdpPercap gdpPercap_rank lifeExp_highlow\n     &lt;dbl&gt;     &lt;dbl&gt;          &lt;int&gt; &lt;lgl&gt;          \n 1    43.8      975.             19 TRUE           \n 2    76.4     5937.             70 TRUE           \n 3    72.3     6223.             72 TRUE           \n 4    42.7     4797.             64 TRUE           \n 5    75.3    12779.            101 TRUE           \n 6    81.2    34435.            130 TRUE           \n 7    79.8    36126.            132 TRUE           \n 8    75.6    29796.            122 TRUE           \n 9    64.1     1391.             30 TRUE           \n10    79.4    33693.            128 TRUE           \n# ℹ 132 more rows\n\n\n\n3.3 rename() 함수\n변수의 이름을 바꾼다. 열의 길이에는 변화가 없다.\n\n# 변수의 이름 변경\ngapminder |&gt; \n  rename(\n    gdp_percap = gdpPercap,\n    left_exp = lifeExp\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year left_exp      pop gdp_percap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;      &lt;dbl&gt;\n 1 Afghanistan Asia       1952     28.8  8425333       779.\n 2 Afghanistan Asia       1957     30.3  9240934       821.\n 3 Afghanistan Asia       1962     32.0 10267083       853.\n 4 Afghanistan Asia       1967     34.0 11537966       836.\n 5 Afghanistan Asia       1972     36.1 13079460       740.\n 6 Afghanistan Asia       1977     38.4 14880372       786.\n 7 Afghanistan Asia       1982     39.9 12881816       978.\n 8 Afghanistan Asia       1987     40.8 13867957       852.\n 9 Afghanistan Asia       1992     41.7 16317921       649.\n10 Afghanistan Asia       1997     41.8 22227415       635.\n# ℹ 1,694 more rows\n\n\n패밀리 함수인 rename_with()를 이용하면 다른 것도 가능하다.\n\n# \"l\"로 시작하는 변수를 전부 소문자로 변경\ngapminder |&gt; \n  rename_with(\n    tolower, starts_with(\"l\")\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeexp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n3.4 relocate() 함수\n변수의 위치를 바꾼다. 열의 길이에는 변화가 없다.\n\n# year 변수의 위치를 continent 앞으로 이동\ngapminder |&gt; \n  relocate(year, continent)\n\n# A tibble: 1,704 × 6\n    year continent country     lifeExp      pop gdpPercap\n   &lt;int&gt; &lt;fct&gt;     &lt;fct&gt;         &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1  1952 Asia      Afghanistan    28.8  8425333      779.\n 2  1957 Asia      Afghanistan    30.3  9240934      821.\n 3  1962 Asia      Afghanistan    32.0 10267083      853.\n 4  1967 Asia      Afghanistan    34.0 11537966      836.\n 5  1972 Asia      Afghanistan    36.1 13079460      740.\n 6  1977 Asia      Afghanistan    38.4 14880372      786.\n 7  1982 Asia      Afghanistan    39.9 12881816      978.\n 8  1987 Asia      Afghanistan    40.8 13867957      852.\n 9  1992 Asia      Afghanistan    41.7 16317921      649.\n10  1997 Asia      Afghanistan    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n.before나 .after 아규먼트를 사용하여 해당 변수를 어떤 변수의 앞이나 뒤로 보낼 수 있다.\n\n# pop 변수의 위치를 lifeExp 앞으로 이동\ngapminder |&gt; \n  relocate(pop, .before = lifeExp )\n\n# A tibble: 1,704 × 6\n   country     continent  year      pop lifeExp gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;    &lt;int&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952  8425333    28.8      779.\n 2 Afghanistan Asia       1957  9240934    30.3      821.\n 3 Afghanistan Asia       1962 10267083    32.0      853.\n 4 Afghanistan Asia       1967 11537966    34.0      836.\n 5 Afghanistan Asia       1972 13079460    36.1      740.\n 6 Afghanistan Asia       1977 14880372    38.4      786.\n 7 Afghanistan Asia       1982 12881816    39.9      978.\n 8 Afghanistan Asia       1987 13867957    40.8      852.\n 9 Afghanistan Asia       1992 16317921    41.7      649.\n10 Afghanistan Asia       1997 22227415    41.8      635.\n# ℹ 1,694 more rows",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_04.html#그룹-함수",
    "href": "lab_04.html#그룹-함수",
    "title": "Lab04: 데이터 변형하기",
    "section": "\n4 그룹 함수",
    "text": "4 그룹 함수\n\n4.1 group_by() 함수\n특정 범주 열(변수)에 의거해 행을 분할한다. 행의 길이는 변하지 않는다.\n하나의 범주 변수에 의거해 그룹화한다. 산출물을 보면 year에 의거해 행이 12개의 그룹으로 나누어졌음이 나타나 있다(두 번째 줄: Group: year [12]).\n\n# year을 기준으로 그룹화\ngapminder |&gt; \n  group_by(year)\n\n# A tibble: 1,704 × 6\n# Groups:   year [12]\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n두 개 이상의 범주 변수에 의거해 그룹화할 수도 있다.\n\n# year, continent를 기준으로 그룹화\ngapminder |&gt; \n  group_by(year, continent)\n\n# A tibble: 1,704 × 6\n# Groups:   year, continent [60]\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n4.2 summarize() 함수\n주어진 열(변수)에 대한 통계 요약값을 계산하고 그것으로 이루어진 새로운 데이터 프레임을 생성한다. 엄밀히 말해 기존 열(변수)을 변형한다기 보다는 기존 데이터 프레임으로부터 새로운 데이터 프레임을 생성한다고 볼 수 있다. summarize() 함수는 대부분의 경우 group_by() 함수와 함께 사용된다. 다음의 둘을 비교해 보라.\n\n# 2007년 전체의 gdpPercap의 평균 계산\ngapminder |&gt; \n  filter(year == 2007) |&gt; # year이 2007인 행만 선택\n  summarize(mean_gdpPercap = mean(gdpPercap)) # gdpPercap의 평균값 계산\n\n# A tibble: 1 × 1\n  mean_gdpPercap\n           &lt;dbl&gt;\n1         11680.\n\n\n\n# 2007년 대륙별 gdpPercap의 평균 계산\ngapminder |&gt; \n  filter(year == 2007) |&gt; # year이 2007인 행만 선택\n  group_by(continent) |&gt;  # continent를 기준으로 그룹화\n  summarize(mean_gdpPercap = mean(gdpPercap)) # gdpPercap의 평균값 계산\n\n# A tibble: 5 × 2\n  continent mean_gdpPercap\n  &lt;fct&gt;              &lt;dbl&gt;\n1 Africa             3089.\n2 Americas          11003.\n3 Asia              12473.\n4 Europe            25054.\n5 Oceania           29810.\n\n\n좀 더 복잡한 확장이 가능하다. 마지막의 n()은 자동으로 생성되는 그룹별 빈도값이다.\n\n# continent, year별로 다양한 통계값 산출\ngapminder |&gt; \n    group_by(continent, year) |&gt; # continent, year을 기준으로 그룹화\n    summarize(\n      mean_gdpPercap = mean(gdpPercap), # gdpPercap의 평균값 계산\n      sd_gdpPercap = sd(gdpPercap), # gdpPercap의 표준편차 계산\n      mean_pop = mean(pop), # pop의 평균값 계산\n      sd_pop = sd(pop), # pop의 표준편차 계산\n      n = n() # 그룹에 포함된 행의 개수\n      )\n\n# A tibble: 60 × 7\n# Groups:   continent [5]\n   continent  year mean_gdpPercap sd_gdpPercap  mean_pop    sd_pop     n\n   &lt;fct&gt;     &lt;int&gt;          &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;\n 1 Africa     1952          1253.         983.  4570010.  6317450.    52\n 2 Africa     1957          1385.        1135.  5093033.  7076042.    52\n 3 Africa     1962          1598.        1462.  5702247.  7957545.    52\n 4 Africa     1967          2050.        2848.  6447875.  8985505.    52\n 5 Africa     1972          2340.        3287.  7305376. 10130833.    52\n 6 Africa     1977          2586.        4142.  8328097. 11585184.    52\n 7 Africa     1982          2482.        3243.  9602857. 13456243.    52\n 8 Africa     1987          2283.        2567. 11054502. 15277484.    52\n 9 Africa     1992          2282.        2644. 12674645. 17562719.    52\n10 Africa     1997          2379.        2821. 14304480. 19873013.    52\n# ℹ 50 more rows\n\n\ngroup_by()와 arrange()를 결합하는 경우, .by_group = TRUE를 하면 그룹별로 행을 배열할 수 있다.\n\n# year, continent 그룹별로 gdpPercap 내림차순 정렬\ngapminder |&gt; \n  group_by(year, continent) |&gt; # year, continent를 기준으로 그룹화\n  arrange(desc(gdpPercap), .by_group = TRUE) # 그룹별로 gdpPercap 내림차순 정렬\n\n# A tibble: 1,704 × 6\n# Groups:   year, continent [60]\n   country      continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 South Africa Africa     1952    45.0 14264935     4725.\n 2 Gabon        Africa     1952    37.0   420702     4293.\n 3 Angola       Africa     1952    30.0  4232095     3521.\n 4 Reunion      Africa     1952    52.7   257700     2719.\n 5 Djibouti     Africa     1952    34.8    63149     2670.\n 6 Algeria      Africa     1952    43.1  9279525     2449.\n 7 Namibia      Africa     1952    41.7   485831     2424.\n 8 Libya        Africa     1952    42.7  1019729     2388.\n 9 Congo, Rep.  Africa     1952    42.1   854885     2126.\n10 Mauritius    Africa     1952    51.0   516556     1968.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\n힌트.by_group = TRUE를 사용하지 않은 경우\n\n\n\n\n\n.by_group = TRUE를 붙이지 않으면 그냥 arrange()를 사용한 것과 같은 결과가 나온다.\n\n# .by_group = TRUE를 사용하지 않은 경우\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  arrange(desc(gdpPercap))\n\n# A tibble: 1,704 × 6\n# Groups:   year, continent [60]\n   country   continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Kuwait    Asia       1957    58.0  212846   113523.\n 2 Kuwait    Asia       1972    67.7  841934   109348.\n 3 Kuwait    Asia       1952    55.6  160000   108382.\n 4 Kuwait    Asia       1962    60.5  358266    95458.\n 5 Kuwait    Asia       1967    64.6  575003    80895.\n 6 Kuwait    Asia       1977    69.3 1140357    59265.\n 7 Norway    Europe     2007    80.2 4627926    49357.\n 8 Kuwait    Asia       2007    77.6 2505559    47307.\n 9 Singapore Asia       2007    80.0 4553009    47143.\n10 Norway    Europe     2002    79.0 4535591    44684.\n# ℹ 1,694 more rows\n\n\n\ngapminder |&gt; \n  arrange(desc(gdpPercap))\n\n# A tibble: 1,704 × 6\n   country   continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Kuwait    Asia       1957    58.0  212846   113523.\n 2 Kuwait    Asia       1972    67.7  841934   109348.\n 3 Kuwait    Asia       1952    55.6  160000   108382.\n 4 Kuwait    Asia       1962    60.5  358266    95458.\n 5 Kuwait    Asia       1967    64.6  575003    80895.\n 6 Kuwait    Asia       1977    69.3 1140357    59265.\n 7 Norway    Europe     2007    80.2 4627926    49357.\n 8 Kuwait    Asia       2007    77.6 2505559    47307.\n 9 Singapore Asia       2007    80.0 4553009    47143.\n10 Norway    Europe     2002    79.0 4535591    44684.\n# ℹ 1,694 more rows\n\n\n\n\n\n아래는 연도별/대륙별로 일인당 GDP가 가장 높은 국가를 추출한 것이다. 코드를 생각해 보라. Code를 누르면 답을 확인할 수 있다.\n\n\nOutput\nCode\n\n\n\n\n\n# A tibble: 60 × 6\n# Groups:   year, continent [60]\n   country       continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 South Africa  Africa     1952    45.0  14264935     4725.\n 2 United States Americas   1952    68.4 157553000    13990.\n 3 Kuwait        Asia       1952    55.6    160000   108382.\n 4 Switzerland   Europe     1952    69.6   4815000    14734.\n 5 New Zealand   Oceania    1952    69.4   1994794    10557.\n 6 South Africa  Africa     1957    48.0  16151549     5487.\n 7 United States Americas   1957    69.5 171984000    14847.\n 8 Kuwait        Asia       1957    58.0    212846   113523.\n 9 Switzerland   Europe     1957    70.6   5126000    17909.\n10 New Zealand   Oceania    1957    70.3   2229407    12247.\n# ℹ 50 more rows\n\n\n\n\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  slice_max(gdpPercap)\n\n\n\n\ngroup_by() 함수가 한 번 적용되면, 그 뒤의 모든 오퍼레이션에 그룹 분할이 적용되기 때문에 예기치 못한 일이 발생할 수 있다. 이것을 회피하기 위해 두 가지 옵션이 있다. 첫번째 방법은 마지막에 upgroup() 함수를 첨가하는 것이다.\n\n# 그룹화를 해제하고 year, continent별로 gdpPercap이 가장 높은 국가 선택\ngapminder |&gt; \n  group_by(year, continent) |&gt; # year, continent를 기준으로 그룹화\n  slice_max(gdpPercap) |&gt; # 그룹에서 gdpPercap이 가장 높은 행 선택\n  ungroup() # 그룹화 해제\n\n# A tibble: 60 × 6\n   country       continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 South Africa  Africa     1952    45.0  14264935     4725.\n 2 United States Americas   1952    68.4 157553000    13990.\n 3 Kuwait        Asia       1952    55.6    160000   108382.\n 4 Switzerland   Europe     1952    69.6   4815000    14734.\n 5 New Zealand   Oceania    1952    69.4   1994794    10557.\n 6 South Africa  Africa     1957    48.0  16151549     5487.\n 7 United States Americas   1957    69.5 171984000    14847.\n 8 Kuwait        Asia       1957    58.0    212846   113523.\n 9 Switzerland   Europe     1957    70.6   5126000    17909.\n10 New Zealand   Oceania    1957    70.3   2229407    12247.\n# ℹ 50 more rows\n\n\n두 번째 방법은 group_by() 함수 대신 by 아규먼트를 사용하는 것이다. 결과가 달라보이겠지만 정렬의 차이일 뿐 동일하다.\n\n# year, continent 기준으로 gdpPercap이 가장 높은 행 선택\ngapminder |&gt; \n  slice_max(gdpPercap, by = c(year, continent)) \n\n# A tibble: 60 × 6\n   country      continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Kuwait       Asia       1952    55.6   160000   108382.\n 2 Kuwait       Asia       1957    58.0   212846   113523.\n 3 Kuwait       Asia       1962    60.5   358266    95458.\n 4 Kuwait       Asia       1967    64.6   575003    80895.\n 5 Kuwait       Asia       1972    67.7   841934   109348.\n 6 Kuwait       Asia       1977    69.3  1140357    59265.\n 7 Saudi Arabia Asia       1982    63.0 11254672    33693.\n 8 Kuwait       Asia       1987    74.2  1891487    28118.\n 9 Kuwait       Asia       1992    75.2  1418095    34933.\n10 Kuwait       Asia       1997    76.2  1765345    40301.\n# ℹ 50 more rows\n\n\n\n4.3 count() 함수\n특정 범주 열(변수)에 의거한 빈도를 빠르게 계산해 준다.\n\n# year, continent별 행 개수 계산\ngapminder |&gt; \n  count(year, continent)\n\n# A tibble: 60 × 3\n    year continent     n\n   &lt;int&gt; &lt;fct&gt;     &lt;int&gt;\n 1  1952 Africa       52\n 2  1952 Americas     25\n 3  1952 Asia         33\n 4  1952 Europe       30\n 5  1952 Oceania       2\n 6  1957 Africa       52\n 7  1957 Americas     25\n 8  1957 Asia         33\n 9  1957 Europe       30\n10  1957 Oceania       2\n# ℹ 50 more rows\n\n\nwt 아규먼트를 사용하면 빈도가 아니라 범주별 특정 변수의 합산값을 구할 수 있다.\n\n# year, continent별 pop의 합산값 계산\ngapminder |&gt; \n  count(year, continent, wt = pop)\n\n# A tibble: 60 × 3\n    year continent          n\n   &lt;int&gt; &lt;fct&gt;          &lt;dbl&gt;\n 1  1952 Africa     237640501\n 2  1952 Americas   345152446\n 3  1952 Asia      1395357351\n 4  1952 Europe     418120846\n 5  1952 Oceania     10686006\n 6  1957 Africa     264837738\n 7  1957 Americas   386953916\n 8  1957 Asia      1562780599\n 9  1957 Europe     437890351\n10  1957 Oceania     11941976\n# ℹ 50 more rows\n\n\n위의 두 개를 한 번에 실행할 수 있다.\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; # year, continent를 기준으로 그룹화\n  summarize(\n    n = n(), # 그룹별 행 개수 계산\n    sum_pop = sum(pop) # 그룹별 pop의 합산값 계산\n  )\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent     n    sum_pop\n   &lt;int&gt; &lt;fct&gt;     &lt;int&gt;      &lt;dbl&gt;\n 1  1952 Africa       52  237640501\n 2  1952 Americas     25  345152446\n 3  1952 Asia         33 1395357351\n 4  1952 Europe       30  418120846\n 5  1952 Oceania       2   10686006\n 6  1957 Africa       52  264837738\n 7  1957 Americas     25  386953916\n 8  1957 Asia         33 1562780599\n 9  1957 Europe       30  437890351\n10  1957 Oceania       2   11941976\n# ℹ 50 more rows\n\n\n\n4.4 across() 함수\n다수의 열(변수)에 동일한 함수를 적용할 수 있다.\n\n# lifeExp와 gdpPercap을 반올림\ngapminder |&gt; \n  mutate(\n    across(c(lifeExp, gdpPercap), round)\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952      29  8425333       779\n 2 Afghanistan Asia       1957      30  9240934       821\n 3 Afghanistan Asia       1962      32 10267083       853\n 4 Afghanistan Asia       1967      34 11537966       836\n 5 Afghanistan Asia       1972      36 13079460       740\n 6 Afghanistan Asia       1977      38 14880372       786\n 7 Afghanistan Asia       1982      40 12881816       978\n 8 Afghanistan Asia       1987      41 13867957       852\n 9 Afghanistan Asia       1992      42 16317921       649\n10 Afghanistan Asia       1997      42 22227415       635\n# ℹ 1,694 more rows\n\n\n이것은 다음과 동일하다.\n\ngapminder |&gt; \n  mutate(\n    lifeExp = round(lifeExp), # lifeExp를 반올림한 새로운 변수 생성\n    gdpPercap = round(gdpPercap) # gdpPercap을 반올림한 새로운 변수 생성\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952      29  8425333       779\n 2 Afghanistan Asia       1957      30  9240934       821\n 3 Afghanistan Asia       1962      32 10267083       853\n 4 Afghanistan Asia       1967      34 11537966       836\n 5 Afghanistan Asia       1972      36 13079460       740\n 6 Afghanistan Asia       1977      38 14880372       786\n 7 Afghanistan Asia       1982      40 12881816       978\n 8 Afghanistan Asia       1987      41 13867957       852\n 9 Afghanistan Asia       1992      42 16317921       649\n10 Afghanistan Asia       1997      42 22227415       635\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\n힌트\n\n\n\n새롭게 생성한 변수가 기존 변수와 이름이 같은 경우 기존 변수를 대체한다.\n\n\nsummarize() 함수와 결합하여 선택된 변수에 특정 함수를 적용하고 그 결과의 이름을 변수명과 함수명을 사용하여 부여할 수 있다.\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; # year, continent를 기준으로 그룹화\n  summarize(across(c(lifeExp, gdpPercap), mean, # lifeExp와 gdpPercap의 평균값 계산\n                   .names = \"mean_{.col}\")) # 새롭게 생성된 변수의 이름을 \"mean_기존 이름\"으로 설정\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent mean_lifeExp mean_gdpPercap\n   &lt;int&gt; &lt;fct&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n 1  1952 Africa            39.1          1253.\n 2  1952 Americas          53.3          4079.\n 3  1952 Asia              46.3          5195.\n 4  1952 Europe            64.4          5661.\n 5  1952 Oceania           69.3         10298.\n 6  1957 Africa            41.3          1385.\n 7  1957 Americas          56.0          4616.\n 8  1957 Asia              49.3          5788.\n 9  1957 Europe            66.7          6963.\n10  1957 Oceania           70.3         11599.\n# ℹ 50 more rows\n\n\n\n4.5 c_across() 함수\ngroup_by() 함수와 across() 함수가 결합하는 것과 정반대로, rowwise() 함수와 c_across() 함수를 결합하며, 행별 통계값을 산출할 수 있다. 물론 여기서 sd 값은 아무런 의미가 없다.\n\ngapminder |&gt; \n  rowwise() |&gt; # 행별로 그룹화\n  mutate(\n    sd = sd(c_across(where(is.numeric))) # 각 행에서 숫자인 값들의 표준편차 계산\n  )\n\n# A tibble: 1,704 × 7\n# Rowwise: \n   country     continent  year lifeExp      pop gdpPercap        sd\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  4212207.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  4619999.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  5133067.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  5768510.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  6539272.\n 6 Afghanistan Asia       1977    38.4 14880372      786.  7439719.\n 7 Afghanistan Asia       1982    39.9 12881816      978.  6440408.\n 8 Afghanistan Asia       1987    40.8 13867957      852.  6933499.\n 9 Afghanistan Asia       1992    41.7 16317921      649.  8158513.\n10 Afghanistan Asia       1997    41.8 22227415      635. 11113262.\n# ℹ 1,694 more rows",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab04: 데이터 변형하기"
    ]
  },
  {
    "objectID": "lab_03.html",
    "href": "lab_03.html",
    "title": "Lab03: 데이터 불러오기와 정리하기",
    "section": "",
    "text": "티블(tibble)에 대해 이해할 수 있다.\n다양한 형식의 데이터를 원하는 형태로 불러올 수 있다. (데이터 불러오기)\n데이터를 늘이고, 넓히고, 서로 결합할 수 있다. (데이터 정리하기)",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab03: 데이터 불러오기와 정리하기"
    ]
  },
  {
    "objectID": "lab_03.html#실습의-목표",
    "href": "lab_03.html#실습의-목표",
    "title": "Lab03: 데이터 불러오기와 정리하기",
    "section": "",
    "text": "티블(tibble)에 대해 이해할 수 있다.\n다양한 형식의 데이터를 원하는 형태로 불러올 수 있다. (데이터 불러오기)\n데이터를 늘이고, 넓히고, 서로 결합할 수 있다. (데이터 정리하기)",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab03: 데이터 불러오기와 정리하기"
    ]
  },
  {
    "objectID": "lab_03.html#티블tibble",
    "href": "lab_03.html#티블tibble",
    "title": "Lab03: 데이터 불러오기와 정리하기",
    "section": "\n1 티블(tibble)",
    "text": "1 티블(tibble)\n실습을 시작하기에 앞서 tidyverse 패키지를 불러오자. 설치는 이미 지난 시간에 했기 때문에 오늘은 library()함수를 통해 패키지를 불러오기만 하면 된다.\n\nlibrary(tidyverse)\n\n\n\n\n\n\n\n중요\n\n\n\n왼쪽 위 Editor 창에서 코드를 실행하기 위해서는 그냥 enter가 아니라 ctrl+enter(Mac은 cmd+enter)를 눌러야 한다.\n\n\n\n1.1 티블 생성하기\n\n1.1.1 기존 데이터를 티블 포맷으로 변환하기\nBase R에 포함되어 있는 iris라는 데이터 프레임을 사용한다. 우선 지난 시간에 배운 파이프 연산자(pipe operator)를 가지고 iris 데이터를 살펴보자.\n\niris |&gt; \n  glimpse()  \n\nRows: 150\nColumns: 5\n$ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n\n\nclass() 함수를 통해 iris 데이터의 형식이 data.frame인 것을 확인할 수 있다.\n\nclass(iris)\n\n[1] \"data.frame\"\n\n\nas_tibble() 함수를 이용하여 tibble 객체로 전환한다. 그러면 data.frame 객체가 tibble 객체로 전환된 것을 알 수 있다.\n\niris_tbl &lt;- iris |&gt; \n  as_tibble() \nclass(iris_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n1.1.2 티블 객체를 직접 생성하기\ntibble 객체를 직접 생성하는 방식은 두 가지로 나뉜다.\n\n열-단위 방식(보다 일반적): 우선 열-벡터를 만들고 그것을 결합해 최종적인 tibble 객체를 만든다. tibble() 함수를 이용한다.\n\n\n# 열-벡터를 만들고 이들을 결합하여 최종적인 tibble 객체 생성\ntibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n\n# A tibble: 3 × 3\n      x y         z\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 h      0.08\n2     2 m      0.83\n3     5 g      0.6 \n\n\n\n# 수식 등을 활용해서도 tibble 객체를 생성할 수 있다.\ntibble(\n  x = 1:5, \n  y = 1, \n  z = x ^ 2 + y\n)\n\n# A tibble: 5 × 3\n      x     y     z\n  &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1     1     2\n2     2     1     5\n3     3     1    10\n4     4     1    17\n5     5     1    26\n\n\n\n행-단위 방식: 우선 행-벡터를 만들고 그것을 결합해 최종적인 tibble 객체를 만든다. tribble() 함수를 이용한다. tribble은 전치티블(transposed tibble)의 약자이다.\n\n\n# 행-벡터를 만들고 이들을 결합하여 최종적인 tibble 객체 생성\ntribble(\n  ~x, ~y, ~z,\n  1, \"h\", 0.08,\n  2, \"m\", 0.83,\n  5, \"g\", 0.60\n)\n\n# A tibble: 3 × 3\n      x y         z\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 h      0.08\n2     2 m      0.83\n3     5 g      0.6",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab03: 데이터 불러오기와 정리하기"
    ]
  },
  {
    "objectID": "lab_03.html#데이터-불러오기",
    "href": "lab_03.html#데이터-불러오기",
    "title": "Lab03: 데이터 불러오기와 정리하기",
    "section": "\n2 데이터 불러오기",
    "text": "2 데이터 불러오기\n\n2.1 readr 패키지\n\n2.1.1 파일 형식\nreadr 패키지는 다양한 함수를 이용해 다양한 형식의 데이터를 불러올 수 있게 도와준다.\n\nread_csv(): 콤마분리(comma-separated values, CSV) 형식의 파일\nread_csv2(): 세미콜론분리(semicolon-separated) 형식의 파일\nread_tsv(): 탭구분(tab-delimited) 형식의 파일\nread_delim(): 여타의 구분 형식의 파일\nread_fwf(): 고정폭(fixed-width) 형식의 파일\nread_table(): 공백구분 형식의 파일\nread_log(): 아파치 형식(Apache-style)의 로그 파일\n\n2.1.2 read_csv() 함수의 활용\n지난번 실습에서 사용한 데이터를 면밀히 살펴본다.\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\nstudents\n\n# A tibble: 6 × 5\n  `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n         &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n2            2 Barclay Lynn     French fries       Lunch only          5    \n3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n6            6 Güvenç Attila    Ice cream          Lunch only          6    \n\n\n다음의 몇 가지 점이 불만족스럽다.\n\n변수명: 특히 Student ID와 Full Name 변수명은 규칙에 어긋난다. 변수명 속에 공란이 있으면 좋지 않다. 이런 이름을 비구문명(non-syntactic name)이라고 하고, ``로 둘러싸여 표시된다. 나중에 다른 분석을 할 때 문제를 일으킬 수 있기 때문에 바꿔주는 것이 좋다.\n변수 형식: mealPlan은 문자형(chr)이 아니라 팩트형(fct)이, AGE는 문자형(chr)이 아니라 수치형(dbl)이 적절하다.\n결측치(NA): favourite.food의 ’N/A’는 형식에 맞지 않아 결측치가 아니라 문자로 취급된다. 따라서 ’N/A’가 결측치임을 알려주어야 한다.\n\n\nstudents &lt;- read_csv(\n  \"https://pos.it/r4ds-students-csv\", \n  skip = 1, # 첫 행을 건너뛰기\n  col_names = c(\"student_id\", \"full_name\", \"favorite_food\", \"meal_plan\", \"age\"), # 새로운 변수명 지정\n  col_types = cols( \n    meal_plan = col_factor(),\n    age = col_number()), # 변수별 타입 지정\n  na = \"N/A\" # 문자 \"N/A\"를 결측치 NA로 수정\n  )\nstudents\n\n# A tibble: 6 × 5\n  student_id full_name        favorite_food      meal_plan             age\n       &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n2          2 Barclay Lynn     French fries       Lunch only              5\n3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n4          4 Leon Rossini     Anchovies          Lunch only             NA\n5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch    NA\n6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n\n\n2.2 엑셀 파일\n\n2.2.1 readxl 패키지\n가장 널리 사용되는 스프레드시트(spreadsheet) 형식인 엑셀 파일을 불러들이기 위해서는 readxl이라는 패키지가 필요하다. tidyverse의 핵심 패키지는 아니지만 일종의 친척 패키지라 할 수는 있다. tidyverse에 포함되어 있지 않기 때문에 따로 인스톨하고 library() 함수를 통해 불러와야 한다.\n\nlibrary(readxl)\n\n가장 널리 사용되는 명령어는 다음의 세 가지이다.\n\nread_xls(): xls 포맷의 엑셀 파일 불러오기\nread_xlsx(): xlsx 포맷의 엑셀 파일 불러오기\nread_excel(): xls, xlsx 포맷의 엑셀 파일 불러오기\n\n2.2.2 read_excel() 함수의 활용\nWorld Population Prospects 2022 데이터를 직접 다운받아 실습을 진행하고자 한다. 이 데이터셋은 매우 중요하다. 다음의 절차에 따라 해당 엑셀 파일을 다운로드한다.\n\nWPP 웹사이트(https://population.un.org/wpp/)에 접속한다.\nDownload Data Files를 클릭한다.\n\n\n\n다음의 파일을 클릭한다: Compact (most used: estimates and medium projections) (XLSX, 24.07 MB)\n\n\n\n엑셀 파일(WPP2022_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT_REV1)을 다운로드하여 자신의 프로젝트 폴더에 저장한다. 프로젝트 폴더에 저장하지 않으면 따로 경로를 설정해주어야 한다.\n\nR 바깥에서 다운로드한 파일을 열어 어떠한 정보가 어떠한 방식으로 수록되어 있는지 살펴본다. 데이터 불러오기를 위해 다음의 네 가지 사항에 유의해야 함을 이해한다.\n\n16번 행까지는 불필요한 영역이다.\n17번 행을 변수명으로 사용할 경우 많은 문제점이 발생한다.\n결측치는 공란이거나 ‘…’ 기호로 표시되어 있다.\n첫 번째 워킹시트(Estimates)에는 1950~2021의 데이터가, 두 번째 워킹시트(Medium variant)에는 2022~2100년의 데이터가 수록되어 있다. 나중에 결합해야한다.\n\n우선 엑셀 파일을 그대로 불러와 본다.\n\nread_excel(\n  \"WPP2022_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT_REV1.xlsx\", \n  sheet = \"Estimates\" \n  )\n\n# A tibble: 20,608 × 65\n   ...1  ...2  ...3  ...4  `United Nations`  ...6  ...7  ...8  ...9  ...10 ...11\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;             &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  Population Divis… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 2 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  Department of Ec… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 3 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;              &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 4 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  World Population… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 5 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  File GEN/01/REV1… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 6 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  Estimates, 1950 … &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 7 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  POP/DB/WPP/Rev.2… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 8 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  © July 2022 by U… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 9 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  Suggested citati… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n10 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;              &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n# ℹ 20,598 more rows\n# ℹ 54 more variables: ...12 &lt;chr&gt;, ...13 &lt;chr&gt;, ...14 &lt;chr&gt;, ...15 &lt;chr&gt;,\n#   ...16 &lt;chr&gt;, ...17 &lt;chr&gt;, ...18 &lt;chr&gt;, ...19 &lt;chr&gt;, ...20 &lt;chr&gt;,\n#   ...21 &lt;chr&gt;, ...22 &lt;chr&gt;, ...23 &lt;chr&gt;, ...24 &lt;chr&gt;, ...25 &lt;chr&gt;,\n#   ...26 &lt;chr&gt;, ...27 &lt;chr&gt;, ...28 &lt;chr&gt;, ...29 &lt;chr&gt;, ...30 &lt;chr&gt;,\n#   ...31 &lt;chr&gt;, ...32 &lt;chr&gt;, ...33 &lt;chr&gt;, ...34 &lt;chr&gt;, ...35 &lt;chr&gt;,\n#   ...36 &lt;chr&gt;, ...37 &lt;chr&gt;, ...38 &lt;chr&gt;, ...39 &lt;chr&gt;, ...40 &lt;chr&gt;, …\n\n\n끔찍할 것이다. 아래의 과정을 거쳐 사용할 수 있는 데이터로 바꾸어 불러온다.\n우선 새로운 변수명들을 하나의 벡터로 만든다.\n\n# 새롭게 사용될 변수명 지정\nnew_names &lt;- c(\"index\", \"variant\", \"region_name\", \"notes\", \"location_code\", \n                \"ISO3\", \"ISO2\", \"SDMX\", \"type\", \"parent_code\", \"year\", \"pop_jan_total\", \n                \"pop_jul_total\", \"pop_jul_male\", \"pop_jul_female\", \"pop_den\", \"sex_ratio\", \n                \"median_age\", \"natural_change\", \"RNC\", \"pop_change\", \"PGR\", \n                \"dubling_time\", \"births\", \"births_by_f1519\", \"CBR\", \"TFR\", \"NRR\", \n                \"mean_age_childbearing\", \"sex_ratio_birth\", \"deaths_total\", \n                \"deaths_male\", \"deaths_female\", \"CDR\", \"life_exp_total\", \n                \"life_exp_male\", \"life_exp_female\", \"life_exp_15_total\", \n                \"life_exp_15_male\", \"life_exp_15_female\", \"life_exp_65_total\", \n                \"life_exp_65_male\", \"life_exp_65_female\", \"life_exp_80_total\", \n                \"life_exp_80_male\", \"life_exp_80_female\", \"infant_deaths\", \n                \"IMR\", \"live_births\", \"under_five_deaths\", \"mort_under_five\", \n                \"mort_bf_40_total\", \"mort_bf_40_male\", \"mort_bf_40_female\", \"mort_bf_60_total\", \n                \"mort_bf_60_male\", \"mort_bf_60_female\", \"mort_bt_1550_total\", \n                \"mort_bt_1550_male\", \"mort_bt_1550_female\", \"mort_bt_1560_total\", \n                \"mort_bt_1560_male\", \"mort_bt_1560_female\", \"net_migrants\", \"NMR\")\n\n앞에서 했던 과정과 유사하게 필요한 내용들을 수정하여 엑셀 파일을 불러온다.\n\n# Estimates 시트 정리\nwpp_2022_estimates &lt;- read_excel(\n  \"WPP2022_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT_REV1.xlsx\",\n  sheet = \"Estimates\",\n  skip = 17, \n  col_names = new_names,\n  col_types = c(rep(\"guess\", 3), \"text\", \"guess\", rep(\"text\", 2), rep(\"guess\", 58)),\n  na = c(\"...\", \"\")\n  )\n\n# Medium variant 시트 정리\nwpp_2022_future &lt;- read_excel(\n  \"WPP2022_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT_REV1.xlsx\",\n  sheet = \"Medium variant\",\n  skip = 17, \n  col_names = new_names,\n  col_types = c(rep(\"guess\", 3), \"text\", \"guess\", rep(\"text\", 2), rep(\"guess\", 58)),\n  na = c(\"...\", \"\")\n)\n\n# 행 단위로 결합\nwpp_2022 &lt;- bind_rows(wpp_2022_estimates, wpp_2022_future)\n\n# 새 창에서 보기\nView(wpp_2022)\n\n\n\n\n\n\n\n힌트rep() 함수\n\n\n\n\n\nrep()함수는 Basic R 함수로 값들을 반복하는 데 사용된다.\n\n# 벡터 전체를 반복\nrep(c(\"A\", \"B\", \"C\"), 3)\n\n[1] \"A\" \"B\" \"C\" \"A\" \"B\" \"C\" \"A\" \"B\" \"C\"\n\nrep(c(\"A\", \"B\", \"C\"), times = 3)\n\n[1] \"A\" \"B\" \"C\" \"A\" \"B\" \"C\" \"A\" \"B\" \"C\"\n\n\n\n# 벡터의 각 요소들을 반복\nrep(c(\"A\", \"B\", \"C\"), each = 2)\n\n[1] \"A\" \"A\" \"B\" \"B\" \"C\" \"C\"\n\n\n\n# 벡터의 각 요소들을 반복하고 그 전체를 다시 반복\nrep(c(\"A\", \"B\", \"C\"), each = 2, times = 2)\n\n [1] \"A\" \"A\" \"B\" \"B\" \"C\" \"C\" \"A\" \"A\" \"B\" \"B\" \"C\" \"C\"\n\n\n\n\n\n해야 할 일이 한가지 더 남아있다. 많은 변수 중에 데이터 탐색이라는 측면에서 가장 중요한 것은 type 변수이다. 다음을 통해 distinct()함수를 통해 type 변수에 어떤 내용이 담겨 있는지 확인한다.\n\nwpp_2022 |&gt; \n  distinct(type) # type 변수에 어떤 값들이 들어가 있는지 확인\n\n# A tibble: 9 × 1\n  type             \n  &lt;chr&gt;            \n1 World            \n2 Label/Separator  \n3 SDG region       \n4 Development Group\n5 Special other    \n6 Income Group     \n7 Region           \n8 Subregion        \n9 Country/Area     \n\n\ndistinct() 함수의 결과를 통해 세계 전체(World), 국가군(SDG region, Region 등), 국가(Country/Area) 등으로 데이터를 활용할 수 있다는 것을 인지한다. 그런데, “Label/Separator”는 엑셀 내에서 분할선의 역할만 하는 것으로, 무의미한 값이다. 따라서 이를 제거한다.\n\nwpp_2022 &lt;- wpp_2022 |&gt; \n  filter(type != \"Label/Separator\") # type 변수의 값이 \"Label/Separator\"가 아닌 행만 추출\n\n나중에 사용하기 위해, writexl 패키지의 write_xlsx() 함수를 이용하여 엑셀 파일로 저장한다.\n\nlibrary(writexl)\nwrite_xlsx(wpp_2022, \"wpp_2022.xlsx\")\n\n그런데, 저장된 파일을 read_excel() 함수로 다시 불러 들이면 컬럼 형식에 대한 정보가 사라져 버리는 등의 에러가 발생한다. 이런 점 때문에 다음과 같은 대안이 존재한다. readr 패키지의 write_rds() 함수로 저장하고, 다시 read_rds() 함수로 불러들이면 정확히 동일한 것을 얻을 수 있다.\n\nwrite_rds(wpp_2022, \"wpp_2022.rds\")\nread_rds(\"wpp_2022.rds\")\n\n# A tibble: 43,186 × 65\n   index variant   region_name notes location_code ISO3  ISO2   SDMX type \n   &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n 1     1 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 2     2 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 3     3 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 4     4 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 5     5 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 6     6 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 7     7 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 8     8 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 9     9 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n10    10 Estimates WORLD       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n# ℹ 43,176 more rows\n# ℹ 56 more variables: parent_code &lt;dbl&gt;, year &lt;dbl&gt;, pop_jan_total &lt;dbl&gt;,\n#   pop_jul_total &lt;dbl&gt;, pop_jul_male &lt;dbl&gt;, pop_jul_female &lt;dbl&gt;,\n#   pop_den &lt;dbl&gt;, sex_ratio &lt;dbl&gt;, median_age &lt;dbl&gt;, natural_change &lt;dbl&gt;,\n#   RNC &lt;dbl&gt;, pop_change &lt;dbl&gt;, PGR &lt;dbl&gt;, dubling_time &lt;dbl&gt;, births &lt;dbl&gt;,\n#   births_by_f1519 &lt;dbl&gt;, CBR &lt;dbl&gt;, TFR &lt;dbl&gt;, NRR &lt;dbl&gt;,\n#   mean_age_childbearing &lt;dbl&gt;, sex_ratio_birth &lt;dbl&gt;, deaths_total &lt;dbl&gt;, …\n\n\n\n\n\n\n\n\n힌트\n\n\n\n.rds 파일은 R 전용 특수한 형태의 파일로, R에서 사용하기 편리한 구조를 가지고 있다. R에서 작업을 할 경우에는 .rds 파일을 이용하고 R을 사용하지 않는 사람과 파일을 주고 받을 때에는 .csv파일을 이용하면 좋다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab03: 데이터 불러오기와 정리하기"
    ]
  },
  {
    "objectID": "lab_03.html#데이터-정리하기",
    "href": "lab_03.html#데이터-정리하기",
    "title": "Lab03: 데이터 불러오기와 정리하기",
    "section": "\n3 데이터 정리하기",
    "text": "3 데이터 정리하기\n여기서는 데이터 늘이기(lengthening data), 데이터 넓히기(widening data), 데이터 결합하기(joining data)를 다룬다.\n\n3.1 데이터 늘이기\n실습을 위해 tidyverse 패키지에 포함되어 있는 who2 데이터를 사용한다. 이것은 WHO(world Health Organization, 세계보건기구)에서 제공한 데이터로서 1980~2013년 전세계 209개국의 결핵 환자수에 대한 데이터이다.\n\nglimpse(who2)\n\nRows: 7,240\nColumns: 58\n$ country    &lt;chr&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\",…\n$ year       &lt;dbl&gt; 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989,…\n$ sp_m_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_014  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_1524 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_2534 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_3544 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_4554 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_5564 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_65   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_014  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_1524 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_2534 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_3544 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_4554 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_5564 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_65   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n\n\ncountry와 year은 분명한 변수이지만 나머지 56개 변수는 무엇인지 알 수 없다. 그런데 잘 살펴보면, 변수명에 어떤 패턴이 있다는 것을 알 수 있다. 모두 세 부분으로 나뉘어져 있는데, 첫 번째 부분은 진단법(sp, rel, ep)과 관련되어 있고, 두 번째 부분은 성(m, f)과 관련되어 있고, 세 번째 부분은 연령(014, 1524, 2534, 3544, 4554, 5564, 65)과 관련되어 있다. 56개 변수의 셀 값은 모두 케이스(환자수)를 의미한다. 이 지저분한 데이터를 pivot_longer() 함수를 이용해 정돈된 데이터로 만들어 본다.\n\nwho2 |&gt; \n  pivot_longer(\n    cols = !c(country, year), # country와 year을 제외한 나머지 변수들을 바꾼다.\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), # 원래 데이터의 변수명들이 들어갈 새로운 변수명 지정\n    names_sep = \"_\", # \"_\"를 기준으로 원래의 변수명을 분할\n    values_to = \"count\" # 원래 데이터의 값들이 들어갈 새로운 변수명 지정\n  )\n\n# A tibble: 405,440 × 6\n   country      year diagnosis gender age   count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;\n 1 Afghanistan  1980 sp        m      014      NA\n 2 Afghanistan  1980 sp        m      1524     NA\n 3 Afghanistan  1980 sp        m      2534     NA\n 4 Afghanistan  1980 sp        m      3544     NA\n 5 Afghanistan  1980 sp        m      4554     NA\n 6 Afghanistan  1980 sp        m      5564     NA\n 7 Afghanistan  1980 sp        m      65       NA\n 8 Afghanistan  1980 sp        f      014      NA\n 9 Afghanistan  1980 sp        f      1524     NA\n10 Afghanistan  1980 sp        f      2534     NA\n# ℹ 405,430 more rows\n\n\n정돈된 데이터를 만들기 위해 왜 데이터 ’늘이기’를 해야하는지 생각해 보라.\n\n3.2 데이터 넓히기\n실습을 위해 tidyverse 패키지에 포함되어 있는 cms_patient_experience 데이터를 사용한다. 이것은 미국의 Centers of Medicare and Meicaid Services가 제공한 데이터이다.\n\nView(cms_patient_experience)\n\n이 데이터도 정돈된 데이터가 아니다. 자세히 살펴보면 다음과 같은 사실을 알 수 있다.\n\norg_pac_id와 org_nm 변수는 의료조직의 식별자와 이름이다.\n의료조직별로 6개씩의 열을 차지하고 있는데, 6개의 열은 measure_cd와 measure_title에 나타나 있는 것과 같은 6개의 서로 다른 조사 항목을 나타낸다.\n마지막의 prf_rate는 조사 항목별 점수이다.\n\npivot_wider() 함수를 이용하여, 행에는 개별 의료조직이, 열에는 개별 조사 항목이 나타나는 정돈된 데이터를 만들어 본다.\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    names_from = measure_cd, # 원래 데이터의 measure_cd 값들을 변수로 변환\n    values_from = prf_rate # 원래 데이터의 prf_rate 값들을 변수의 값으로 변환\n  )\n\n# A tibble: 500 × 9\n   org_pac_id org_nm           measure_title CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3\n   &lt;chr&gt;      &lt;chr&gt;            &lt;chr&gt;               &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 0446157747 USC CARE MEDICA… CAHPS for MI…          63          NA          NA\n 2 0446157747 USC CARE MEDICA… CAHPS for MI…          NA          87          NA\n 3 0446157747 USC CARE MEDICA… CAHPS for MI…          NA          NA          86\n 4 0446157747 USC CARE MEDICA… CAHPS for MI…          NA          NA          NA\n 5 0446157747 USC CARE MEDICA… CAHPS for MI…          NA          NA          NA\n 6 0446157747 USC CARE MEDICA… CAHPS for MI…          NA          NA          NA\n 7 0446162697 ASSOCIATION OF … CAHPS for MI…          59          NA          NA\n 8 0446162697 ASSOCIATION OF … CAHPS for MI…          NA          85          NA\n 9 0446162697 ASSOCIATION OF … CAHPS for MI…          NA          NA          83\n10 0446162697 ASSOCIATION OF … CAHPS for MI…          NA          NA          NA\n# ℹ 490 more rows\n# ℹ 3 more variables: CAHPS_GRP_5 &lt;dbl&gt;, CAHPS_GRP_8 &lt;dbl&gt;, CAHPS_GRP_12 &lt;dbl&gt;\n\n\n지난 시간과 같은 방식으로 데이터 늘이기를 수행했으나 여전히 하나의 의료 조직이 여러 행에 걸쳐 나타나고 있음을 확인할 수 있다. 이를 해결하기 위해 각 행을 고유하게 식별하는 변수를 선택한다. 이 데이터에서는 “org”로 시작하는 변수들이 이에 해당한다.\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    id_cols = starts_with(\"org\"), # 각 행을 고유하게 식별하는 변수 선택\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n\n# A tibble: 95 × 8\n   org_pac_id org_nm CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5 CAHPS_GRP_8\n   &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 0446157747 USC C…          63          87          86          57          85\n 2 0446162697 ASSOC…          59          85          83          63          88\n 3 0547164295 BEAVE…          49          NA          75          44          73\n 4 0749333730 CAPE …          67          84          85          65          82\n 5 0840104360 ALLIA…          66          87          87          64          87\n 6 0840109864 REX H…          73          87          84          67          91\n 7 0840513552 SCL H…          58          83          76          58          78\n 8 0941545784 GRITM…          46          86          81          54          NA\n 9 1052612785 COMMU…          65          84          80          58          87\n10 1254237779 OUR L…          61          NA          NA          65          NA\n# ℹ 85 more rows\n# ℹ 1 more variable: CAHPS_GRP_12 &lt;dbl&gt;\n\n\n이제 어떤 의료조직이 어떤 항목에서 얼마의 점수를 받았는지를 일목요연하게 알아 볼 수 있다. 정돈된 데이터를 만들기 위해 이번에는 왜 데이터 ’넓히기’를 해야하는지 생각해 보라.\n\n3.3 데이터 결합하기\n\n3.3.1 조인(join)의 종류\n여기서는 데이터 프레임을 결합하여 새로운 데이터 프레임을 생성하는 과정에 대해 살펴본다. tidyverse 패키지에 포함되어 있는 dplyr 패키지는 다양한 종류의 조인(join) 함수를 제공한다.\n\nleft_join(): 첫 번째 변수는 그대로 둔 상태에서 두 번째 변수를 결합함으로써 두 번째 변수의 열을 가져옴\ninner_join(): 두 번째 변수는 그대로 둔 상태에서 첫 번째 변수를 결합함으로써 첫 번째 변수의 열을 가져옴\nright_join(): 두 변수 모두에 존재하는 열을 취함\nfull_join(): 최소한 한 변수에 존재하는 열을 모두 취함\nsemi_join(): 첫 번째 변수의 행 중 두 번째 변수에 대응하는 행이 있는 것만 취함\nanti_join(): 첫 번째 변수의 행 중 두 번째 변수에 대응하는 행이 없는 것만 취함\n\n이들 중 left_join()이 가장 많이 사용되기 때문에 그것에 집중한다.\n\n3.3.2 left_join() 함수의 활용\n실습을 위해 nycflights13 패키지의 데이터를 사용한다. 이 패키지에는 다섯 개의 데이터 프레임이 포함되어 있다. 지난 번에는 첫 번째 데이터만 사용했다.\n\nflights: 2013년 NYC를 출발한 모든 항공기\nweather: 공항별 시간별 기상 상황\nplanes: 항공기별 건조 정보\nairports: 공항명과 위치\nairlines: 항공사\n\n그리고 이 6개의 데이터 프레임은 그림 1 처럼 공통키(common key)를 통해 서로 연결되어 있다.\n\n\n\n\n\n그림 1: nycflights13 데이터(https://github.com/tidyverse/nycflights13)\n\n\nflights 데이터의 변수가 너무 많기 때문에 조인을 위한 공통키를 중심으로 변수를 줄인다.\n\nlibrary(nycflights13)\n\n\nflights2 &lt;- flights |&gt; \n  select(year, time_hour, origin, dest, tailnum, carrier)\nflights2\n\n# A tibble: 336,776 × 6\n    year time_hour           origin dest  tailnum carrier\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  \n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     \n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     \n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     \n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     \n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     \n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6     \n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV     \n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6     \n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA     \n# ℹ 336,766 more rows\n\n\nflights2 데이터를 중심으로 나머지 4개의 데이터와 조인한다.\n\nairlines\n\n# A tibble: 16 × 2\n   carrier name                       \n   &lt;chr&gt;   &lt;chr&gt;                      \n 1 9E      Endeavor Air Inc.          \n 2 AA      American Airlines Inc.     \n 3 AS      Alaska Airlines Inc.       \n 4 B6      JetBlue Airways            \n 5 DL      Delta Air Lines Inc.       \n 6 EV      ExpressJet Airlines Inc.   \n 7 F9      Frontier Airlines Inc.     \n 8 FL      AirTran Airways Corporation\n 9 HA      Hawaiian Airlines Inc.     \n10 MQ      Envoy Air                  \n11 OO      SkyWest Airlines Inc.      \n12 UA      United Air Lines Inc.      \n13 US      US Airways Inc.            \n14 VX      Virgin America             \n15 WN      Southwest Airlines Co.     \n16 YV      Mesa Airlines Inc.         \n\nflights2 |&gt;\n  left_join(airlines)\n\n# A tibble: 336,776 × 7\n    year time_hour           origin dest  tailnum carrier name                  \n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;                 \n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines Inc. \n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines Inc. \n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines Inc.\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways       \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.  \n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines Inc. \n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      JetBlue Airways       \n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      ExpressJet Airlines I…\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      JetBlue Airways       \n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      American Airlines Inc.\n# ℹ 336,766 more rows\n\n\n\nweather\n\n# A tibble: 26,115 × 15\n   origin  year month   day  hour  temp  dewp humid wind_dir wind_speed\n   &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;\n 1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4 \n 2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06\n 3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5 \n 4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7 \n 5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7 \n 6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5 \n 7 EWR     2013     1     1     7  39.0  28.0  64.4      240      15.0 \n 8 EWR     2013     1     1     8  39.9  28.0  62.2      250      10.4 \n 9 EWR     2013     1     1     9  39.9  28.0  62.2      260      15.0 \n10 EWR     2013     1     1    10  41    28.0  59.6      260      13.8 \n# ℹ 26,105 more rows\n# ℹ 5 more variables: wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;,\n#   visib &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\nflights2 |&gt; \n  left_join(weather |&gt; select(origin, time_hour, temp, wind_speed))\n\n# A tibble: 336,776 × 8\n    year time_hour           origin dest  tailnum carrier  temp wind_speed\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;      &lt;dbl&gt;\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA       39.0       12.7\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA       39.9       15.0\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA       39.0       15.0\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6       39.0       15.0\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL       39.9       16.1\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA       39.0       12.7\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6       37.9       11.5\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV       39.9       16.1\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6       37.9       13.8\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA       39.9       16.1\n# ℹ 336,766 more rows\n\n\n\nplanes\n\n# A tibble: 3,322 × 9\n   tailnum  year type              manufacturer model engines seats speed engine\n   &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; \n 1 N10156   2004 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 2 N102UW   1998 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 3 N103US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 4 N104UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 5 N10575   2002 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 6 N105UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 7 N107US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 8 N108UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 9 N109UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n10 N110UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n# ℹ 3,312 more rows\n\nflights2 |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\n\n# A tibble: 336,776 × 9\n    year time_hour           origin dest  tailnum carrier type     engines seats\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;int&gt; &lt;int&gt;\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Fixed w…       2   149\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      Fixed w…       2   149\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Fixed w…       2   178\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      Fixed w…       2   200\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Fixed w…       2   178\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Fixed w…       2   191\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Fixed w…       2   200\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      Fixed w…       2    55\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      Fixed w…       2   200\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;          NA    NA\n# ℹ 336,766 more rows\n\n\n\nairports\n\n# A tibble: 1,458 × 8\n   faa   name                             lat    lon   alt    tz dst   tzone    \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n 1 04G   Lansdowne Airport               41.1  -80.6  1044    -5 A     America/…\n 2 06A   Moton Field Municipal Airport   32.5  -85.7   264    -6 A     America/…\n 3 06C   Schaumburg Regional             42.0  -88.1   801    -6 A     America/…\n 4 06N   Randall Airport                 41.4  -74.4   523    -5 A     America/…\n 5 09J   Jekyll Island Airport           31.1  -81.4    11    -5 A     America/…\n 6 0A9   Elizabethton Municipal Airport  36.4  -82.2  1593    -5 A     America/…\n 7 0G6   Williams County Airport         41.5  -84.5   730    -5 A     America/…\n 8 0G7   Finger Lakes Regional Airport   42.9  -76.8   492    -5 A     America/…\n 9 0P2   Shoestring Aviation Airfield    39.8  -76.6  1000    -5 U     America/…\n10 0S9   Jefferson County Intl           48.1 -123.    108    -8 A     America/…\n# ℹ 1,448 more rows\n\nflights2 |&gt; \n  left_join(airports, join_by(origin == faa))\n\n# A tibble: 336,776 × 13\n    year time_hour           origin dest  tailnum carrier name         lat   lon\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Newark Li…  40.7 -74.2\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      La Guardia  40.8 -73.9\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      John F Ke…  40.6 -73.8\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      John F Ke…  40.6 -73.8\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      La Guardia  40.8 -73.9\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Newark Li…  40.7 -74.2\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Newark Li…  40.7 -74.2\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      La Guardia  40.8 -73.9\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      John F Ke…  40.6 -73.8\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      La Guardia  40.8 -73.9\n# ℹ 336,766 more rows\n# ℹ 4 more variables: alt &lt;dbl&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, tzone &lt;chr&gt;\n\n\nairports의 경우만 왜 join_by()라는 아규먼트가 필요한지 생각해 본다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab03: 데이터 불러오기와 정리하기"
    ]
  },
  {
    "objectID": "lab_05.html",
    "href": "lab_05.html",
    "title": "Lab05: 데이터 시각화하기",
    "section": "",
    "text": "이 실습은 R로 데이터사이언스를 하는 과정 중 데이터 시각화하기(visualizing)를 다룬다. 다음의 사항을 다룬다. 데이터 시각화하기는 tidyverse의 핵심 패키지 중의 하나인 ggplot2 에서 제공된다.\n모든 실습의 시작은 tidyverse 패키지를 불러오는 것이다. 또한 이후 사용하게 될 패키지 ggrepel, patchwork, RColorBrewer 패키지도 미리 설치하고 불러온다.\n\nlibrary(tidyverse)\nlibrary(ggrepel)\nlibrary(patchwork)\nlibrary(RColorBrewer)\n\n실습을 위해 ggplot2 패키지 속에 포함되어 있는 mpg 데이터와 diamonds 데이터를 사용한다. 각 데이터에서 눈여겨 볼 변수는 아래와 같다.\n\n\nmpg\n\ndispl : 배기량(displacement)\nclass : 자동차 유형(compact/midsize/suv/2seater/minivan/pickup/subcompact)\nhwy : 고속도로(highway) 연비\n\n\n\ndiamonds\n\nprice : 가격\ncarat : 캐럿\ncolor : 다이아몬드 색깔\nclarity : 투명도\ncut : 가공의 품질",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab05: 데이터 시각화하기"
    ]
  },
  {
    "objectID": "lab_05.html#실습-개요",
    "href": "lab_05.html#실습-개요",
    "title": "Lab05: 데이터 시각화하기",
    "section": "",
    "text": "이 실습은 R로 데이터사이언스를 하는 과정 중 데이터 시각화하기(visualizing)를 다룬다. 다음의 사항을 다룬다. 데이터 시각화하기는 tidyverse의 핵심 패키지 중의 하나인 ggplot2 에서 제공된다.\n모든 실습의 시작은 tidyverse 패키지를 불러오는 것이다. 또한 이후 사용하게 될 패키지 ggrepel, patchwork, RColorBrewer 패키지도 미리 설치하고 불러온다.\n\nlibrary(tidyverse)\nlibrary(ggrepel)\nlibrary(patchwork)\nlibrary(RColorBrewer)\n\n실습을 위해 ggplot2 패키지 속에 포함되어 있는 mpg 데이터와 diamonds 데이터를 사용한다. 각 데이터에서 눈여겨 볼 변수는 아래와 같다.\n\n\nmpg\n\ndispl : 배기량(displacement)\nclass : 자동차 유형(compact/midsize/suv/2seater/minivan/pickup/subcompact)\nhwy : 고속도로(highway) 연비\n\n\n\ndiamonds\n\nprice : 가격\ncarat : 캐럿\ncolor : 다이아몬드 색깔\nclarity : 투명도\ncut : 가공의 품질",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab05: 데이터 시각화하기"
    ]
  },
  {
    "objectID": "lab_05.html#핵심-레이어-심미성과-기하",
    "href": "lab_05.html#핵심-레이어-심미성과-기하",
    "title": "Lab05: 데이터 시각화하기",
    "section": "\n1 핵심 레이어: 심미성과 기하",
    "text": "1 핵심 레이어: 심미성과 기하\n이 8개 구성요소 중 가장 중요한 것은 ‘심미성(aesthetics)’ 혹은 ‘심미성 매핑(aesthetic mapping)’와 ’기하(geometries)’ 혹은 ’기하 객체(geometric objects)’이다. 기하가 그래프의 전체 구조 혹은 형식을 규정하는 것이라면, 심미성은 기하의 외견을 규정한다. 결국 기하는 그래프의 유형(예: 막대 그래프, 산포도 등)과 관련되고, 심미성은 그래프의 시각적 속성(예: x축, y축, 컬러, 크기, 모양 등)과 관련된다. 이 두 가지는 독립적인 요소이지만, 어느 정도는 관련되어 있기도 하다. 모든 기하가 모든 심미성과 결합할 수 있는 것은 아니다. 특정한 기하는 오로지 특정한 심미성과만 결합한다. 예를 들어 포인트 기하 객체(geom_point())는 크기(size) 심미성과 관련되지만, 라인 기하 객체(geom_line())는 크기 심미성과는 관련되지 않고 라인폭(linewidth) 심미성과만 관련되는 식이다.\n\n1.1 기초 예제\n그래프를 그리기 위해 반드시 필요한 것은 데이터, 심미성, 기하이다. 이들을 차례로 하나씩 추가해본다.\n그림 1 를 보면, 빈 화면만 출력되는 것을 볼 수 있다. 데이터만 올라왔으므로, 그릴 수 있는 것이 없다. 그림 2 에서는 x축과 y축이 나타났다. 그러나 이 재료를 가지고 무슨 그래프를 그릴지는 지정하지 않았으므로 아무 그래프도 나타나지 않는다. 그림 3 에서야 비로소 그래프가 나타나는데, 이는 어떤 데이터로부터 어떤 변수를 사용할지, 그리고 그것을 어떤 방식으로 그릴지를 모두 지정해주었기 때문이다.\n\n# 데이터만 추가\nggplot(data=mpg)\n\n\n\n\n\n\n그림 1: 데이터만 추가\n\n\n\n\n\nggplot(data=mpg, aes(x=displ, y=hwy))\n\n\n\n\n\n\n그림 2: 데이터 + 심미성(x, y축)\n\n\n\n\n\nggplot(data=mpg, aes(x=displ, y=hwy)) +\n  geom_point()\n\n\n\n\n\n\n그림 3: 데이터 + 심미성(x, y축) + 기하\n\n\n\n\n\n1.2 심미성 매핑\n심미성 매핑이란 다양한 시각적 속성 혹은 재료를 그래프에 적용 혹은 부여하는 과정을 의미한다. displ과 hwy의 관계가 class에 따라 어떻게 달라지는지를 시각화한다. 다음의 두 그래프를 비교해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 4: 심미성: 컬러\n\n\n\n\n\nggplot(mpg, aes(x = displ, y = hwy, shape = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 5: 심미성: 형태\n\n\n\n\n그림 4 과 그림 5 중 어느 것이 더 효과적인 시각화라고 생각하는가? 컬러(color)와 형태(shape)라는 심미성 요소 외에 크기(size)와 투명도(alpha) 요소를 동일한 데이터에 적용해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, size = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 6: 심미성: 크기\n\n\n\n\n\nggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 7: 심미성: 투명도\n\n\n\n\n크기와 투명도는 양적인 차이를 나타내는데 적합한 심미성이기 때문에 class라는 정성적인 범주의 차이를 보여주는데는 적합하지 않다. 심미성 부여에서 가장 중요한 것은 결국 얼마나 적절한 심미성 요소, 혹은 시각 변수(visual variables)를 선택하느냐에 달려 있다.\n\n1.3 기하 객체\n그림 8 와 그림 9 이 다르게 보이는 것은 기하 객체가 하나는 포인트(point)이고 다른 하나는 완만한 선(smooth)이기 때문이다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point()\n\n\n\n\n\n\n그림 8: 기하: geom_point()\n\n\n\n\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_smooth()\n\n\n\n\n\n\n그림 9: 기하: geom_smooth()\n\n\n\n\n그림 4 과 그림 9 두 개를 결합해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = class)) + \n  geom_point() + \n  geom_smooth()\n\n\n\n\n\n\n그림 10: 기하: geom_point() + geom_smooth() 1\n\n\n\n\n원하는 것이 아니다. 왜 이런 결과가 나왔으며, 어떻게 하면 원하는 것을 얻을 수 있을지 생각해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(aes(color = class)) + \n  geom_smooth()\n\n\n\n\n\n\n그림 11: 기하: geom_point() + geom_smooth() 2\n\n\n\n\n두 결과의 차이는 color 심미성을 글로벌하게 적용하느냐 로컬하게 적용하느냐(포인트 기하에만 적용)에 달린 것이다. 글로벌한 심미성은 ggplot()속에서 설정하고, 국지적인 심미성은 개별 기하(geom_point()) 속에서 설정한다. 매우 중요한 사항이니 꼭 기억하도록 한다.\n다양한 기하 객체는 동일한 데이터를 다양한 방식으로 탐색할 수 있게 해준다. 다음의 세가지 기하 객체는 탐색적 데이터 분석에서 널리 사용되는 것이다.\n\nggplot(mpg, aes(x = hwy)) +\n  geom_histogram(binwidth = 2)\n\n\n\n\n\n\n그림 12: 기하: geom_histogram()\n\n\n\n\n\nggplot(mpg, aes(x = hwy)) +\n  geom_density()\n\n\n\n\n\n\n그림 13: 기하: geom_density()\n\n\n\n\n\nggplot(mpg, aes(x = hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n그림 14: 기하: geom_boxplot()",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab05: 데이터 시각화하기"
    ]
  },
  {
    "objectID": "lab_05.html#다른-레이어",
    "href": "lab_05.html#다른-레이어",
    "title": "Lab05: 데이터 시각화하기",
    "section": "\n2 다른 레이어",
    "text": "2 다른 레이어\n\n2.1 스케일\n스케일(scales)은 심미성이 구체적으로 어떻게 구현될지를 결정한다. 예를 들어 color 심미성이 적용되었다 하더라도 어떤 색상이 선정되어 어떻게 배열되는지에 따라 최종 그래프의 모습은 매우 달라질 수 있다. 그래프를 다시 나타낸다. 스케일이 어느 부분에 어떻게 적용되었는지 생각해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() \n\n\n\n\n\n\n그림 15\n\n\n\n\n그림 15 은 아래에서 보는 것처럼, ggplot2가 자동적으로 적용한 세 가지의 스케일 설정에 의거해 만들어진 것이다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_color_discrete()\n\n수정하여 다음과 같이 적용할 수 있다. scale 함수의 아규먼트가 어떤 역할을 하는지 생각해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(breaks = seq(15, 40, by = 5)) +\n  scale_color_brewer(palette = \"Set1\", labels = c(\"4\" = \"4-wheel\", \"f\" = \"front\", \"r\" = \"rear\"))\n\n\n\n\n\n\n그림 16\n\n\n\n\nscale_color_brewer() 함수는 ColorBrewer 컬러 스케일을 사용한 것인데 익히고 있으면 많은 도움이 된다. 살펴보면 양적인 변수에 적용하기 좋은 팔레트가 있고, 질적인 변수에 적용하기 좋은 팔레트도 있다. 한번 마음에 드는 팔레트를 골라보자.\n\npar(mar=c(0.1, 3, 0.1, 1))\ndisplay.brewer.all()\n\n\n\n\n\n\n\n\n\n\n\n\n\n힌트직접 색상 지정하는 방법\n\n\n\n\n\n한편, 내가 원하는 색상을 골라 직접 지정하는 방법도 있다. scale_color_brewer() 대신 scale_color_manual() 함수를 사용하면 된다. 또한 RGB 색상에 대한 html 코드를 사용해도 되고, R에서 부여한 657개의 이름 중에서 골라 사용해도 된다. 색상 이름 및 html 코드는 다음 사이트를 참고하라.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(breaks = seq(15, 40, by = 5)) +\n  scale_color_manual(values = c(\"sienna1\", \"slateblue4\", \"#698B22\"))\n\n\n\n\n\n\n\n\n\n\n\n2.2 패싯\n패싯(facets) 레이어는 다면생성(faceting) 과정을 통해 하나의 플롯을 여러개의 하위 플롯으로 쪼갬으로서 생성된다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_wrap(~cyl)\n\n\n\n\n\n\n그림 17: 패싯: facet_wrap()\n\n\n\n\n두 개의 변수에 의거해 패싯을 생성할 수도 있다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl)\n\n\n\n\n\n\n그림 18: 패싯: facet_grid()\n\n\n\n\n\n2.3 통계적 변환\n어떤 시각화 과정은 필연적으로 통계적 변환(statistical transformation)을 수반한다.\n\nggplot(diamonds, aes(x = cut)) + \n  geom_bar()\n\n\n\n\n\n\n그림 19: 통계적 변환: geom_bar()\n\n\n\n\nafter_stat()이라고 하는 도우미 함수를 사용하면, 이 그래프를 절대 빈도가 아닌 상대 빈도 그래프로 변환할 수 있다. 이 역시 통계적 변환 과정이 숨어 있는 것이다.\n\nggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + \n  geom_bar()\n\n\n\n\n\n\n그림 20: 통계적 변환: geom_bar()\n\n\n\n\n\n\n\n\n\n\n힌트geom_bar() vs. geom_col()\n\n\n\n\n\ngeom_bar() 함수는 자동으로 통계적 변환을 한 후 결과를 반환한다. 그래서 y축을 지정하지 않아도 된다. 반면 geom_col() 함수는 마찬가지로 막대그래프이지만, x축과 그에 상응하는 y축의 값을 바탕으로 그래프를 생성한다. 아래의 두 코드를 살펴보고 결과를 비교해보자. geom_bar()의 통계적 변환이 무엇을 한 것인지, 두 함수의 차이가 무엇이지 이해할 수 있을 것이다. 참고로 두 번째 코드는 지난 실습 때 다룬 count() 함수를 활용한 것이다. 다른 코드이지만 동일한 결과가 출력됨됨을 알 수 있다.\n\ndiamonds |&gt; \n  ggplot(aes(x = cut)) +\n  geom_bar()\n\n\n\n\n\n\n\n\ndiamonds |&gt;\n  count(cut) |&gt; \n  ggplot(aes(x = cut, y = n)) +\n  geom_col()\n\n\n\n\n\n\n\n\n\n\n막대 그래프에 심미성을 가미하고, position 아규먼트를 통한 위치 조정(position adjustment)을 시도한다.\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar()\n\n\n\n\n\n\n그림 21: position: stack\n\n\n\n\n기하 객체에 색상을 지정하고 싶을 때, 0차원(point)과 1차원(line) 객체에는 color라는 심미성을 적용하지만, 막대 그래프와 같은 2차원(area) 객체에는 fill이라는 심미성을 적용한다. 자주 혼돈이 되는 부분이다.\n위치 조정을 위해 position 아규먼트를 사용하는데, 네 가지 옵션이 있다.\n\nposition = \"stack\"\nposition = \"identity\"\nposition = \"dodge\"\nposition = \"fill\"\n\n그림 21 에는 디폴트로 position = \"stack\"이 적용된 것이다. 그림 22 는 position = \"dodge\"를 적용한 것이다 . 나머지 옵션도 적용해보고 차이가 무엇인지 알아본다.\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n그림 22: position: dodge\n\n\n\n\n\n\n\n\n\n\n힌트position 아규먼트의 종류와 차이\n\n\n\n\n\nposition 아규먼트에 따른 차이는 아래의 그래프가 잘 보여준다. 아래에서 배울(운) patchwork도 활용했다.\n\ng1 &lt;- ggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"stack\") +\n  labs(title = \"'stack' graph\")\n\ng2 &lt;- ggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"dodge\") +\n  labs(title = \"'dodge' graph\")\n\ng3 &lt;- ggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\") +\n  labs(title = \"'fill' graph\")\n\ng4 &lt;- ggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"identity\") +\n  labs(title = \"'identity' graph\")\n\ng1+g2+g3+g4 +\n  plot_annotation(\n    title = \"How does position argument work?\",\n    subtitle = \"Graph differences by position argument\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n2.4 좌표\n좌표(coordinates) 레이어 혹은 좌표계(coordinate systems)는 그래픽 요소들의 위치 결정에 기준이 되는 준거체계이다. 특히 두 가지가 함수가 유용하다. coord_flip() 함수는 축을 전환한다.\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\") +\n  coord_flip()\n\n\n\n\n\n\n그림 23: coord_clip() 함수\n\n\n\n\ncoord_fixed() 함수는 두 축의 스케일을 절대화하여 동일하게 적용한다. 아규먼트로 x축 한 단위 대비 y축 한 단위의 비(y/x)를 받으며, 생략할 경우 디폴트로 1을 지정한다. 무슨 의미인지 알아본다.\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point() +\n  coord_fixed()\n\n\n\n\n\n\n그림 24: coord_fixed() 함수\n\n\n\n\n\n\n\n\n\n\n힌트왜 coord_fixed() 함수를 사용할까?\n\n\n\n\n\ncoord_fixed()를 사용하지 않아도 ggplot은 적당한 비율을 찾아 그래프를 그려준다. 그러나 간혹 사용자가 원하는 가로-세로 비율이 있을 때가 있다. 예를 들어, 우리나라가 동고서저의 지형임을 보여주는 그래프를 그려보자.\n\n# 가상 데이터\ndata &lt;- tibble(x=seq(0, 170, by=10),\n               y=c(10, 62, 108, 162, 245, 330, 469, 608, 780, 942,\n                   1125, 1307, 1500, 1707, 1324, 849, 394, 0))\n\n\n# 비율 지정 안하면?\nggplot(data, aes(x=x, y=y)) +\n  geom_point()+\n  geom_line()+\n  labs(x=\"서울-강릉(km)\", y=\"고도(m)\")\n\n\n\n\n\n\n\n비율을 지정하지 않으니 조금 이상하다. 시각적 효과를 위해서, 가로 한 단위와 세로 한 단위의 비율을 적절히 맞춰보자.\n\n# 적정 비율 지정하기\nggplot(data, aes(x=x, y=y)) +\n  geom_point()+\n  geom_line()+\n  labs(x=\"서울-강릉(km)\", y=\"고도(m)\") +\n  coord_fixed(ratio = 0.02)\n\n\n\n\n\n\n\n아까보다 조금 더 가독성이 좋아짐을 확인할 수 있다.\n\n\n\n\n2.5 테마\n디폴트인 회색빛 배경이 마음에 들지 않았다면 그림 25 처럼 흑백 테마(theme_bw())를 적용할 수도 있다. 다른 테마도 적용해 보고 그 차이를 알아본다.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  theme_bw()\n\n\n\n\n\n\n그림 25: theme_bw() 함수\n\n\n\n\n이렇게 한꺼번에 그래프의 외관을 바꿀 수도 있지만 theme() 함수를 통해 그래프의 개별 요소 하나씩을 모두 수정할 수 있다. 어떤 요소를 바꿀 수 있는지 다음을 참고한다.\n\nhttps://ggplot2.tidyverse.org/reference/theme.html\n\n그림 26 는 몇 가지 요소를 수정한 사례이다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  labs(\n    title = \"Larger engine sizes tend to have lower fuel economy\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  theme(\n    legend.position = c(0.6, 0.7),\n    legend.direction = \"horizontal\",\n    plot.title = element_text(face = \"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(hjust = 0)\n  )\n\n\n\n\n\n\n그림 26: 개별 요소의 수정: theme() 함수",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab05: 데이터 시각화하기"
    ]
  },
  {
    "objectID": "lab_05.html#기타-사항",
    "href": "lab_05.html#기타-사항",
    "title": "Lab05: 데이터 시각화하기",
    "section": "\n3 기타 사항",
    "text": "3 기타 사항\n\n3.1 라벨과 주석\nlab() 함수를 활용하면 그래프의 다양한 종류의 라벨을 설정할 수 있다.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  labs(\n    x = \"Engine displacement (L)\",\n    y = \"Highway fuel economy (mpg)\",\n    color = \"Car type\",\n    title = \"Fuel efficiency generally decreases with engine size\",\n    subtitle = \"Two seaters (sports cars) are an exception because of their light weight\",\n    caption = \"Data from fueleconomy.gov\"\n  )\n\n\n\n\n\n\n그림 27: 라벨링\n\n\n\n\n기하 함수인 geom_text() 혹은 geom_label()를 통해 그래프 속에 텍스트를 삽입할 수 있다. 주석이 겹치는 것을 방지하기 위해 ggrepel 패키지가 유용하게 사용될 수 있다.\n\nlibrary(ggrepel)\n\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(colour = \"red\") +\n  geom_label_repel(data = mpg |&gt; slice_sample(prop = 0.1), aes(label = class))\n\n\n\n\n\n\n\n\n3.2 레이아웃\n레이아웃(layout)은 복수의 그래프를 적절히 배치하여 하나의 그래픽으로 융합하는 과정을 의미한다. 수 많은 ggplot2의 확장 패키지(ggplot2 extensions) 중 하나이 patchwork 패키지를 활용할 수 있다.\n\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 1\")\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"Plot 2\")\np1 + p2\n\n\n\n\n\n\n그림 28: 레이아웃: patchwork 패키지\n\n\n\n\n\n\n\n\n\n\n힌트patchwork() 더 살펴보기\n\n\n\n\n\npatchwork() 패키지는 그래프의 배치를 적용하는데 매우 유용하다. 좌우배치를 하되 자동으로 줄넘김을 원한다면 ‘A+B’, 무조건 좌우배치를 원할 때는 ‘A|B’, 상하배치를 원하다면 ’A/B’의 형식을 사용하면 된다. 매우 직관적이다. 위에서 position 아규먼트를 공부할 때 사용한 코드를 재사용해보자.\n\ng1+g2+g3+g4\n\n\n\n\n\n\n\n\n(g1+g3+g4)/g2\n\n\n\n\n\n\n\n\n\n\n\n3.3 그래프의 저장\n두 가지 방식이 있다.\n첫 번째 방식은 Output 창의 Plots 탭에 있는 Export 버을 이용하는 것이다. 다양한 그래픽 포멧 뿐만 아니라 pdf 형식으로도 저장할 수 있다.\n두 번째 방식은 ggplot2 의 ggsave() 함수를 이용하는 것이다. 결과물의 폰트 크기, 가로세로비, 해상도 등을 종합적으로 고려하여 최적의 세팅값을 찾아야 한다. 자신의 디바이스에 따라 동일한 세팅값이 다른 결과를 산출할 수도 있다.\n\nmy_plot &lt;- ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  labs(\n    title = \"Larger engine sizes tend to have lower fuel economy\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  theme(\n    legend.position = c(0.6, 0.7),\n    legend.direction = \"horizontal\",\n    plot.title = element_text(face = \"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(hjust = 0)\n  )\nggsave(filename = \"my_plot.png\", plot = my_plot, width = 8, height = 8 * 0.618, dpi = 600)",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab05: 데이터 시각화하기"
    ]
  },
  {
    "objectID": "lab_08.html",
    "href": "lab_08.html",
    "title": "Lab08: 데이터로 소통하기: Quarto",
    "section": "",
    "text": "File &gt; New File &gt; Quarto Document를 실행한다. Title과 Author란에 적절한 텍스트를 기입하고 아래에 위치한 Create 버튼을 클릭한다.\n\n그렇다면 아마도 아래의 화면이 보일 것이다.\n\n--- 으로 둘러싸인 YAML(YAML Ain’t Markup Language)에 아래와 같은 몇 가지 key: value 를 더해보자.\n\n---\nnumber-sections: true\nformat: \n  html: \n    toc: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\n---\n\n기본적인 Quarto 작성법은 다음과 같다.\n\n텍스트: 그냥 작성\n코드 청크(Code Chunk): Insert &gt; Executable Cell &gt; R(Ctrl+Alt+I)\n표(Table): Insert &gt; Table\n그림(Figure): Insert &gt; Figure\n링크(Link): (원하는 텍스트 선택 후) Insert &gt; Link\n머릿말(Header): Normal &gt; Header 1~6 중 선택\n\n이제 지난 실습록(데이터 수집하기)의 일부분을 재현해보자. 일반 텍스트와 코드 청크를 넣고 이를 렌더링해보면 그럴듯한 html 파일이 만들어짐을 확인할 수 있을 것이다.\n\n추가로 몇 가지의 팁을 소개한다.\n첫째, R의 패키지나 함수를 다르게 표시할 수 있다. 지금까지의 실습록에서 tidyverse 함수를 tidyverse 와 같이 표시하던 것이 기억날 것이다. 이는 해당 텍스트를 선택한 후, Format에서 Code를 누르면 생성된다. 혹은 Ctrl+D로 실행할 수 있다.\n둘째, Call-out 이다. 몇몇 실습록에서 아래와 같은 모습을 보았을 것이다. 문서 중간에 팁이나 주의를 알려주고 있다.\n\n\nCallout에는 공지(note), 팁(tip), 중요사항(important), 주의(caution), 경고(warning) 등이 있다. 이는 비주얼 에디터 메뉴 Insert-Callout에서 선택할 수 있고, ::: 으로 둘러싸인 부분에 글이나 코드 청크를 작성하면 된다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab08: 데이터로 소통하기: Quarto"
    ]
  },
  {
    "objectID": "lab_08.html#실습-1-기본-quarto-다큐먼트의-작성",
    "href": "lab_08.html#실습-1-기본-quarto-다큐먼트의-작성",
    "title": "Lab08: 데이터로 소통하기: Quarto",
    "section": "",
    "text": "File &gt; New File &gt; Quarto Document를 실행한다. Title과 Author란에 적절한 텍스트를 기입하고 아래에 위치한 Create 버튼을 클릭한다.\n\n그렇다면 아마도 아래의 화면이 보일 것이다.\n\n--- 으로 둘러싸인 YAML(YAML Ain’t Markup Language)에 아래와 같은 몇 가지 key: value 를 더해보자.\n\n---\nnumber-sections: true\nformat: \n  html: \n    toc: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\n---\n\n기본적인 Quarto 작성법은 다음과 같다.\n\n텍스트: 그냥 작성\n코드 청크(Code Chunk): Insert &gt; Executable Cell &gt; R(Ctrl+Alt+I)\n표(Table): Insert &gt; Table\n그림(Figure): Insert &gt; Figure\n링크(Link): (원하는 텍스트 선택 후) Insert &gt; Link\n머릿말(Header): Normal &gt; Header 1~6 중 선택\n\n이제 지난 실습록(데이터 수집하기)의 일부분을 재현해보자. 일반 텍스트와 코드 청크를 넣고 이를 렌더링해보면 그럴듯한 html 파일이 만들어짐을 확인할 수 있을 것이다.\n\n추가로 몇 가지의 팁을 소개한다.\n첫째, R의 패키지나 함수를 다르게 표시할 수 있다. 지금까지의 실습록에서 tidyverse 함수를 tidyverse 와 같이 표시하던 것이 기억날 것이다. 이는 해당 텍스트를 선택한 후, Format에서 Code를 누르면 생성된다. 혹은 Ctrl+D로 실행할 수 있다.\n둘째, Call-out 이다. 몇몇 실습록에서 아래와 같은 모습을 보았을 것이다. 문서 중간에 팁이나 주의를 알려주고 있다.\n\n\nCallout에는 공지(note), 팁(tip), 중요사항(important), 주의(caution), 경고(warning) 등이 있다. 이는 비주얼 에디터 메뉴 Insert-Callout에서 선택할 수 있고, ::: 으로 둘러싸인 부분에 글이나 코드 청크를 작성하면 된다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab08: 데이터로 소통하기: Quarto"
    ]
  },
  {
    "objectID": "lab_08.html#실습-2-개인-블로그-만들기",
    "href": "lab_08.html#실습-2-개인-블로그-만들기",
    "title": "Lab08: 데이터로 소통하기: Quarto",
    "section": "\n2 실습 2: 개인 블로그 만들기",
    "text": "2 실습 2: 개인 블로그 만들기\nQuarto를 활용하면 개인 블로그도 만들 수 있다. 어떻게 보면 블로그나 웹사이트는 위에서 만든 html의 집합이라고도 볼 수 있다. 블로그는 다음의 과정을 통해 생성할 수 있다.\n\n2.1 새로운 Quarto Blog 프로젝트 시작하기\nFile &gt; New Project &gt; Create Project &gt; Quarto Blog를 선택한다.\n\n\n\n\n\n\n\n\n\n\n디렉토리 이름과 경로를 설정하고, 아래에 위치한 Create Project 버튼을 클릭한다.\n\n\n2.2 렌더링하여 결과를 살펴보기\nRender 버튼을 클릭하여 결과를 확인한다. 결과는 오른쪽 패널의 Viewer 탭에 나타난다. Viewer 탭의 Show in new window 아이콘을 클릭하면 웹브라우저 상에 결과를 나타낼 수 있다.\n\nFiles 탭을 클릭하면 프로젝트 폴더에 다음과 같은 파일들이 생성되어 있음을 확인할 수 있다. 조교의 도움을 받아 각각의 파일이 어떠한 역할을 하는지 파악한다.\n\n\nFile\nDescription\n\n\n\n_quarto.yml\nQuarto 프로젝트 파일\n\n\nindex.qmd\n블로그의 홈페이지\n\n\nabout.qmd\n블로그의 어바우트 페이지\n\n\nposts/\n포스트를 포함하고 있는 폴더\n\n\nposts/_metadata.yml\n포스트가 공유하고 있는 옵션들\n\n\nstyles.css\n웹사이트의 CSS\n\n\n\n2.3 구성 요소 수정하기\n구성 요소를 수정하여 자신의 개인 블로그를 만들어 나간다.\n\n2.3.1 메타데이터\n블로그의 전체적인 모습은 _quarto.yml 파일에 의해 규정된다. _quarto.yml 파일의 내용을 살펴보고 조교의 도움을 받아 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히, 25개의 테마를 살펴보고, 그 중 하나를 선택한다. theme 만 바꿔주어도 아래와 같이 그럴듯한 블로그가 완성된다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n힌트다크 모드\n\n\n\n하나의 테마만 적용하는 것이 아니라, 다크 모드도 지정할 수 있다. 아래의 코드를 _quarto.yml 에 추가해보자.\n\ntheme:\n  light: flatly\n  dark: darkly\n\n\n\n\n2.3.2 홈페이지(home page)\n블로그의 홈페이지는 포스트 디렉토리에 포함되는 모든 포스트의 리스트를 제공하는 것으로 index.qmd 파일에 의해 규정된다. index.qmd 파일의 내용을 살펴보고 조교의 도움을 받아 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히 리스팅 유형(listing types) 옵션 세개(default, table, grid)를 살펴보고, 그 중 하나를 선택한다. 아래의 그림을 보면 그 차이를 직관적으로 알 수 있을 것이다.\n\n\n\n\n2.3.3 어바우트 페이지(about page)\n어바우트 페이지는 블로그와 블로그의 저작자에 대한 부가 정보를 제공하는 것으로 about.qmd 파일에 의해 규정된다. about.qmd 파일의 내용을 살펴보고 조교의 도움을 받아 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히 템플릿(template) 옵션 다섯개(jolla, trestles, solana, marquee, broadside)를 살펴보고, 그 중 하나를 선택한다. 아래는 jolla(좌)와 solana(우) 템플릿의 모습이다. 원한다면 사진도 변경할 수 있다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.4 포스트 디렉토리(posts directory)\n블로그의 콘텐츠는 포스트 디렉토리 속에 포함되어 있다. 기본적으로 하나의 포스트는 하나의 폴더인데, 개별 폴더 속에는 index.qmd라는 이름의 Quarto 파일이 들어 있다. 그리고 Quarto 다큐먼트에 포함되어 있는 이미지는 images라는 서브 폴더에 저장되어 있다.\n정리하면, 블로그를 만들기 위해 만든 폴더에 생성되는 .yml 파일은 블로그의 전체적인 모습을, index.qmd는 생성될 첫 블로그 페이지를, about.qmd는 블로그 정보를 담당한다. 이렇게 만들어진 블로그에 새로운 글은 하위의 post 폴더 내에 다시 qmd 파일을 생성하고 렌더링하여 포스팅할 수 있다.\n이제 다음의 절차에 따라 새로운 포스트를 생성해 본다.\n\nposts 디렉토리 아래에 새로운 디렉토리를 생성한다. 이름은 날짜와 주제가 결합된 형태로 하면 좋다.\n새로운 디렉토리에 index.qmd 파일을 생성한다. 아래와 같이 YAML 해더를 수정하고, 실습 1에서처럼 새로운 포스트를 작성한다.\n지금까지 배운 7번의 R 실습을 복습 겸 블로그에 차근차근 포스팅하여 나만의 기술 블로그로 만들 수도 있다.\n\n2.4 블로그를 웹 상에 출판하기\n어느 정도 개인 블로그가 완성되었다면, 다음의 절차에 따라 웹에 출판한다. 여기서는 Posit에서 제공하는 무료 출판 사이트인 Quarto Pub을 활용한다.\n\nQuarto Pub에 접속하여 계정을 만든다.\nRStudio에서, 왼쪽 하단부의 Terminal 탭을 누른다.\n프롬프트에 다음과 같이 입력하고 실행한다: quarto publish quarto-pub\n\n\n\n\n\n조교의 도움을 받고, 다음을 웹사이트를 참고한다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab08: 데이터로 소통하기: Quarto"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#데이터사이언스-프로세스-소통",
    "href": "R_lec_03_2025.html#데이터사이언스-프로세스-소통",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "데이터사이언스 프로세스: 소통",
    "text": "데이터사이언스 프로세스: 소통\n\nhttps://r4ds.hadley.nz/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#패키지",
    "href": "R_lec_03_2025.html#패키지",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "패키지",
    "text": "패키지\n\nhttps://r4ds.hadley.nz/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#section",
    "href": "R_lec_03_2025.html#section",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "",
    "text": "https://quarto.org/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#정의",
    "href": "R_lec_03_2025.html#정의",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "정의",
    "text": "정의\n\n“과학적, 기술적 출판을 위한 오픈소스 시스템(an open-source scientific and technical publishing system)”\n\n오픈소스 저작 시스템\n\n다양한 형식의 저작물(노트, 연구 논문, 프레젠테이션, 대시보드, 웹사이트, 블로그, 서적 등)을 다양한 디지털 포맷(HTML, PDF, MS Word, ePub 등)으로 출판할 수 있게 해주는 도구\n적용 분야의 스케일\n\n개인 스케일: 노트, 레포트, 연구 논문, 프레젠테이션, 블로그 등의 작성 도구\n그룹 스케일: 프로젝트의 원할한 진행을 위한 협업 프레임워크\n사회 스케일: 과학 커뮤니티의 재현성(reproducibility) 고양",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#기능",
    "href": "R_lec_03_2025.html#기능",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "기능",
    "text": "기능\n\nhttps://allisonhorst.com/cetinkaya-rundel-lowndes-quarto-keynote",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#기능-1",
    "href": "R_lec_03_2025.html#기능-1",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "기능",
    "text": "기능\n\nhttps://quarto.org/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#결과물-예시",
    "href": "R_lec_03_2025.html#결과물-예시",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "결과물 예시",
    "text": "결과물 예시\n\n개인 홈페이지 및 블로그: https://sangillee.snu.ac.kr/\n웹북: https://r4ds.hadley.nz/\n프레젠테이션: https://sangillee.snu.ac.kr/2024_AIEDAP/lecture_3.html\n대시보드: https://sangillee.snu.ac.kr/dashboard_popgeo/\n논문, 포스터, 소식지 등",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#구문syntax",
    "href": "R_lec_03_2025.html#구문syntax",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "구문(syntax)",
    "text": "구문(syntax)\n\n마크다운(markdown) 언어: 팬독(pandoc)\n\n마크업(markup) 언어: 다큐먼트의 구조와 포맷을 관장하는 텍스트-엔코딩 시스템\n사용자의 편의성을 크게 향상시킨 마크업 언어\n\nQuarto 다규먼트: .qmd\n\n프로그래밍 언어 + 워드프로세서",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#렌더링rendering",
    "href": "R_lec_03_2025.html#렌더링rendering",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "렌더링(rendering)",
    "text": "렌더링(rendering)\n\nknitr 패키지: .qmd를 .md로 전환\npandoc: .md를 다양한 디지털 포맷으로 전환\n\n\nhttps://r4ds.hadley.nz/quarto",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#quarto-다큐먼트의-기본-구조",
    "href": "R_lec_03_2025.html#quarto-다큐먼트의-기본-구조",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "Quarto 다큐먼트의 기본 구조",
    "text": "Quarto 다큐먼트의 기본 구조\n\nYAML 헤더(header)\n\n일종의 메타데이터\n다큐먼트의 전반적인 사항을 관장\n\n코드 청크(code chunk)\n\n프로그래밍 언어가 들어가는 부분\nR 스크립트 파일\n\n마크다운 텍스트(markdown text)\n\n워드프로세서처럼 텍스트를 작성(도표 포함)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#section-1",
    "href": "R_lec_03_2025.html#section-1",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "",
    "text": "https://r4ds.hadley.nz/quarto",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#yaml-헤더",
    "href": "R_lec_03_2025.html#yaml-헤더",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "YAML 헤더",
    "text": "YAML 헤더\n\n\n\n\n\n\n\n키(key)\n설명\n\n\n\n\ntitle\n다큐먼트의 제목\n\n\ndate\n다큐먼트 작성 날짜\n\n\nauthor\n다큐먼트 저자 이름\n\n\nformat\n다양한 포맷 관련 사항의 지정\n\n\ntoc\n목차 삽입\n\n\nnumber-section\n섹션 제목에 자동 번호 부여 여부\n\n\nexecute: echo\n소스 코드의 포함 여부를 글로벌하게 설정, 보통 true\n\n\nexecute: warning\n경고 메시지를 산출물에 나타나게 할지를 글로벌하게 설정, 보통 false\n\n\neditor\n비주얼 에디터와 소스 에디터 중 선택, 보통 visual",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#코드-청크",
    "href": "R_lec_03_2025.html#코드-청크",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "코드 청크",
    "text": "코드 청크\n\n\n\n\n\n\n\n\n\n\n\n\nOption\nRun code\nShow code\nOutput\nPlots\nMessages\nWarnings\n\n\n\n\neval: false\nX\n\nX\nX\nX\nX\n\n\ninclude: false\n\nX\nX\nX\nX\nX\n\n\necho: false\n\nX\n\n\n\n\n\n\nresults: hide\n\n\nX\n\n\n\n\n\nfig-show: hide\n\n\n\nX\n\n\n\n\nmessage: false\n\n\n\n\nX\n\n\n\nwarning: false\n\n\n\n\n\nX",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#마크다운-텍스트",
    "href": "R_lec_03_2025.html#마크다운-텍스트",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "마크다운 텍스트",
    "text": "마크다운 텍스트\n\n소스 에디터(source editor) vs. 비주얼 에디터(visual editor)\n마크다운 언어의 사용자 편이성을 한 번 더 강화한 것",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#zotero",
    "href": "R_lec_03_2025.html#zotero",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "Zotero",
    "text": "Zotero\n\nhttps://quarto.org/docs/visual-editor/technical.html",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#웹-발행publishing과-호스팅hosting-서비스",
    "href": "R_lec_03_2025.html#웹-발행publishing과-호스팅hosting-서비스",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "웹 발행(publishing)과 호스팅(hosting) 서비스",
    "text": "웹 발행(publishing)과 호스팅(hosting) 서비스\n\nQuarto Pub(https://quartopub.com/)\nGitHub Pages(https://pages.github.com/)\nNetlify(https://www.netlify.com/)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#quarto-pub",
    "href": "R_lec_03_2025.html#quarto-pub",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "Quarto Pub",
    "text": "Quarto Pub\n\nhttps://quarto.org/docs/publishing/quarto-pub.html",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#데이터-대시보드",
    "href": "R_lec_03_2025.html#데이터-대시보드",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "데이터 대시보드",
    "text": "데이터 대시보드\n\n레이아웃 요소: 대시보드의 기본 구조\n\n카드(행과 열)\n페이지, 내비게이션 바, 사이드바, 툴바, 탭셋\n\n내용 요소: 카드를 채우는 내용의 유형\n\n텍스트, 표, 그래프, 동영상, 밸류박스, 지도, 챗봇 등\n\n작동 요소: 상호작용성의 형식과 정도",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#예시",
    "href": "R_lec_03_2025.html#예시",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "예시",
    "text": "예시\nhttps://sangillee.quarto.pub/my-first-dashboard/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#레이아웃-요소-1-카드",
    "href": "R_lec_03_2025.html#레이아웃-요소-1-카드",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "레이아웃 요소 1: 카드",
    "text": "레이아웃 요소 1: 카드\n\nCodeResult\n\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1 \n\n### Column {width=60%}\n\nCard 2-2",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#레이아웃-요소-2-탭셋",
    "href": "R_lec_03_2025.html#레이아웃-요소-2-탭셋",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "레이아웃 요소 2: 탭셋",
    "text": "레이아웃 요소 2: 탭셋\n\nCodeResult\n\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30% .tabset}\n\n### Column\n\nCard 2-1 {width=50%}\n\n### Column\n\nCard 2-2 {width=50%}",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#레이아웃-요소-3-페이지",
    "href": "R_lec_03_2025.html#레이아웃-요소-3-페이지",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "레이아웃 요소 3: 페이지",
    "text": "레이아웃 요소 3: 페이지\n\nCodeResult\n\n\n# Page A\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1\n\n### Column {width=60%}\n\nCard 2-2\n\n# Page B\n\nCard 3",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#레이아웃-요소-4-내비게이션-바",
    "href": "R_lec_03_2025.html#레이아웃-요소-4-내비게이션-바",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "레이아웃 요소 4: 내비게이션 바",
    "text": "레이아웃 요소 4: 내비게이션 바\n\n\ntitle\nauthor\nformat: dashboard\n\nlogo\nnav-buttons\nscrolling: true\n\ntheme: 25 bootswatch themes(https://quarto.org/docs/dashboards/theming.html)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#레이아웃-요소-5-사이드바",
    "href": "R_lec_03_2025.html#레이아웃-요소-5-사이드바",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "레이아웃 요소 5: 사이드바",
    "text": "레이아웃 요소 5: 사이드바",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#내용-요소-1-그래프",
    "href": "R_lec_03_2025.html#내용-요소-1-그래프",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "내용 요소 1: 그래프",
    "text": "내용 요소 1: 그래프\n\n그래프 카드: 그래프 하나를 만들어내는 코드 청크\nggplot2 패키지, plotly 패키지\n\n#| title: \"Histogram of GDP per capita\"\nlibrary(tidyverse)\nlibrary(gapminder)\ngapminder |&gt; \n  filter(year == 2007) |&gt;\n  ggplot(aes(x = gdpPercap)) +\n  geom_histogram()",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#내용-요소-2-테이블",
    "href": "R_lec_03_2025.html#내용-요소-2-테이블",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "내용 요소 2: 테이블",
    "text": "내용 요소 2: 테이블\n\n테이블 카드: 테이블 하나를 만들어내는 코드 청크\nDT 패키지, knitr 패키지\n\n#| title: Lookup Table\nlibrary(DT)\ndatatable(gapminder, filter = \"top\", \n          options = list(\n            pageLength = 5, autoWidth = TRUE\n          ))",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#내용-요소-3-지도",
    "href": "R_lec_03_2025.html#내용-요소-3-지도",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "내용 요소 3: 지도",
    "text": "내용 요소 3: 지도\n\n지도 카드: 지도 하나를 만들어내는 코드 청크\nggplot2 패키지, leaflet 패키지\n\n#| title: A Reference Map \nlibrary(leaflet) \nleaflet() |&gt;  \n  addTiles()",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#내용-요소-4-텍스트",
    "href": "R_lec_03_2025.html#내용-요소-4-텍스트",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "내용 요소 4: 텍스트",
    "text": "내용 요소 4: 텍스트\n\n텍스트 카드: 텍스트 박스 하나를 만들어내는 div\n{.card} 탭과 title 속성\n\n::: {.card title=\"Text\"}\nThis is my first dashboard.\n:::",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#내용-요소-5-밸류박스valueboxe",
    "href": "R_lec_03_2025.html#내용-요소-5-밸류박스valueboxe",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "내용 요소 5: 밸류박스(valueboxe)",
    "text": "내용 요소 5: 밸류박스(valueboxe)\n\n밸류박스 카드: 밸류박스 하나를 만들어내는 코드 청크\n아이콘: bootstrap icon(https://icons.getbootstrap.com/)\n컬러: 8개(https://quarto.org/docs/dashboards/data-display.html)\n\n#| content: valuebox\n#| title: \"Number of Countries\"\nn_countries &lt;- gapminder |&gt; distinct(country) |&gt; nrow()\nlist(\n  icon = \"asterisk\",\n  color = \"primary\",\n  value = n_countries\n)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_03_2025.html#웹-발행",
    "href": "R_lec_03_2025.html#웹-발행",
    "title": "R Lecture 3\n소통하기: Quarto",
    "section": "웹 발행",
    "text": "웹 발행\n\nQuarto Pub(https://quartopub.com/)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 3]{style=\"color:coral;font-size:0.6em\"}\n| [소통하기: Quarto]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "lab_09.html",
    "href": "lab_09.html",
    "title": "Lab09: 데이터로 소통하기: 대시보드 만들기",
    "section": "",
    "text": "이번 실습은 Quarto를 이용하여 데이터 대시보드(dashboard)를 만드는 것이다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab09: 데이터로 소통하기: 대시보드 만들기"
    ]
  },
  {
    "objectID": "lab_09.html#실습-개요",
    "href": "lab_09.html#실습-개요",
    "title": "Lab09: 데이터로 소통하기: 대시보드 만들기",
    "section": "",
    "text": "이번 실습은 Quarto를 이용하여 데이터 대시보드(dashboard)를 만드는 것이다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab09: 데이터로 소통하기: 대시보드 만들기"
    ]
  },
  {
    "objectID": "lab_09.html#레이아웃-설정법",
    "href": "lab_09.html#레이아웃-설정법",
    "title": "Lab09: 데이터로 소통하기: 대시보드 만들기",
    "section": "\n1 레이아웃 설정법",
    "text": "1 레이아웃 설정법\n\n1.1 페이지의 설정\n페이지(page)는 최상위 레이아웃 요소이다. 기본 원칙은 다음과 같다.\n\n헤더 1(header 1) 레벨이 페이지의 구분을 결정한다.\nQuarto에서는 페이지가 내비게이션바에 나타난다.\n\n# Page A\n\n# Page B\n\n1.2 사이드바의 설정\n사이드바(sidebar)는 {.sidebar} 태그를 통해 만들 수 있는데, 헤더 1(header 1) 레벨이므로 특정한 페이지에 종속되지 않는다. 사이드바는 주로 사용자의 투입을 받을 때 사용되기 때문에 동적인 대시보드에 주로 사용된다. 정적인 대시보드의 경우에는 텍스트를 통한 특정 정보의 제공에 사용될 수 있다.\n# {.sidebar}\nSidebar content\n\n1.3 행과 열의 설정\n행(row)과 열(column)은 가장 기본이 되는 레이아웃 요소이다. 기본 원칙은 다음과 같다.\n\n헤더 2(header 2) 레벨이 행과 열의 구분을 일차적으로 결정한다.\n헤더 3(header 3) 레벨이 하위 행과 열의 구분을 이차적으로 결정한다.\nRow와 Column 옆에 {height}, {width} 태그를 통해 가로 세로의 상대적인 크기를 정한다.\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1\n\n### Column {width=60%}\n\nCard 2-2\n\n# Page B\n\nCard 3\n\n1.4 탭셋의 설정\nRow나 Column에 {.tabset}을 표기하면, 하위의 행과 열이 탭으로 구분된다. 이렇게 하면 카드의 크기가 지나치게 줄어드는 단점을 해소할 수 있다.\n\n1.5 기본 구조 살펴보기\n위를 바탕으로 대시보드의 골격을 작성해본다.\n---\ntitle: \"dashboard\"\nformat: dashboard\ntheme: default\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n# {.sidebar}\nSidebar content\n\n# Page A\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1\n\n### Column {width=60%}\n\nCard 2-2 {.tabset}\n\n#### Column\n\nCard 2-1 {width=50%}\n\n#### Column\n\nCard 2-2 {width=50%}\n\n# Page B\n\nCard 3\n위와 같이 설정하면 다음과 같은 결과를 얻을 수 있다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab09: 데이터로 소통하기: 대시보드 만들기"
    ]
  },
  {
    "objectID": "lab_09.html#카드와-내용-요소",
    "href": "lab_09.html#카드와-내용-요소",
    "title": "Lab09: 데이터로 소통하기: 대시보드 만들기",
    "section": "\n2 카드와 내용 요소",
    "text": "2 카드와 내용 요소\n카드(card)란 특정한 내용 요소(텍스트, 벨류박스, 테이블, 그래프, 지도 등)를 포함하고 있는, 대시보드의 가장 기본적인 단위이다. 다음의 두 가지 사항이 중요하다.\n\n카드의 제목이 중요하다. 완성된 대시보드 상에 등장하기 때문에 사용자가 이해하기 쉬운 제목이 부여되어야 한다.\n내용 요소에 따라 카드를 작성하는 방법이 조금 다르다.\n\n내용 요소 제작의 세세한 사항은 아래의 “예시 대시보드 만들기”에서 확인한다.\n\n2.1 그래프\nQuarto는 그래프 하나를 만들어내는 코드 청크를 하나의 카드로 인식한다. 그래프 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. ggplot2와 같은 정적인 플롯 도구 뿐만 아니라 plotly와 같은 반응형 플롯 도구를 사용하여 그래프 카드를 생성한다.\n\n2.2 테이블\nQuarto는 테이블 하나를 디스플레이하는 코드 청크를 하나의 카드로 인식한다. 테이블 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. knitr 패키지의 kable() 함수, DT 패키지의 datatable() 함수 등을 이용해 테이블 카드를 생성한다.\n\n2.3 지도\nQuarto는 지도 하나를 디스플레이하는 코드 청크를 하나의 카드로 인식한다. 지도 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. ggplot2와 같은 정적인 지도 제작 도구 뿐만 아니라 leaflet과 같은 반응형 지도 제작 도구를 사용하여 지도 카드를 생성한다.\n\n2.4 텍스트\n일종의 텍스트 박스도 하나의 카드로 간주된다. 그래프, 테이블, 지도가 하나의 코드 청크가 하나의 카드로 인식되는데 반해 텍스트 카드는 다른 형식을 취한다. ::: {.card} div를 사용해야 하며 괄호 내부에 title= 옵션을 사용해 제목을 지정해야 한다. 가령 {.card title=\"Text\"}와 같이 표기해야 한다.\n\n2.5 밸류박스\n요약적 수치를 큰 박스 속에 나타내는 것을 밸류박스(value box)라고 하는데, 코드 청크로 표현하지만 형식은 조금 다르다. #| content: valuebox라는 옵션이 반드시 포함되야 하며, 제목을 지정하기 위해 #| title: 옵션도 필요하다. 또한 리스트를 이용해 아이콘(icon), 컬러(color), 수치(value)를 지정해야 한다.\n아이콘은 부트스트랩 아이콘(bootstrap icon)이 사용된다. 적절한 아이콘을 찾고 그 이름을 #| title: 옵션을 통해 설정하는 것이 중요하다.\n모든 컬러가 다 사용가능한 것은 아니다. 아래의 표를 참조하여 컬러를 설정해야 한다.\n\n\nColor Alias\nDefault Theme Color(s)\n\n\n\nprimary\nBlue\n\n\nsecondary\nGray\n\n\nsuccess\nGreen\n\n\ninfo\nBright Blue\n\n\nwarning\nYellow/Orange\n\n\ndanger\nRed\n\n\nlight\nLight Gray\n\n\ndark\nBlack",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab09: 데이터로 소통하기: 대시보드 만들기"
    ]
  },
  {
    "objectID": "lab_09.html#예시-대시보드-만들기",
    "href": "lab_09.html#예시-대시보드-만들기",
    "title": "Lab09: 데이터로 소통하기: 대시보드 만들기",
    "section": "\n3 예시 대시보드 만들기",
    "text": "3 예시 대시보드 만들기\n위의 사항을 바탕으로 예시 대시보드(https://sechangkim.quarto.pub/my-first-dashboard/)에 접속하여 구성을 살펴본다. 다음의 사항에 주목한다.\n\n내비게이션바에 서울대학교 로고가 있고, 오른쪽 맨 끝애 홈페이지 및 이메일 아이콘이 위치해 있다.\n대시보드가 네 개의 페이지(Intro, Graphs, Tables, Maps)로 나뉘어져 있고, 각 페이지마다 행, 열, 탭셋과 같은 레이아웃 요소들이 배치되어 있다.\n\n어떤 식으로 제작할 수 있을지 생각해 본다. 새로운 프로젝트를 생성하고 Quarto 다큐먼트를 생성한다. 아래는 해당 대시보드를 만들기 위해 사용된 코드이다. 참고하여 자신만의 대시보드를 만들어 본다. 단, 로고 및 홈페이지 주소는 반드시 자신의 것으로 수정해야 한다.\n\n3.1 YAML 해더\n특히, nav-buttons: 옵션의 지정 형식에 주의한다. scrolling 옵션과 다양한 theme: 옵션을 시험해 본다.\n---\ntitle: \"My First Dashboard\"\nauthor: Your name\nformat: \n  dashboard:\n    embed-resources: true\n    logo: img/snu_ui_download.png\n    nav-buttons: \n      - icon: house-door-fill\n        href: Your Blog Address\n        aria-label: GitHub\n      - icon: envelope\n        href: mailto:vs5345@snu.ac.kr\n        aria-label: Mail\ntheme: default\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n3.2 Intro 페이지\nIntro라는 이름의 페이지를 설정한다.\n# Intro\n\n3.2.1 첫번째 행: Text 카드\n행을 설정하고 행의 상대적인 높이(10%)를 지정한다.\n## Row {height=\"12%\"}\n텍스트 카드를 생성한다. 텍스트 카드를 생성하기 위해 {.card} 태그가 사용되어야 하며, 텍스트 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다.\n::: {.card title=\"Text\"}\nThis is my first dashboard.\n:::\n\n3.2.2 두번째 행의 탭셋: Histogram of GDP per capita & Table of Mean Values\n행을 설정하고 행의 상대적인 높이(70%)를 지정한다. 탭셋을 생성하기 위해 {.tabset} 태그가 사용되어야 함에 주의한다.\n## Row {.tabset height=\"70%\"}\n그래프 카드를 생성하기 위해 ggplot2 패키지를 활용한다. 그래프 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다. 두 개의 그래프를 지난 실습에서 배웠던 patchwork 함수로 가로 배치하였다. 이때 산출될 플롯의 크기는 fig-width와 fig-height로 조정할 수 있다.\n#| title: \"Histogram of GDP per capita\"\n#| fig-width: 20\n#| fig-height: 6\nlibrary(tidyverse)\nlibrary(gapminder)\nlibrary(patchwork)\n\np1 &lt;- gapminder |&gt; \n  filter(year==2007) |&gt; \n  ggplot(aes(x=gdpPercap))+\n  geom_histogram()\n\np2 &lt;- gapminder |&gt; \n  filter(year==2007) |&gt; \n  ggplot(aes(x=gdpPercap, y=lifeExp))+\n  geom_point()\n\np1|p2\n테이블 카드를 생성하기 위해 knitr 패키지의 kable() 함수를 활용한다. 테이블 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다.\n#| title: \"Table of Mean Values\"\nlibrary(knitr)\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  summarize(\n    GDP_percap = mean(gdpPercap),\n    Life_Exp = mean(lifeExp),\n    Population = mean(pop),\n    .by = continent\n  ) |&gt; \n  kable()\n\n3.2.3 세번째 행의 3개의 밸류박스\n행을 설정하고 행의 상대적인 높이(18%)를 지정한다.\n## Row {height=\"18%\"}\n첫번째 밸류박스를 생성한다. #| content: valuebox 옵션과 #| title: 옵션이 사용됨에 주의한다.\n#| content: valuebox\n#| title: \"Number of Countries\"\nn_countries &lt;- gapminder |&gt; distinct(country) |&gt; nrow()\nlist(\n  icon = \"asterisk\",\n  color = \"primary\",\n  value = n_countries\n)\n두번째 밸류박스를 생성한다.\n#| content: valuebox\n#| title: \"First Year\"\nfirst_year &lt;- gapminder |&gt; distinct(year) |&gt; pull() |&gt; first()\nlist(\n  icon = \"airplane\",\n  color = \"secondary\",\n  value = first_year\n세번째 밸류박스를 생성한다.\n#| content: valuebox\n#| title: \"Last Year\"\nlast_year &lt;- gapminder |&gt; distinct(year) |&gt; pull() |&gt; last()\nlist(\n  icon = \"bank\",\n  color = \"success\",\n  value = last_year\n)\n더 다양한 아이콘이 궁금하다면 이 웹사이트를 참고할 것.\n\n3.3 Graphs 페이지\nGraphs라는 이름의 페이지를 설정한다.\n# Graphs\n\n3.3.1 첫번째 행의 그래프 카드: GDP and Life Expectancy\n행을 설정한다.\n## Row\nggplot2 패키지를 활용하여 그래프 카드를 생성한다.\n#| title: GDP and Life Expectancy\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(aes(x = log10(gdpPercap), y = lifeExp)) +\n  geom_point(aes(color = continent), show.legend = FALSE) +\n  geom_smooth() + \n  facet_wrap(~continent, ncol = 5)\n\n3.3.2 두번째 행의 그래프 카드: Population & Life Expectancy\n첫번째 그래프(Population)를 위한 열을 설정한다.\n### Column\n그래프 카드를 생성한다.\n#| title: Population\ngapminder |&gt; \n  summarize(\n    sum_pop = sum(pop),\n    .by = c(year, continent)\n  ) |&gt; \n  ggplot(aes(x = year, y = sum_pop)) +\n  geom_area(aes(fill = continent)) +\n  labs(x = \"Year\", y = \"Population\", fill = \"Continents\")\n두번째 그래프(Life Expectancy)를 위한 열을 설정한다.\n### Column\n그래프 카드를 생성한다.\n#| title: Life Expectancy\ngapminder |&gt; \n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line(aes(color = continent, group = country)) +\n  labs(x = \"Year\", y = \"Life Expectancy\", color = \"Continents\")\n\n3.4 Tables 페이지\nTables라는 이름의 페이지를 설정한다.\n# Tables\n단일 행을 설정한다.\n## Row\nDT 패키지를 활용하여 테이블 카드를 생성한다.\n#| title: Lookup Table\nlibrary(DT)\ndatatable(gapminder, filter = \"top\", \n          options = list(\n            pageLength = 5, autoWidth = TRUE\n          ))\n\n\n\n\n\n\n노트DT() 함수\n\n\n\n\n\n다음 주 강의에 조금 더 자세히 배우겠지만, DT는 다양한 표 형식을 제공한다. 아래의 코드는 필터링 기능과 수정 기능, 다운로드 버튼을 생성해준다.\n\nlibrary(DT)\nlibrary(gapminder)\ndatatable(gapminder,\n          filter = \"top\",\n          editable=TRUE,\n          extensions = \"Buttons\",\n          options = list(\n            pageLength = 15,\n            autoWidth = TRUE,\n            dom = \"Bfrtip\",\n            buttons=c(\"copy\", \"excel\", \"pdf\", \"print\")\n          ))\n\n\n\n\n\n\n\n\n\n3.5 Maps 페이지\nMaps라는 이름의 페이지를 설정한다.\n# Maps\n단일 행을 설정한다.\n## Row\nleaflet 패키지를 활용하여 지도 카드를 생성한다.\n#| title: A Reference Map \nlibrary(leaflet) \nleaflet() |&gt;  \n  addTiles()\n\n\n\n\n\n\n노트leaflet 패키지\n\n\n\n\n\nleaflet() 함수는 다양한 지도와 환경설정을 제공한다. 초점을 경도 0도, 위도 20도에 두고 확대 정도를 3단계로 두고 싶다면 아래와 같은 코드를 사용할 수 있다. 또한 배경 지도도 변경할 수 있는데, 이 때는 addProviderTiles() 함수를 활용할 수 있다.\n\nlibrary(leaflet) \nleaflet() |&gt;  \n  setView(lng=0, lat=20, zoom=3) |&gt; \n  addProviderTiles('CartoDB.Positron')\n\n\n\n\n\n\n\n\n\n3.6 대시보드 웹 상에 출판하기\n블로그와 마찬가지로 다음의 절차에 따라 완성된 대시보드를 웹 상에 출판한다. 여기서는 Posit에서 제공하는 무료 출판 사이트인 Quarto Pub을 활용한다.\n\nQuarto Pub에 접속하여 계정을 만든다.\nRStudio에서, 왼쪽 하단부의 Terminal 탭을 누른다.\n프롬프트에 다음과 같이 입력하고 실행한다: quarto publish quarto-pub\n나머지 사항에 대해서는 조교의 도움을 받는다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab09: 데이터로 소통하기: 대시보드 만들기"
    ]
  },
  {
    "objectID": "lab_02.html",
    "href": "lab_02.html",
    "title": "Lab02: R과 데이터사이언스",
    "section": "",
    "text": "R의 패키지에 대해 이해할 수 있다.\n\n데이터사이언스의 과정을 개괄적으로 이해할 수 있다.\n\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기\n\n\n파이프 연산자의 사용법에 대해 이해할 수 있다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#실습의-목표",
    "href": "lab_02.html#실습의-목표",
    "title": "Lab02: R과 데이터사이언스",
    "section": "",
    "text": "R의 패키지에 대해 이해할 수 있다.\n\n데이터사이언스의 과정을 개괄적으로 이해할 수 있다.\n\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기\n\n\n파이프 연산자의 사용법에 대해 이해할 수 있다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#패키지",
    "href": "lab_02.html#패키지",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n1 패키지",
    "text": "1 패키지\n패키지를 사용하기 우선 패키지가 사용자의 디바이스에 물리적으로 인스톨되어 있어야 하고, R 세션에서 패키지를 불러와야 한다. 패키지를 인스톨하는 방법은 두 가지 이다. 스크립트 내에서 패키지를 반복해서 인스톨하는 것은 합리적이지 않기 때문에 전자의 관행을 추천한다.\n\nOutput 창의 Packages 탭 선택: Install 아이콘 클릭하고 패키지 이름 입력\n스크립트 내에서 인스톨하기: install.packages(\"패키지명\")\n\n쌍따옴표 속에 패키지 이름을 타이핑해야 한다. 한번 인스톨이 되면 업데이트하지 않는 한 새롭게 패키지를 인스톨할 필요가 없다. 인스톨된 패키지를 사용하려면 스크립트 내에서 다음과 같이 타이핑하고 실행한다.\n\nlibrary(패키지명)\n\n괄호 속에 패키지명을 기입해야 한다.\n\n\n\n\n\n\n중요\n\n\n\ninstall.packages()함수에서는 반드시 패키지명을 쌍따옴표로 싸야하지만, library()함수에서는 그렇지 않다. 불러온 패키지는 R 세션이 유지되는 동안 내내 사용할 수 있지만, R 세션을 끝내고 다시 시작하면 다시 library()함수를 이용해 다시 불러와야 한다. 그래서 R 스크립트 파일의 시작 부분에는 패키지를 불러오는 코드를 위치시키고, 다시 스크립트 파일을 열 때마다 그 부분을 재실행하는 것이 좋은 습관이다.\n\n\ntidyverse 패키지를 사용하는 것의 장점은 이 패키지만 불러오면 구성 패키지까지 한꺼번에 사용할 수 있게 된다는 점이다. 스크립트 내에서 다음과 같은 코드를 실행한다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#시각화하기",
    "href": "lab_02.html#시각화하기",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n2 시각화하기",
    "text": "2 시각화하기\n\n2.1 데이터 살펴보기\n이 실습을 위해 남극 파머군도(Palmer Archipelago)에 서식하는 펭귄 성체의 신체 계측 데이터를 사용한다. 이 데이터는 palmerpenguins라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다.\n\nlibrary(palmerpenguins)\n\n이제 이 패키지에 포함되어 있는 penguins라는 이름의 데이터를 불러온다.\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n데이터를 자세히 살펴보면 몇 가지를 알 수 있다.\n\n티블(tibble)이라는 형식의 데이터 프레임이다. 티블은 tidyverse의 공식 데이터 프레임 포맷이다.\n관측개체는 344개, 변수는 8개이다.\nspecies, island, sex 변수의 유형은 팩트형(fctr)이고, bill_length_mm, bill_depth_mm은 실수형(dbl)이고, 나머지는 정수형(int)이다.\n\n변수가 많아지면 전체 데이터를 조망하기 어렵기 때문에, 최초의 tidyverse 함수인 glimpse()를 사용하여 데이터의 행과 열을 바꾸어 보자.\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\n\n\n\n\n힌트데이터 내 속성들에 대한 정보가 궁금할 때\n\n\n\n\n\npenguins 데이터 내 속성들에 대한 설명을 보고싶다면 help(penguins) 또는 ?penguins를 입력한 뒤 실행한다.\n\n\n\n\n2.2 그래프 만들기\n이 penguins 데이터와 ggplot2() 패키지를 이용하여 “펭귄의 날개 길이와 몸무게의 관계”를 표현하는 그래프를 작성해 보자. ggplot2()의 더 많은 사용법에 대해서는 이후의 실습에서 매우 자세히 다룰 것이기 때문에 오늘은 간단한 제작 과정만을 따라가 보면서 데이터 시각화에 흥미를 가질 수 있도록 해보자.\n\n2.2.1 플롯 객체의 지정\nggplot()이라는 함수를 통해 플롯 제작을 개시하는 단계이며, 어떤 데이터를 사용할지를 지정한다.\n\nggplot(data = penguins) # 플롯 제작에 penguins 데이터를 사용\n\n\n\n\n\n\n\n\n2.2.2 플롯의 심미성 지정\n데이터가 어떤 시각적 속성으로 표현될 것인가를 지정한다. 여기서는 간단히 어떤 변수들이 x-축과 y-축에 나타나는지만 지정한다. mapping = aes() 아규먼트가 핵심이다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n힌트코드의 가독성을 위한 Tip\n\n\n\nR에서 코드를 작성하다 보면 한 덩어리의 코드가 매우 길어지는 일이 빈번하게 발생한다. 코드를 정리하지 않고 계속 작성할 경우 작성자 본인이 봐도 무엇을 한 것인지 모르는 일이 발생하기 때문에 줄바꿈을 통해 코드를 간결하게 정리하는 것이 좋다. 특히 R이 익숙하지 않은 초보자의 경우 각 줄마다 본인이 무엇을 했는지 # 각주를 통해 설명을 달아 놓으면 R 문법에 익숙해지는데 도움이 된다.\n\n\n\n2.2.3 플롯의 기하 속성 지정\n데이터가 어떤 기하학적 속성으로 표현될 것인가를 지정한다. geom 아규먼트가 핵심인데, geom_point()는 데이터를 포인트라고 하는 기하학적 속성으로 표현한다는 것을 지정한 것으로 결국 산포도(scatterplot)을 산출하게 된다.\n\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n) +\n  geom_point() # 데이터를 산포도로 표현\n\n\n\n\n\n\n\n\n2.2.4 심미성의 첨가\n이러한 관련성이 펭귄의 종족에 따라 다르게 나타나는지를 탐색하기 위해 color 라는 심미성을 species라는 변수에 적용한다.\n\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species) # x축에 날개 길이, y축에 몸무게를 표시, 종별로 색상을 지정\n) +\n  geom_point() # 데이터를 산포도로 표현\n\n\n\n\n\n\n\n\n2.2.5 기하 레이어의 첨가\n두 변수의 관련성을 보여주는 선형 기하를 첨가한다. 여기서는 geom_smooth()를 이용하여 OLS 회귀선을 첨가한다.\n\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n) +\n  geom_point(mapping = aes(color = species)) + # 데이터를 산포도로 표현, 종별로 색상을 지정\n  geom_smooth(method = \"lm\") # OLS 회귀선을 추가\n\n\n\n\n\n\n\n\n\n\n\n\n\n힌트OLS 회귀선이란?\n\n\n\n\n\nOLS(Ordinary Least Square, 최소제곱법) 회귀선이란 관측값과 회귀선의 차이인 잔차의 제곱을 최소화하는 직선을 의미한다. 데이터들의 추세선 정도로 이해하면 된다. 선 주변의 음영은 신뢰 구간을 나타내는데, 이를 제거하고 싶으면 se = FALSE를 추가하면 된다.\n\n\n\n\n2.2.6 라벨링 등 마무리 작업\n\nggplot(\n  data = penguins, # 플롯 제작에 penguins 데이터를 사용\n  mapping = aes(x = flipper_length_mm, y = body_mass_g) # x축에 날개 길이, y축에 몸무게를 표시\n) +\n  geom_point(mapping = aes(color = species)) + # 데이터를 산포도로 표현, 종별로 색상을 지정\n  geom_smooth(method = \"lm\") + # OLS 회귀선을 추가\n  labs(\n    title = \"Body mass and flipper length\", # 플롯의 제목을 지정\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\", # 플롯의 부제목을 지정\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\", # 축의 이름을 지정\n    color = \"Species\" # 범례의 제목을 설정\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n노트\n\n\n\n데이터 시각화에 대한 보다 자세한 내용은 5주차 실습에서 다룬다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#변형하기",
    "href": "lab_02.html#변형하기",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n3 변형하기",
    "text": "3 변형하기\n변형하기와 관련된 함수들은 대부분 dplyr 패키지에 포함되어 있다.\n\n3.1 데이터 살펴보기\n이 실습을 위해 미국 교통통계국(U.S. Bureau of Transportation)이 제공하는 데이터를 사용하는데, 이것은 2013년 한 해 동안 미국 뉴욕시를 출발한 336,776대의 항공기에 대한 정보를 담고 있다. 이 데이터는 nycflights13 이라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다. 그리고 나서 패키지에 포함되어 있는 flights라는 이름의 데이터를 불러온다.\n\nlibrary(nycflights13)\nglimpse(flights)\n\nRows: 336,776\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n\n\n\n\n\n\n힌트\n\n\n\nflights 데이터 내 속성들에 대한 설명을 보고싶다면 help(flights) 또는 ?flights를 입력한 뒤 실행한다.\n\n\n\n3.2 주요 함수\n여기서는 가장 널리 사용되는 6개 함수에 대해서만 개략적으로 다룬다. 그 6개 함수는 select(), filter(), arrange(), mutate(), group_by(), summerize()이다.\n\n3.2.1 select() 함수\n열(변수) 중 일부를 솎아낸다. 즉, 변수의 개수를 줄인다.\n\nselect(flights, year, month, day) # 지정한 열(변수)만 추출\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\n\n3.2.2 filter() 함수\n특정 열(변수)에 의거해 조건을 만족하는 행을 솎아낸다. 즉 관측개체의 갯수를 줄인다.\n\nfilter(flights, month == 1 & day == 1) # 지정한 행(관측개체)만 추출\n\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.3 arrange() 함수\n특정 열(변수)에 의거해 행의 순서를 바꾼다. 내림차순으로 정렬하고 싶다면 desc(dep_time)을 넣으면 된다.\n\narrange(flights, dep_time) # dep_time 오름차순으로 행 정렬\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1    13        1           2249        72      108           2357\n 2  2013     1    31        1           2100       181      124           2225\n 3  2013    11    13        1           2359         2      442            440\n 4  2013    12    16        1           2359         2      447            437\n 5  2013    12    20        1           2359         2      430            440\n 6  2013    12    26        1           2359         2      437            440\n 7  2013    12    30        1           2359         2      441            437\n 8  2013     2    11        1           2100       181      111           2225\n 9  2013     2    24        1           2245        76      121           2354\n10  2013     3     8        1           2355         6      431            440\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.4 mutate() 함수\n기존의 열(변수)을 변형하여 새로운 열(변수)을 생성한다. 아래에 gain , speed  변수가 새로 생긴 것을 확인할 수 있다.\n\nmutate(flights,\n    gain = dep_delay - arr_delay, # gain이라는 새로운 열(변수) 생성\n    speed = distance / air_time * 60 # speed라는 새로운 열(변수) 생성\n  )\n\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, gain &lt;dbl&gt;, speed &lt;dbl&gt;\n\n\n\n3.2.5 group_by() 함수\n열(변수)(범주형 변수, categorical variables)에 의거해 전체 행을 그룹으로 분할한다. Groups: month[12]를 통해 월별로 행이 분할되었음을 알 수 있다.\n\ngroup_by(flights, month) # 전체 행을 월별로 분할\n\n# A tibble: 336,776 × 19\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.6 summerize() 함수\n열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장한다.\n\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE)) # dep_delay의 평균을 delay라는 변수에 저장\n\n# A tibble: 1 × 1\n  delay\n  &lt;dbl&gt;\n1  12.6\n\n\n\n\n\n\n\n\n힌트결측값\n\n\n\n\n\nR에서 데이터 셋에 결측값이 포함되어 있을 경우 통계량을 계산하면 NA라는 결과를 얻게 된다. 따라서 데이터셋에 결측값이 있는지 확인한 뒤 이를 분석에서 제외하거나 다른 값으로 대체해야 한다. 여기에서는 결측값을 분석에서 제외하는 방법만 다룬다.\n\n# 결측값을 포함하여 통계량을 계산했을 때\nsummarize(flights, delay = mean(dep_delay))\n\n# A tibble: 1 × 1\n  delay\n  &lt;dbl&gt;\n1    NA\n\n\n\n# dep_delay변수에 결측값이 몇개 있는지 확인: is.na\nsum(is.na(flights$dep_delay))\n\n[1] 8255\n\n\n\n# 통계량 계산에서 결측값을 제외: na.rm = TRUE\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  delay\n  &lt;dbl&gt;\n1  12.6\n\n\n\n\n\n위의 group_by() 함수와 결합하면, 그룹별로 열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장할 수 있다.\n\nby_day &lt;- group_by(flights, year, month, day) # 전체 행을 연, 월, 일로 분할하여 새로운 변수에 할당\nsummarize(by_day, delay = mean(dep_delay, na.rm = TRUE)) # 일별 delay 계산\n\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day delay\n   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n 1  2013     1     1 11.5 \n 2  2013     1     2 13.9 \n 3  2013     1     3 11.0 \n 4  2013     1     4  8.95\n 5  2013     1     5  5.73\n 6  2013     1     6  7.15\n 7  2013     1     7  5.42\n 8  2013     1     8  2.55\n 9  2013     1     9  2.28\n10  2013     1    10  2.84\n# ℹ 355 more rows\n\n\n\n\n\n\n\n\n노트\n\n\n\n데이터 변형하기에 대한 보다 자세한 내용은 4주차 실습에서 다룬다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#정리하기",
    "href": "lab_02.html#정리하기",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n4 정리하기",
    "text": "4 정리하기\n정리하기와 관련된 함수들은 대부분 tidyr 패키지에 포함되어 있다. 많은 함수가 있지만 가장 중요한 두 개의 함수에만 집중한다.\n\n4.1 데이터 살펴보기\n이 실습에서는 tidyverse에 포함되어 있는 매우 단순한 데이터를 사용한다.\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n\n\n\n4.2 주요 함수\n\n4.2.1 pivot_longer() 함수\ntable4a에서 1999과 2000은 변수명일 수 없다. year라는 변수의 속성이어야 한다.\n\npivot_longer(\n  table4a, \n  cols = c(`1999`, `2000`), # 바꾸고싶은 변수 지정 \n  names_to = \"year\", # 원래 데이터의 변수명들이 들어갈 새로운 변수명 지정\n  values_to = \"cases\" # 원래 데이터의 값들이 들어갈 새로운 변수명 지정\n)\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\n\n4.2.2 pivot_wider() 함수\ntable2에서 type 변수는 두 개의 변수명을 포함하고 있다. 즉, cases와 population은 속성값이라기 보다는 변수명이다.\n\npivot_wider(\n  table2, \n  names_from = \"type\", # 원래 데이터의 type 값들을 변수로 변환\n  values_from = \"count\" # 원래 데이터의 count 값들을 변수의 값으로 변환\n)\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\n\n\n\n\n\n\n\n노트\n\n\n\n데이터 정리하기에 대한 보다 자세한 내용은 3주차 실습에서 다룬다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#불러오기",
    "href": "lab_02.html#불러오기",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n5 불러오기",
    "text": "5 불러오기\n불러오기와 관련된 함수들은 대부분 readr 패키지에 포함되어 있다. 여러 유형의 파일을 불러오기 위해 여러 함수가 존재하지만, 콤마분리값(comma-separated values, CSV) 형식의 데이터를 불러오는 함수(read_csv())만 실습한다.\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\") # URL에서 가져온 CSV 파일을 students에 할당\nglimpse(students)\n\nRows: 6\nColumns: 5\n$ `Student ID`   &lt;dbl&gt; 1, 2, 3, 4, 5, 6\n$ `Full Name`    &lt;chr&gt; \"Sunil Huffmann\", \"Barclay Lynn\", \"Jayendra Lyne\", \"Leo…\n$ favourite.food &lt;chr&gt; \"Strawberry yoghurt\", \"French fries\", \"N/A\", \"Anchovies…\n$ mealPlan       &lt;chr&gt; \"Lunch only\", \"Lunch only\", \"Breakfast and lunch\", \"Lun…\n$ AGE            &lt;chr&gt; \"4\", \"5\", \"7\", NA, \"five\", \"6\"\n\n\n\n\n\n\n\n\n노트\n\n\n\n데이터 불러오기에 대한 보다 자세한 내용은 3주차 실습에서 다룬다.",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "lab_02.html#파이프-연산자pipe-operator",
    "href": "lab_02.html#파이프-연산자pipe-operator",
    "title": "Lab02: R과 데이터사이언스",
    "section": "\n6 파이프 연산자(pipe operator)",
    "text": "6 파이프 연산자(pipe operator)\n우리는 이전 실습에서 할당 연산자(&lt;-)에 대해 배웠다. 오늘 살펴본 다양한 변형의 결과를 다른 데이터 프레임에 담고 싶으면 다음과 같이 할당 연산자를 사용할 수 있다.\n\nflights_day1 &lt;- filter(flights, month == 1 & day == 1)\nglimpse(flights_day1)\n\nRows: 842\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n\n6.1 파이프 연산자\n\n현재 RStudio의 디폴트는 %&gt;%로 설정되어 있다. 이것을 Tools &gt; Global Options &gt; Code에 가서 ’Use native pipe operator, |&gt; (requires R 4.1+)’를 선택해 주어야 한다. 아래의 그림 1 를 참고하라.\n\n\n\n\n\n\n그림 1: 파이프 연산자(https://r4ds.hadley.nz/data-transform)\n\n\n\n단축키는 Crtl + Shift + M(Mac은 Commnad + Shift + M)이다. 다른 건 몰라도 이 단축키만은 반드시 기억해야 한다.\n\nIAH 공항으로 가기 위한 가장 빠른 항공편을 찾기 위한 다음의 코드들을 비교해 보자. 먼저 파이프 연산자를 사용하지 않은 경우이다.\n\n# 중간에 여러 변수를 거쳐야 한다.\nflights1 &lt;- filter(flights, dest == \"IAH\")\nflights2 &lt;- mutate(flights1, speed = distance / air_time * 60)\nflights3 &lt;- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n\n# 또는 함수 안에 함수를 집어넣는 과정을 반복해야 한다.\narrange(\n  select(\n    mutate(\n      filter(\n        flights, \n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n다음은 파이프 연산자를 사용한 경우이다. 동일한 결과를 가져다 주지만 훨신 더 간결하고 직관적이고 이해하기 쉽다. 파이프 연산자의 사용 원리는 이후 실습에서 자세히 배운다.\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt;\n  mutate(speed = distance / air_time * 60) |&gt; \n  select(year:day, dep_time, carrier, flight, speed) |&gt; \n  arrange(desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows",
    "crumbs": [
      "R 실습: 2024/1",
      "Lab02: R과 데이터사이언스"
    ]
  },
  {
    "objectID": "abc.html",
    "href": "abc.html",
    "title": "abc",
    "section": "",
    "text": "이상일\n\n\n\n 맨 위로"
  },
  {
    "objectID": "exec_01.html",
    "href": "exec_01.html",
    "title": "R과 RStudio",
    "section": "",
    "text": "여기서는 R과 RStudio의 기본기를 다진다. 다음과 같은 사항이 다루어진다.\n\nR과 RStudio 설치\nRStudio 둘러보기\n프로젝트와 스크립트 개념 이해하기\n\n\n\n\n\n\n\n경고\n\n\n\nR은 실행과정에서 폴더 경로에 한글이 포함된 경우 오류가 자주 발생한다. 따라서 사용자 계정 이름이 한국어로 설정되어 있지 않은지 반드시 확인해야 하며, 앞으로 만들 프로젝트 폴더 등도 이름을 모두 영어로 설정하는 것이 좋다.\nWindows: [설정] -&gt; [계정] -&gt; [사용자 정보]로 들어가 볼드체로 된 사용자 계정 이름이 영어인지 확인하기. 사용자 계정이 한국어로 설정되어 있다면 영어로 된 새로운 윈도우 사용자 계정을 만들어야 한다.\nMac: 프로젝트 폴더 이름 설정만 잘 신경쓰면 된다.",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 RStudio"
    ]
  },
  {
    "objectID": "exec_01.html#개요",
    "href": "exec_01.html#개요",
    "title": "R과 RStudio",
    "section": "",
    "text": "여기서는 R과 RStudio의 기본기를 다진다. 다음과 같은 사항이 다루어진다.\n\nR과 RStudio 설치\nRStudio 둘러보기\n프로젝트와 스크립트 개념 이해하기\n\n\n\n\n\n\n\n경고\n\n\n\nR은 실행과정에서 폴더 경로에 한글이 포함된 경우 오류가 자주 발생한다. 따라서 사용자 계정 이름이 한국어로 설정되어 있지 않은지 반드시 확인해야 하며, 앞으로 만들 프로젝트 폴더 등도 이름을 모두 영어로 설정하는 것이 좋다.\nWindows: [설정] -&gt; [계정] -&gt; [사용자 정보]로 들어가 볼드체로 된 사용자 계정 이름이 영어인지 확인하기. 사용자 계정이 한국어로 설정되어 있다면 영어로 된 새로운 윈도우 사용자 계정을 만들어야 한다.\nMac: 프로젝트 폴더 이름 설정만 잘 신경쓰면 된다.",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 RStudio"
    ]
  },
  {
    "objectID": "exec_01.html#r과-rstudio-설치",
    "href": "exec_01.html#r과-rstudio-설치",
    "title": "R과 RStudio",
    "section": "\n1 R과 RStudio 설치",
    "text": "1 R과 RStudio 설치\n프로그램을 다운로드하기 위해 다음의 웹사이트로 이동한다. 여기는 RStudio를 만든 posit(과거에는 회사명 자체도 RStudio였음)이라는 회사가 관리하는 RStudio Desktop 다운로드 페이지이다.\n그러면 그림 1 과 같이 R과 RStudio를 설치할 수 있는 화면이 나타날 것이다.\n\n\n\n\n\n그림 1: 다운로드 화면\n\n\n\n1.1 R의 설치\n왼쪽의 다운로드 바를 클릭하면 CRAN(The Comprehensive R Archive Network)으로 이동한다. 자신의 운영체계에 맞는 R의 최신 버전을 다운로드하고 자신의 디바이스에 설치한다. 이 다큐먼트 작성 시점 기준으로 R의 최신 버전은 4.5.1이다.\n\n\n\n\n\n\n노트\n\n\n\nCRAN은 R의 핵심 소프트웨어 저장소(software repository)이다. R 프로그램 자체의 과거와 현재의 버전들 뿐만 아니라 수많은 R 패키지(package)(현재 대략 20,000개)가 모여 있는 곳이다. 1997년 Kurt Hornik와 Friedrich Leisch에 의해 처음 만들어졌으며, 현재에도 Hornik와 많은 자원봉사자들에 의해 운영되고 있다. 자세한 사항은 Wikipedia를 참조할 수 있다.\n\n\n\n1.2 RStudio의 설치\nR의 지배적인 IDE(Integrated Development Environment, 통합개발환경)인 RStudio를 설치한다. 다시 원래의 다운로드 페이지로 돌아와, 오른편의 다운로드 바를 클릭하면 윈도우즈용 RStudio의 파일을 다운로드할 수 있다. 스크롤 다운하면 다른 운영체계를 위한 RStudio를 다운로드할 수 있다. 다운받은 RStudio를 자신의 디바이스에 설치한다. 이 다큐먼트 작성 시점 기준으로 RStudio의 최신 버전은 2025년 5월 1일에 발표된 2025.05.1+513이다.\nRStudio는 R만을 위한 IDE인데, posit은 최근 R과 Python 모두를 사용할 수 있는 범용 IDE인 Positron을 개발하였다. 2025년 7월 3일에 베타 버전을 끝내고 정식 출시했으며, 현재는 2025년 8월 14일에 출시된 2025.08.0-130이 최신 버전이다. Positron은 RStudio와 Python에서 많이 사용되는 VS Code를 결합한 것으로, 향상된 기능과 외견이 기대된다. 2026년부터는 RStudio에서 Positron으로의 이동이 본격화될 것이다. Positron을 살펴보는데 아래의 동영상이 도움이 될 것이다.",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 RStudio"
    ]
  },
  {
    "objectID": "exec_01.html#rstudio-둘러보기",
    "href": "exec_01.html#rstudio-둘러보기",
    "title": "R과 RStudio",
    "section": "\n2 RStudio 둘러보기",
    "text": "2 RStudio 둘러보기\n\n2.1 창(pane, 패인)\nRStudio를 실행하면 아마도 대부분의 경우 그림 2 와 같은 화면을 보게 될 것이다. 크게 세 개의 창으로 구성되어 있음을 알 수 있다.\n\n\n\n\n\n그림 2: 세 개의 창\n\n\n왼편에 가장 크게 나타나 있는 것을 Console 창(pane)이라고 부르고, 우하의 창은 Output 창 혹은 File 창이라고 부른다. 우상에도 또 다른 창이 하나 보이는데 보통 Environment 창이라고 부른다.\n\n\n\n\n\n\n노트\n\n\n\n개별 창은 여러 개의 탭(tab)으로 구성되어 있는데, 탭의 기능이 매우 다양하기 때문에 소속 탭의 모든 기능을 포괄하는 일관성 있는 창 이름을 붙이는 것이 매우 어렵다. 예를 들어 Output 창의 경우 Plots와 Viewer 탭은 결과물을 보여주는 것이라 할 수 있지만 나머지 탭은 꼭 그렇지도 않다.\n\n\n\n2.2 Console 창에서 놀아보기\n여기서는 Console 창을 통해 R의 가장 기본적인 다음의 개념들에 대해 알아보고자 한다. Console 창은 R에서 CLI(command-line interface, 명령줄(어) 인터페이스) 역할을 하는 가장 핵심적인 부분이다. 사용자가 프로그램을 통해 컴퓨터와 상호작용하는 인터페이스이다.\n\n프롬프트(prompt): 명령 프롬프트(command prompt)라고도 불리는 것으로, CLI에서 명령어 대기 상태를 나타내는 일종의 부호이다. R에서는 &gt;를 사용한다.\n할당(assignment): 값을 식별자(identifier)를 가진 객체로 전환하는 과정을 의미한다. 프로그래밍 언어는 할당을 위한 고유한 연산자(operator)를 가지고 있는데, R은 &lt;-을 사용한다. =도 동일한 기능을 하는데, 권장하지는 않는다.\n객체(object): 값을 품고 있는, 식별자를 가진, 메모리 상의 기본 단위\n함수(function): 특정 동작을 수행하는 코드 블록을 의미한다. 인풋을 함수에 적용하면 함수의 고유한 동작을 통해 아웃풋이 산출된다.\n벡터(vector): 숫자의 일차원적 집합으로 보통 개별 행(row) 혹은 개별 열(column)을 의미한다.\n데이터 프레임(data frame): 하나 이상의 벡터를 모아 둔 숫자의 2차원적 집합으로, 다수의 행과 다수의 열로 이루어진 테이블을 의미한다. 이것이 보통 우리가 데이터셋이라고 부르는 것이다.\n\n\n2.2.1 프롬프트, 할당, 객체\n콘솔 창에 R 프롬프트인 &gt;가 나타나 있을 것이다. 아래와 같이 숫자 1을 타이핑하고 실행을 위해 [enter] 키를 누른다.\n\n1\n\n[1] 1\n\n\n간단한 연산을 해본다. 사실 R은 기본적으로 계산기이다.\n\n1 + 2\n\n[1] 3\n\n\n이제 할당 연산자(&lt;-)를 활용하여 할당을 해보자.\n\na &lt;- 1\n\n우상의 Environment 창을 보면 뭔가 생성된 것을 확인할 수 있을 것이다. a라는 객체가 생성되었으며 그것은 1이라는 값을 품고 있다는 의미이다. 이제 a는 알파벳 소문자가 아니라 1이라는 숫자와 필연적으로 결합해 있는 객체이다. 다음을 샐행하면 이러한 사실을 보다 명확히 확인할 수 있다.\n\n\n\n\n\n\n노트\n\n\n\n할당 연산자의 단축키는 Alt + - 이다. 가장 많이 사용하게 될 단축키 중의 하나이다. 이 단축키를 사용하면 좋은 점 중의 하나는 전후에 빈 공간이 자동적으로 생성된다는 점이다. 따라서 객체 이름 다음에 할당 연산자를 사용하기 위해 스페이스바를 사용할 필요가 없다.\n\n\n\na\n\n[1] 1\n\n\n아래와 같이 하면 객체끼리의 연산이 가능하다.\n\nb &lt;- 2\nc &lt;- a + b\nc\n\n[1] 3\n\n\nBase R에는 할당 연사자 외에도 여러 연산자가 존재한다. 이를 정리하면 다음과 같다.\n\n\n\n\n\n\n\n\n범주\n연산자\n설명\n예시\n\n\n\n할당(assignment) 연산자\n\n&lt;- 혹은 -&gt;\n\n데이터를 객체에 할당\na &lt;- 5\n\n\n수리(arithmetic) 연산자\n+\n더하기(addition)\n5 + 5 = 10\n\n\n\n-\n빼기(subtraction)\n5 - 5 = 0\n\n\n\n*\n곱하기(multiplication)\n2 * 8 = 16\n\n\n\n/\n나누기(division)\n100 / 10 = 10\n\n\n\n\n^ 혹은 **\n\n제곱(exponent/power)\n5^2 = 25\n\n\n\n%%\n나머지(modulo)\n100 %% 15 = 10\n\n\n\n%/%\n몫(integer division)\n100 %/% 15 = 6\n\n\n관계(relational) 연산자\nx &lt; y\nx가 y보다 작은 경우\n3 &lt; 4 TRUE\n\n\n\n\nx &gt; y\nx가 y보다 큰 경우\n3 &gt; 4 FALSE\n\n\n\n\nx &lt;= y\nx가 y보다 작거나 같은 경우\n3 &lt;= 4 TRUE\n\n\n\n\nx &gt;= y\nx가 y보다 크거나 같은 경우\n3 &gt;= 4 FALSE\n\n\n\n\nx == y\nx와 y가 같은 경우\n3 == 4 FALSE\n\n\n\n\nx != y\nx와 y가 다른 경우\n3 != 4 TRUE\n\n\n\n논리(logical) 연산자\n!\n논리 부정(negation)\n\n\n\n\n&\n논리곱(logical “and”)\n\n\n\n\n|\n논리합(logical “or”)\n\n\n\n\nxor\n배타적 논리합(logical “exclusive or”)\n\n\n\n기타 연산자\nx %in% y\n원소 포함\n벡터 x의 각 원소가 y 안에 존재하는지 확인\n\n\n\n!(x %in% y)\n원소 비포함\n벡터 x의 각 원소가 y 안에 존재하지 않는지 확인\n\n\n\n2.2.2 함수\nsum() 함수를 사용하여 동일한 연산을 할 수 있다. sum()은 R에 기본적으로 내장되어 있는 Base R 함수 중 하나이다.\n\nsum(a, b)\n\n[1] 3\n\n\n\n\n\n\n\n\n중요\n\n\n\n지금부터 모든 함수명에는 항상 ()를 연결하여 나타낼 것이다. 다른 객체명과의 혼동을 방지하기 위한 것도 있지만, 모든 함수는 () 속에 인풋(이것을 인자(argument)라고 부른다)을 받아들이기 때문이다.\n\n\nR에는 수많은 내장 함수가 있다. 그 중 몇가지만 실행하면 다음과 같다. sqrt()는 제곱근을, abs()는 절대값을, log10()는 밑을 10으로 하는 로그값을 산출해준다.\n\nsqrt(2)\n\n[1] 1.414214\n\nabs(-3)\n\n[1] 3\n\nlog10(100)\n\n[1] 2\n\n\nBase R에서 사용되는 주요 내장 함수를 정리하면 다음과 같다.\n\n\n\n\n\n\n\n범주\n구분\n함수\n\n\n\n논리형 판별 함수\n결측치 여부\n\nis.na(), is.nan(), is.infinite(), is.finite()\n\n\n\n\n유형 확인\n\nis.numeric(), is.integer(), is.character(), is.logical(), is.factor()\n\n\n\n\n구조 확인\n\nis.data.frame(), is.matrix(), is.list(), is.vector()\n\n\n\n\n기타\n\nis.null(), is.atomic(), is.element()\n\n\n\n위치 기반 추출 함수\n첫 번째 원소\nx[1]\n\n\n\n마지막 원소\nx[length(x)]\n\n\n\nn번째 원소\nx[n]\n\n\n\n앞의 몇 개의 원소\nhead()\n\n\n\n뒤의 몇 개의 원소\ntail()\n\n\n수학 함수\n절댓값/부호\n\nabs(), sign()\n\n\n\n\n제곱근/지수\n\nsqrt(), exp()\n\n\n\n\n로그\n\nlog(), log10(), log2()\n\n\n\n\n삼각함수\n\nsin(), cos(), tan(), asin()\n\n\n\n\n반올림\n\nround(), floor(), ceiling(), trunc()\n\n\n\n\n요약\n\nsum(), mean(), median(), var(), sd(), min(), max(), range(), summary()\n\n\n\n벡터 생성 함수\n수열/반복\n\nseq(), rep()\n\n\n\n\n특정 유형\n\nnumeric(), integer(), logical(), character()\n\n\n\n\n난수/표본 생성\n\nsample(), rnorm(), runif(), rbinom()\n\n\n\n집합 연산 함수\n합집합\nunion()\n\n\n\n교집합\nintersect()\n\n\n\n차집합\nsetdiff()\n\n\n\n동일 여부\nsetequal()\n\n\n\n원소 포함 여부\nis.element()\n\n\n변환 함수\n유형 변환\n\nas.numeric(), as.character(), as.factor(), as.data.frame()\n\n\n\n\n재코딩/재배열\n\ncut(), relevel(), reorder()\n\n\n\n\n표준화\nscale()\n\n\n기타 함수\n길이\nlength()\n\n\n\n정렬\n\nsort(), order()\n\n\n\n\n중복 처리\n\nunique(), duplicated()\n\n\n\n\n결측치 처리\nna.omit()\n\n\n\n\n\n\n\n\n\n노트\n\n\n\n최근 tidyverse 패키지의 사용이 활발해 지면서 이러한 Base R 함수의 활용에 약간의 변동이 발생하고 있다. tidyverse 패키지는 타이디버스 디자인 원리에 의거해 새로운 함수를 디자인하여 제공하고 있다. 이러한 타이디버스 함수가 Base R 함수나 기존의 패키지의 함수를 대체해 나가고 있는 실정이다. 여전히 많은 사람이 여기에 열거되어 있는 Base R의 기본 함수를 사용하고, 그러한 문법에 따라 코드를 작성하고 있다. 나는 타이디버스가 R의 미래라고 확신하며 가능한 코드를 타이디버스 함수를 이용해 작성하도록 노력할 것이다. 여기서 Base R의 함수는 기본적으로 벡터에 적용되는 함수이고, 타이디버스 함수는 데이터 프레임에 적용되는 함수라는 점을 명확히 할 필요가 있다. 따라서 타이디버스에서 벡터 연산을 할 때는 위에서 열거한 많은 함수를 그대로 사용한다. 특히, 논리형 판별 함수와 수학 함수는 그대로 사용하고 있다. 집합 연산 함수는 이름은 동일하지만 사실 새롭게 디자인한 함수이다. 타이디버스는 새로운 데이터 프레임 기반 함수를 통해 기존의 벡터 기반 함수가 하는 일을 대체하고자 한다. 그렇지만 모든 코드를 데이터 프레임 함수로만 작성할 수 없고, Base R의 여러 벡터 함수는 여전히 유용하게 사용되고 있다. 타이디버스가 부가적으로 제공하는 벡터 함수에 대해서는 다른 장에서 다루도록 한다.\n\n\n\n2.2.3 벡터와 데이터 프레임\n위에서 살펴본 숫자 하나하나는 큰 의미가 없다. 우리는 보통 숫자의 집합(array), 즉 벡터를 다룬다.\n\na &lt;- c(58, 26, 24)\nb &lt;- c(58L, 26L, 24L)\nc &lt;- c(TRUE, TRUE, FALSE)\nd &lt;- c(\"이상일\", \"김세창\", \"김우형\")\n\na, b, c, d는 모두 벡터이다. 우상의 Environment 창에서도 이러한 사실을 확인할 수 있다. 그런데, 이 세가지 벡터는 데이터의 유형(type)이라는 측면에서 서로 다르다. a는 숫자형(numeric), b는 정수형(integer), c는 논리형(logical), d는 문자형(character)이다. Environment 창을 보면, a에 대해서는 num, b에 대해서는 int, c에 대해서는 logi, d에 대해서는 chr이라는 축약어가 붙어 있음을 알 수 있는데, 이것이 바로 벡터의 유형을 나타내고 있는 것이다. 사실 R에서 다루는 벡터의 유형은 10가지가 넘는다.\n\n\n\n\n\n\n노트\n\n\n\ntidyverse 패키지의 핵심 패키지 중의 하나인 tibble 패키지에서 규정된 데이터 유형에 대해서는 다음의 웹사이트를 참고할 수 있다. https://tibble.tidyverse.org/articles/types.html\n\n\n벡터를 data.frame()이라는 함수를 통해 결합하면 데이터 프레임을 만들 수 있다.\n\ndf &lt;- data.frame(a, b, c, d)\ndf\n\n   a  b     c      d\n1 58 58  TRUE 이상일\n2 26 26  TRUE 김세창\n3 24 24 FALSE 김우형\n\n\n우상의 Environment 창을 보면 뭔가 변화가 있음을 확인할 수 있을 것이다. Data가 생겼고 그 아래에 df가 생성되어 있을 것이다. “3 obs. of 4 variables”라는 말이 굉장히 중요하다. 이것은 df라는 데이터 프레임 객체가 3개의 관측 개체(observations)와 4개의 변수(variables)로 구성되어 있다는 것을 의미한다. 데이터 프레임, 관측 개체, 변수에 대해서는 강의에서 상세하게 다룬다.\nEnvironment 창에서 df를 클릭해보라. 그러면 왼편에 또 하나의 창이 생기면서 마치 엑셀과 같은 형식으로 데이터가 나타날 것이다. View() 함수를 실행해도 동일한 결과를 얻을 수 있다.\n\nView(df)\n\n여기서 중요한 것은 새로 생긴 창이다. 이것을 보통 Editor 창이라고 부른다. 이제부터 Console은 부차적인 목적으로만 사용할 것이고 Editor 창이 주인공이 된다.",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 RStudio"
    ]
  },
  {
    "objectID": "exec_01.html#프로젝트project와-스크립트script",
    "href": "exec_01.html#프로젝트project와-스크립트script",
    "title": "R과 RStudio",
    "section": "\n3 프로젝트(project)와 스크립트(script)",
    "text": "3 프로젝트(project)와 스크립트(script)\n\n3.1 프로젝트 만들기\n\n3.1.1 R 프로젝트의 개념\nRStudio에서 프로젝트란 한 단위의 R 과업을 의미한다. 매우 단순한 과업도 있겠지만, 보통 데이터를 읽고, 정돈하고, 변형하고, 시각화하고, 모델링하는 등의 다양한 활동이 개입된다. 하나의 일관된 목적을 위해 이러한 다양한 일을 한다면, 이것들을 한데 모아 함께 관리하는 것이 좋을 것이다. 프로젝트는 하나의 과업을 위해 당신이 행한 모든 것이 체계적으로 정돈되어 있는 가상의 방이다. 좀 이질적인 과업을 하게 된다면 기존의 프로젝트 속에서 하기 보다는 또 다른 프로젝트를 만들어 그 속에서 하는 것이 효과적일 것이다.\nRStudio의 프로젝트는 실질적으로 하나의 폴더를 의미한다. 하나의 폴더 속에 모든 활동과 그것의 인풋 및 아웃풋이 모두 저장되고, RStudio는 그것을 체계적으로 관리할 수 있게 해주는 툴을 제공한다.\n다음과 같은 관행을 추천한다.\n\n디바이스에 모든 R 프로젝트를 포괄하는 최상위 폴더를 만든다. 걸맞는 폴더명(예: R_Projects)을 부여한다. 이것은 R 외부에서 미리 해둔다. 물론 Output 창의 Files 탭을 이용하면 R 내부에서도 할 수 있다.\n최상위 폴더 아래에 개별 R 프로젝트를 위한 폴더를 만든다. 과업에 걸맞는 폴더명(예: AI_Class_2025)을 부여한다. 이것을 R 외부에서 미리 해둘 수도 있고, R 내부에서 프로젝트를 생성할 때 할 수도 있다. 후자를 추천한다.\n\n3.1.2 R 프로젝트 만들기\n두 가지 방법이 있다.\n\n최상단 메뉴를 이용: File &gt; New Project\n상단 메뉴바 오른쪽 맨끝에 있는 작은 화살표 아이콘: New Project\n\n그림 3 에 나타나 있는 절차를 통해 프로젝트를 생성한다. 각각 다음의 단계를 거친다.\n\n1단계: 과제 폴더(디렉토리)를 미리 만들어 두지 않았다면, New Directory를 선택한다(추천). 그렇지 않았다면 Existing Directory를 선택한다.\n2단계: New Project를 선택한다.\n3단계: ’Directory name:’에 과제를 위한 폴더명을 타이핑한다(예: AI_Class_2025). ’Create project as subdirectory of:’에 최상위 폴더(예: R_Projects)를 선택한다.\n\n\n\n\n\n\n그림 3: R 프로젝트의 생성 절차\n\n\nOutput 창의 Files 탭을 누르면, 다양한 기본 파일들이 해당 폴드에 생성되었음을 확인할 수 있다. 가장 중요한 파일은 .RProj라는 확장자를 가진 파일이다. 나중에 R 외부에서 이 파일을 더블클릭하면 R 프로젝트를 열 수 있다.\n\n\n\n\n\n\n힌트\n\n\n\n\n\nR 외부의 파일 관리 시스템(윈도우즈의 경우 파일 탐색기)를 사용하지 말고, Output 창의 Files 탭을 사용하는 것이 훨씬 유용하다. 파일 탐색기에서 제공하는 거의 대부분의 기능을 제공한다.\n\n\n\n\n3.1.3 옵션의 변경\nRStudio의 기본 세팅값을 바꿀 수 있는 다양한 옵션이 존재한다. Tools &gt; Global Options를 선택하면 그림 4 과 같은 화면을 볼 수 있을 것이다. 다음의 두 가지를 해보라.\n\n자신이 좀 숙달된 R 사용자가 되었다고 판단되는 즈음에, 가운데 Workspace 부분을 그림과 동일하게 변경해보라. 디폴트는 체크가 되어 있는 것인데, 프로젝트를 다시 열었을 때 그 전에 만들어 둔 데이터나 객체가 모두 그대로 남아있게 한다. 초보자에게는 이것이 좋을 것이다. 그러나 새로운 세션을 시작할 때 마다 그 전의 흔적을 밀어버리고, 다시 모든 코드를 실행하여 결과를 새로이 얻는 것이, 프로그래밍 측면에서는 ‘완전한’ 일이다.\n왼쪽에서 Apearance를 선택한 후, ’Editor font size:’나 ’Editor theme’을 변경하여 자신의 선호를 반영하라.\n\n\n\n\n\n\n그림 4: 옵션의 변경\n\n\n\n3.2 스크립트 만들기\n\n3.2.1 Console에서 Script Editor로\nConsole은 명령어를 입력하고 그 결과를 볼 수 있는 곳이다. 이것은 Base R의 기본 기능을 RStudio가 충실하게 구현한 것이다. 그런데 제법 복잡한 R 프로젝트를 수행하고자 할 때 Console을 이용하는 방식은 제한점이 많다.\n\n다양하고 복잡한 R 명령어를 실행하고 그 결과를 보기에는 공간이 협소하다.\nConsole에서 행한 것은 저장되지 않는다. 보다 정확하게 말하면, 산출물은 저장될 수 있지만, 그러한 산출물을 얻는데 동원된 일련의 코드는 저장되지 않는다. RStudio를 나갔다가 다시 들어오면 객체, 플롯 등의 산출물은 그대로 남아 있지만 어떤 과정을 거쳐 그러한 결과물을 산출했는지에 대한 것을 남아 있지 않다. 이런 점은 상당한 기간이 지난 후에는 더 큰 문제로 다가온다.\n\n이러한 의미에서 R을 가지고 행한 것을 모두 저장하는, 일종의 연구노트와 같은 것이 필요하다. 이것을 R 스크립트(script)라고 부르는데, 좌상의 Editor 창에서 스크립트를 다루고, .R이라는 확장자를 가진 파일로 저장한다.\n\n3.2.2 스크립트 파일 생성하고 저장하기\n스크립트 파일을 생성하는 세 가지 정도의 방법이 있다.\n\nFile &gt; New File &gt; R Script 선택\nFile 메뉴 바로 아래의 New File 아이콘을 누른 후 R Script 선택\n단축키(Ctrl + Shift + N) 실행\n\n이렇게 하면 그림 5 과 같이 좌상에 Editor 창이 생성된다. 그 안에서 그림에서 보는 바와 같이 코드를 작성하게 된다.\n\n\n\n\n\n그림 5: 네 개의 창(https://docs.posit.co/ide/user/ide/guide/ui/ui-panes.html)\n\n\n스크립트 파일에 이름을 부여하고 저장한다.\n\nFile &gt; Save 선택\nSave current document 아이콘 클릭\n단축키(Ctrl + S) 실행\n\n3.2.3 스크립트 파일에서의 실행\n앞에서 Console에서 했던 모든 일을 동일하게 할 수 있다. 단 실행 방식이 조금 다르다. 앞에서 생성한 df 데이터 프레임의 a 벡터(변수)의 평균값을 구하기 위해 이전과 동일하게 입력한다. 그런데 프롬프트가 없고, [enter]를 눌러도 실행되지 않는다.\n\nmean(df$a)\n\n우선 실행할 코드 라인 혹은 코드의 영역을 지정해야 한다. 두 가지 방법이 있다.\n\n실행할 코드 라인 혹은 코드 블록에 커서를 위치시킨다.\n왼쪽 마우스 버튼을 누른 상태에서 커서를 이동시켜 실행할 영역 전체를 선택한다.\n\n영역이 지정되면 실행하면 되는데, 여기에도 두 가지 방법이 있다.\n\n단축키(Ctrl + Enter) 실행\nEditor 창의 우상에 있는 ‘Run the current line or selection’ 아이콘을 클릭(그림 6 참조)\n\n\n\n\n\n\n그림 6: 스크립트 파일에서의 실행(https://docs.posit.co/ide/user/ide/guide/code/execution.html)\n\n\n이전의 실행을 반복하고자 할 때는 다음과 같이 하면 된다.\n\n단축키(Ctrl + Alt +P) 실행\nEditor 창의 우상에 있는 ‘Re-run the previous code region’ 아이콘을 클릭(그림 6 참조)\n\n스크립트 파일 내 모든 코드를 실행하고자 할 때는 다음과 같이 하면 된다.\n\n단축키(Crtl + Shift + S)\n\n3.2.4 코멘트\n코드에 대한 코멘트를 스크립트 파일 곳곳에 남겨두면 나중에 코드 작성의 의도를 보다 쉽게 파악할 수 있다. 이와 관련하여 두 가지 사항을 알아두면 유용하다.\n첫째, # 표시 뒤의 것은 R이 실행하지 않기 때문에 중간중간에 # 표시를 하고 그 뒤에 자신의 코멘트를 남겨두는 것을 권한다.\n\nmean(df$a) # 세 사람의 나이 평균을 구함. 첫 번째 사람 나이가 엄청나게 많음.\n\n둘째, 코드가 길어지면, 그것을 몇 개의 섹션으로 나누고 그것에 코멘트를 달아 줄 수 있다. 단축키(Crtl + Shift + R)를 실행하여 섹션 라벨(Section label)을 달 수 있고, Editor 창의 왼쪽 하단에 있는 작은 아이콘을 이용해 섹션을 빠르게 이동할 수 있다.\n\n\n\n\n\n그림 7: 섹션 코멘트 달기(https://r4ds.hadley.nz/workflow-style.html#sectioning-comments)",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 RStudio"
    ]
  },
  {
    "objectID": "exec_10.html",
    "href": "exec_10.html",
    "title": "소통하기: 지리공간적 시각화",
    "section": "",
    "text": "여기서는 지리공간적 시각화, 특히 지도 제작에 집중한다. “지도는 텍스트, 테이블, 챠트와 같은 것들 보다 훨씬 더 효과적으로 정보를 전달할 수 있다.”(Dougherty 와/과 Ilyankou 2021)\n우선 tidyverse 패키지를 불러온다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: 지리공간적 시각화"
    ]
  },
  {
    "objectID": "exec_10.html#개요",
    "href": "exec_10.html#개요",
    "title": "소통하기: 지리공간적 시각화",
    "section": "",
    "text": "여기서는 지리공간적 시각화, 특히 지도 제작에 집중한다. “지도는 텍스트, 테이블, 챠트와 같은 것들 보다 훨씬 더 효과적으로 정보를 전달할 수 있다.”(Dougherty 와/과 Ilyankou 2021)\n우선 tidyverse 패키지를 불러온다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: 지리공간적 시각화"
    ]
  },
  {
    "objectID": "exec_10.html#지리공간적-데이터와-지도",
    "href": "exec_10.html#지리공간적-데이터와-지도",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n1 지리공간적 데이터와 지도",
    "text": "1 지리공간적 데이터와 지도\n\n1.1 벡터와 래스터 데이터\n지도는 간단히 말해 지리공간적(geospatial) 데이터를 그래픽 형태로 나타낸 것이다. 따라서 지리공간적 데이터를 이해하는 것이 지도 제작의 시발점이 되어야 한다. 지리공간적 데이터는 GIS적 관점에서 벡터(vector) 데이터와 래스터(raster) 데이터로 나뉜다. 벡터 데이터는 지리공간적 사상의 기하학적 형태(형상 데이터)와 그것의 다양한 특성(속성 데이터)을 담고 있는 데이터이다.\n벡터 데이터는 지리공간적 사상을 포인트, 라인, 폴리곤 피처로 구분하고, 개별 피처를 형태와 위치를 개별 피처를 구성하고 있는 버택스의 좌표값을 저장함으로써 구현하는데, 이러한 정보를 담고 있는 것을 형상 데이터라고 한다. 예를 들어 우리나라 17개 시도에 대한 디지털 행정구역도가 여기에 해당한다. 이에 반해 속성 데이터는 포인트, 라인, 폴리곤 등으로 재현된 개별 피처의 다양한 특성을 가지고 있는 것으로 보통 테이블 데이터라고 한다. 예를 들어, 우리나라 17개 시도의 인구수, 인구성장률, 순이동률과 같은 것이다. 형상 데이터가 지리공간적 데이터의 특수성을 더 잘 반영하기 때문에 보통 형상 데이터를 공간 데이터라고도 하면, 벡터 데이터에서는 이 두 종류의 데이터가 기본적으로 독립적이며 보통은 느슨한 형태로 결합되어 있다.\n이에 반해 래스터 데이터는 세상을 동일한 크기의 수 많은 그리드 셀(grid cell)로 구성되어 있다고 보며, 개별 그리드 셀에 속성이 저장되어 있는 데이터를 의미한다. 가장 쉬운 예가 인공위성 영상이다. 인공위성 영상의 특정한 공간해상도를 가진 픽셀로 나뉘어져 있고, 개별 픽셀에 특정한 값(특정한 밴드의 반사값)이 들어가 있다. 따라서 래스터 데이터는 벡터 데이터처럼 형상 데이터와 속성 데이터가 분리되어 있는 것이 아니라 일체형이다. 특수한 경우가 아니라면 하나의 래스터 파일에는 하나의 속성만이 들어가 있다. 이에 반해 벡터 데이터의 속성 파일에는 수많은 변수가 포함될 수 있다.\n지도 제작의 원칙은 동일하지만, 지도로 나타낼 데이터가 벡터 데이터인지 래스터 데이터인지에 혹은 둘 다인지에 따라 지도화의 세부 절차는 달라질 수 있다. 여기서는 벡터 데이터에 기반한 지도 제작에 집중하고자 한다. 속성 데이터는 기본적으로 R의 데이터 프레임과 동일한 개념이므로, 데이터사이언스의 기본 과정을 통해 불러오고, 정돈하고, 변형할 수 있다. 따라서 보다 중요한 것은 형상 데이터를 다루는 것이다.\n\n1.2 셰이프 파일\n벡터 데이터 포맷, 보다 정확하게는 형상 데이터의 포맷으로 가장 널리 사용되고 있는 것이 셰이프 파일(shape file)이다. 셰이프 파일(확장자가 .shp인 파일)은 전세계에서 가장 큰 GIS 회사인 ESRI가 오래전에 개발한 벡터 데이터 포맷으로, 현재 표준 포맷의 역할을 하고 있다. 그런데 셰이프 파일은 동일한 이름을 공유하지만 확장자가 서로 다른 몇 개의 파일의 묶음을 지칭한다는 점을 이해할 필요가 있다. 반드시 다음의 네 파일을 함께 가지고 있어야 한다.\n\n*.shp: 버텍스의 좌표값이 포함된 핵심 파일\n*.dbf: 기본 속성 파일\n*.shx: 공간적 인덱싱 파일\n*.prj: 투영 정보 파일\n\n마지막의 *.prj 파일은 없어도 지도로 나타날 수는 있다. 그러나 다른 셰이프 파일과 함께 지도로 나타내거나 축척막대와 같은 지도 요소를 적절하게 나타내기 위해서는 좌표참조계(CRS) 정보가 포함된 *.prj 파일은 가질 필요가 있다.\n\n1.3 sf 패키지\nR에서 형상 데이터를 다루는데 있어 거의 표준처럼 사용되고 있는 것이 sf 패키지이다. 기본적으로는 셰이프 파일을 불러오기 위한 st_read() 함수를 주로 사용하게 되겠지만, sf 패키지는 벡터-기반 GIS 오퍼레이션을 위한 폭넓은 함수를 제공한다. 중요한 것을 정리하면 다음과 같다.\n\n\n\n\n\n\n\n구분\n함수\n설명\n\n\n\n읽고 쓰기\n\nst_read()\nread_sf()\n\n셰이프 파일 읽어 들이기\n\n\n\nst_write()\n셰이프 파일 저장\n\n\n투영 관련\nst_crs()\nCRS 정보 확인\n\n\n\nst_transform()\nCRS 바꾸기\n\n\n기하 측정\nst_area()\n면적 계산\n\n\n\nst_length()\n길이 계산\n\n\n\nst_perimeter()\n둘레 계산\n\n\n\nst_distance()\n거리 계산\n\n\n기하 변형\nst_centroid()\n센트로이드 생성\n\n\n\nst_buffer()\n버퍼 생성\n\n\n\nst_boundary()\n가장자리 추출\n\n\n\nst_simplify()\n선 피처 단순화 실행\n\n\n기하 생성\nst_point()\n포인트 피처 생성\n\n\n\nst_vironoi()\n보로노이 폴리곤 생성\n\n\n\nst_convex_hull()\n컨벡스 헐 생성\n\n\n\nst_make_grid()\n규칙 그리드 생성\n\n\n기하 검토\nst_is_valid()\n지오메트리가 밸리드한지 여부 검토\n\n\n\nst_make_valid()\n지오메트리를 밸리드하게 만들기\n\n\n기하 중첩\nst_intersection()\n기하 교집합 중첩\n\n\n\nst_union()\n기하 합집합 중첩\n\n\n\nst_crop()\n기하 크롭 중첩\n\n\n기타\nst_coordinates()\n버택스 좌표값 반환\n\n\n\nst_cast()\n다른 피처 유형으로 변환\n\n\n\nst_as_sf()\nsf 객체로 변환\n\n\n\nst_graticule()\n그래티큘 생성\n\n\n\nst_join()\n공간적 조인 실행\n\n\n\n래스터 데이터를 다루는데는 terra 패키지가 가장 널리 사용되고 있으며, stars패키지가 최근 많은 주목을 받고 있다. stars 패키지와 sf 패키지는 모두 에트저르 페베스마(Edzer Pebesma)가 만들었다. 두 패키지에 대한 설명은 페베스마와 로저 비번드(Roger Bivand)가 함께 쓴 ’R을 활용한 공간데이터사이언스(Spatial Data Science With Applications in R)’에 잘 나타나 있다(Pebesma 와/과 Bivand (2023))",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: 지리공간적 시각화"
    ]
  },
  {
    "objectID": "exec_10.html#정적-지도-제작",
    "href": "exec_10.html#정적-지도-제작",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n2 정적 지도 제작",
    "text": "2 정적 지도 제작\n\n2.1 세계 지도\nggplot2 패키지를 이용하여 정적 지도를 그려본다. ggplot2패키지로 지도를 그린다는 것은 ’지도도 그래프다.’라는 접근법에 기반하고 있다. ggplot2의 문법을 지도 제작으로 확장할 수 있고, 막강한 생태계를 고려할 때 충분히 이점이 있는 접근법이다.\n데이터는 지난 실습에서 사용한 WPP 2024(World Population Prospects 2024)이다. 2024년 전세계 국가별 TFR(Total Fertility Rate, 합계출산율) 지도를 그려본다.\n벡터 데이터를 활용한 지도는 형상 데이터와 속성 데이터를 결합해야만 제작할 수 있다. 여기서 형상 데이터는 전세계 국가 경계 데이터이고, 속성 데이터는 TFR이 포함된 WPP 2024 데이터이다. 형상 데이터는 spData 패키지에 들어 있는 world 객체를 사용한다. 벡터 형식의 데이터는 sf 패키지의 st_as_sf() 함수를 통해 sf 객체로 변환하는 것이 좋다.\n\nlibrary(spData)\nlibrary(sf)\ndata(world)\nworld &lt;- st_as_sf(world)\n\nWPP 2024 데이터를 불러와 2025년만 골라낸다.\n\nwpp_2024 &lt;- read_rds(\"wpp_2024.rds\")\nmy_wpp &lt;- wpp_2024 |&gt; \n  filter(year == 2025)\n\n두 데이터를 left_join() 함수를 이용하여 결합한다. 벡터 데이터의 경우는 늘 반드시 형상 데이터를 중심에 두고 left_join() 함수를 통해 속성 데이터를 불러와 합체해야 한다.\n\nworld_data &lt;- world |&gt;\n  left_join(my_wpp, join_by(iso_a2 == ISO2))\n\n로빈슨 도법(Robinson projection)의 지도를 제작한다. ggplot2 패키지로 지도를 그리는 가장 좋은 방법은 기하객체 함수인 geom_sf()와 좌표 변환 함수인 coord_sf()를 결합하는 것이다. scale_x_continuous()와 scale_y_continuous()의 내용은 그래티큘(경위선망)을 원하는 방식대로 지도에 포함시키기 위한 것이다. 그래프를 world_map이라는 이름의 객체로 저장하는 것은 뒤에서 이 지도를 사용하기 때문이다.\n\nworld_map &lt;- ggplot() +\n  geom_sf(data = world_data, aes(fill = TFR, text = name_long)) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_fill_viridis_c() +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.5, seq(-60, 60, 30), 89.5)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\nworld_map\n\n\n\n\n\n\n\n\n2.2 우리나라 지도\n우리나라 지도도 그려본다. ’Lab07: 데이터 수집하기’에서 KOSIS의 API를 통해 수집, 정리한 시군구 단위 지역소멸위험지수를 지도화한다. 우선 우리나라 시군구 행정 경계에 대한 도형(형상, 기하) 데이터가 필요하다. GADM(Database of Global Administrative Areas)는 전 세계 국가별, 행정구역 수준별, 고해상도 디지털 경계 파일을 제공한다. 직접 웹사이트를 방문해 파일을 다운로드할 수도 있지만, 여기서는 geodata 패키지의 도움을 받는다. geodata 패키지는 정말 다양한 종류의 공간 데이터를 쉽게 다운로드할 수 있게 도와준다. 1레벨인 시도 단위와 2레벨인 시군구 단위를 다운받는다. path 아규먼트가 반드시 필요한데, 프로젝트 파일의 폴더도 좋고, 앞으로 geodata 패키지를 통해 다운받을 데이터를 모아둘 곳을 따로 정해두어도 좋다. 그렇지만 할당 연산자를 통해 이름을 부여하면 따로 다운로드된 파일을 다시 부르는 수고는 하지 않아도 된다.\n\nlibrary(geodata)\nlibrary(tmap)\n\nkorea_sd &lt;- gadm(country = \"South Korea\", level = 1, path = \"D:/My R/Geodata/\")\nkorea_sd &lt;- korea_sd |&gt; \n  st_as_sf()\nkorea_sgg &lt;- gadm(country = \"South Korea\", level = 2, path = \"D:/My R/Geodata/\")\nkorea_sgg &lt;- korea_sgg |&gt; \n  st_as_sf()\n\n그런데 파일을 열어보고서 경악한다. 행정구역 코드가 없다. 그래서 이 방법은 포기한다.\n행정구역 파일은 통계청의 통계지리정보서비스에서 구할 수 있다. 다운받는 방법을 익히면 좋겠지만, 시간 절약을 위해 다운받아 정리한 파일을 그냥 제공한다. 프로젝트 폴더에 파일을 저장한 후, 아래의 코드를 통해 불러온다.\n\nsido_shp &lt;- st_read(\"sido.shp\", options = \"ENCODING=CP949\")\nsigungu_shp &lt;- read_sf(\"sigungu.shp\", options = \"ENCODING=CP949\")\n\n두 파일에 대해 서로 다른 함수를 적용한 것을 알 수 있다. st_read() 함수는 가장 보편적으로 사용되는 것으로 불러올 때마다 파일에 대한 정보(지오메트리 유형, 바운딩 박스, CRS 등)가 자동으로 디스플레이된다. 이러한 정보는 항상 유익한 것이지만 보이지 않게 하고 싶을 수도 있다. 이 때 read_sf() 함수를 사용할 수 있다.\n불러들인 파일을 바탕으로 시군구 경계를 그려본다. 지도 제작 전문 패키지인 tmap의 qtm() 함수를 이용하여 시군구 경계에 대한 지도를 빠르게 그려본다. tmap패키지로 지도를 그린다는 것은 ’지도는 지도다.’라는 접근법에 기반하고 있다. tmap의 문법을 새로 배워야 한다는 단점이 있긴 하지만, 지도는 그래프로 환원될 수 없는 고유한 특성이 있고, tmap패키지는 이러한 지도의 고유한 특성을 잘 반영하고 있다. 좀 더 복잡한 tmap의 문법을 사용한 지도 제작은 맨 뒤에서 다루기로 한다.\n\nlibrary(tmap)\nqtm(sigungu_shp)\n\n\n\n\n\n\n\n지역소멸위험지수 데이터를 불러온다. 아래 코드는 지난번 실습 때 rds 파일 포맷으로 저장해 둔 것을 가정한 것이다. 실습의 편의를 위해 파일을 제공하니 프로젝트 폴더에 저장한 후, 아래의 코드를 통해 불러온다.\n\ndata_sigungu &lt;- read_rds(\"data_sigungu.rds\")\n\n도형 데이터(korea_sgg)와 속성 데이터(data_sigungu)를 공통 키(key)를 활용하여 결합한다.\n\nsigungu_data &lt;- sigungu_shp |&gt; \n  left_join(\n    data_sigungu, join_by(SGG1_CD == C1)\n  )\n\n이제 ggplot2 패키지를 이용하여 지도를 제작한다. ’Lab07: 데이터 수집하기’에서 인구소멸위험지수의 시도별 그래프를 제작한 것과 비교해 보라. 그 유사함에 깜짝 놀랄 수도 있다. ggplot2에서는 그래프와 지도의 구분이 없다. 이것은 ggplot2의 장점이자 단점이다.\n\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index_class = case_when(\n      index &lt; 0.2 ~ \"1\",\n      index &gt;= 0.2 & index &lt; 0.5 ~ \"2\",\n      index &gt;= 0.5 & index &lt; 1.0 ~ \"3\",\n      index &gt;= 1.0 & index &lt; 1.5 ~ \"4\",\n      index &gt;= 1.5 ~ \"5\"\n    ),\n    index_class = fct(index_class, levels = as.character(1:5))\n  )\n\nclass_color &lt;- c(\"1\" = \"#d7191c\", \"2\" = \"#fdae61\",\n                 \"3\" = \"#ffffbf\", \"4\" = \"#a6d96a\", \n                 \"5\" = \"#1a9641\")\nggplot() +\n  geom_sf(data = sigungu_data, aes(fill = index_class), show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(name = \"Classes\", \n                    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \n                               \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n                    values = class_color, drop = FALSE)",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: 지리공간적 시각화"
    ]
  },
  {
    "objectID": "exec_10.html#인터랙티브-지도-제작",
    "href": "exec_10.html#인터랙티브-지도-제작",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n3 인터랙티브 지도 제작",
    "text": "3 인터랙티브 지도 제작\n위에서 사용한 plotly 패키지의 ggplotly() 함수를 활용하면 반응형 지도를 생성할 수 있다. 앞의 코드 둘째 줄에 aes()에 text = name_long이 설정되어 있는데, 마우스로 국가를 가리킬 때 이름이 나타날 수 있게 조치한 것이다.\n\nlibrary(plotly)\nggplotly(world_map)\n\n\n\n\n\n지도 위에서 plotly 가 제공하는 다양한 기능을 적용해 볼 필요가 있다. 인터랙티브 그래프에 비해 인터랙티브 지도의 유용성이 더 높아 보인다.\n우리나라 지도는 다른 방식으로 반응형으로 만들어 본다. 여기서는 ggiraph 패키지를 사용한다. 처음 사용하는 경우라면 먼저 패키지를 인스톨해야 한다. 코드의 전반부는 커서를 특정 시군구 위에 올렸을 때 나타나는 정보를 좀 더 다양하게 하려는 조치이다. 중간의 코드가 핵심인데, 찬찬히 살펴보면 그렇게 복잡하지 않다. 마지막은 완전히 지엽적인 것인데, 커서를 특정 시군구 위에 올렸을 때 색이 회색으로 변하게 하기 위한 것이다.\n\nlibrary(ggiraph)\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = format(index, digits = 4, nsmall = 4),\n    my_tooltip = str_c(\"Name: \", SGG1_FNM, \"\\n Index: \", index)\n  )\ngg &lt;- ggplot() +\n  geom_sf_interactive(\n    data = sigungu_data, \n    aes(\n      fill = index_class, \n      tooltip = my_tooltip, \n      data_id = SGG1_FNM\n      ), \n    show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(\n    name = \"Classes\", \n    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n    values = class_color, drop = FALSE) \ngirafe(ggobj = gg) |&gt; \n  girafe_options(\n    opts_hover(css = \"fill: gray\")\n  )\n\n\n\n\n\n그러나 반응형 지도 제작에 가장 널리 쓰이는 것은 leaflet이다. leaflet은 웹 상의 반응형 지도 제작에 특화된 JavaScript 라이브러리이다. 이 라이브러리를 R에서 쓸 수 있게 도와주는 래퍼 패키지가 leaflet 패키지이다. 패키지 홈페이지가 매우 상세하게 잘 되어 있다. 숙독하기를 권한다.\n\nlibrary(leaflet)\n\n매우 단순한 인터랙티브 지도를 만들어 본다. 자신이 원하는 경위도값과 설명문으로 수정하면 된다.\n\nleaflet() |&gt; \n  addTiles() |&gt; \n  addPopups(126.955184, 37.460422, \"Sang-Il's Office\",\n            options = popupOptions(closeButton = FALSE))\n\n\n\n\n\n\n위에서 작성했던 TFR 세계지도를 leaflet 패키지의 다양한 함수와 아규먼트를 활용하여 인터랙티브 지도를 제작해 본다.\n\nworld_data &lt;- world_data |&gt; filter(!is.na(TFR))\n\nbins &lt;- c(0, 1.5, 2.1, 3, 4, 5, Inf)\npal &lt;- colorBin(\"YlOrRd\", domain = world_data$TFR, bins = bins)\nlabels &lt;- sprintf(\"&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g\",\n  world_data$name_long, world_data$TFR) |&gt; lapply(htmltools::HTML)\n\nleaflet(world_data) |&gt; \n  addProviderTiles(providers$Esri.WorldTopoMap) |&gt; \n  addPolygons(\n    fillColor = ~pal(TFR),\n    weight =  2, \n    opacity = 1,\n    color = \"white\",\n    dashArray = \"3\",\n    fillOpacity = 0.6,\n    highlightOptions = highlightOptions(\n      weight = 5,\n      color = \"#666\",\n      dashArray = \"\",\n      fillOpacity = 0.6,\n      bringToFront = TRUE),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n      textsize = \"15px\",\n      direction = \"auto\")\n  ) |&gt; \n  addLegend(\n    pal = pal, values = ~TFR, opacity = 0.6, title = NULL,\n    position = \"bottomright\"\n  )\n\n\n\n\n\n\n우리나라 시군구 단위의 인구소멸위험지수에 대한 지도를 반응형으로 만들어 본다. 여기서는 tmap을 활용한다. 해당 시군구 위에 클릭하면 지역소멸위험지수가 나타난다.\n\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = as.numeric(index)\n  )\ntmap_mode(mode = \"view\")\nmy_tmap &lt;- tm_shape(sigungu_data) + \n  tm_polygons(\n    col = \"index\",\n    palette = class_color, \n    breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n    labels = c(\"&lt; 0.2\", \"0.2~0.5\", \"0.5~1.0\", \"1.0~1.5\", \"&gt;= 1.5\"),\n    title = \"Classes\", \n    popup.vars=c(\"지역소멸위험지수: \" = \"index\"), \n    popup.format = list(index = list(digits = 3)), \n    id = \"SGG1_FNM\", \n    alpha = 0.6, \n    border.alpha = 0.5\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 2)\nmy_tmap\n\n\n\n\n\ntmap_save(my_tmap, \"지방소멸위험지수.html\")",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: 지리공간적 시각화"
    ]
  },
  {
    "objectID": "lab_09_2025.html",
    "href": "lab_09_2025.html",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "",
    "text": "여기서는 대시보드의 구성 요소로 활용할 수 있는 다양한 시각화 기법을 익힌다. 우리는 지금까지 도표(차트, 플롯, 그래프, 테이블)를 중심으로 데이터 시각화 기법을 다루었다. 특히 ggplot2 패키지는 이러한 과정에서 핵심적인 역할을 했다. 그런데 지금까지의 모든 도표는 정적(static) 이라는 특징이 있다. 많은 경우 도표는 정적으로 표현될 수 밖에 없으며, 또한 많은 경우 도표는 정적인 것으로 충분하며, 어떤 경우에는 동적인 것보다 더 낳다.\n소통을 위한 시각화 재료로서 정적인 도표가 가지는 절대적인 중요성에도 불구하고, 상호작용성(interactivity)과 생동감(animatedness)이 부가된 도표는 어떤 상항에서는 소통의 본질적 가치를 고양하는데 많은 도움을 줄 수 있다.\n먼저, Quarto Document를 만들고 YAML 해더를 작성한다.\n---\ntitle: \"Interactive Visualizetion\"\nauthor: Your_Name\nformat: \n  dashboard:\n    scrolling: true\ntheme: cosmo\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\ngapminder 데이터를 실습의 여러 곳에서 활용할 것이다. 우선 tidyverse와 gapminder패키지를 불러온다.\n\nlibrary(tidyverse)\nlibrary(gapminder)",
    "crumbs": [
      "R 실습: 2025/2",
      "소통하기: 인터랙티브 시각화"
    ]
  },
  {
    "objectID": "lab_09_2025.html#개요",
    "href": "lab_09_2025.html#개요",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "",
    "text": "여기서는 대시보드의 구성 요소로 활용할 수 있는 다양한 시각화 기법을 익힌다. 우리는 지금까지 도표(차트, 플롯, 그래프, 테이블)를 중심으로 데이터 시각화 기법을 다루었다. 특히 ggplot2 패키지는 이러한 과정에서 핵심적인 역할을 했다. 그런데 지금까지의 모든 도표는 정적(static) 이라는 특징이 있다. 많은 경우 도표는 정적으로 표현될 수 밖에 없으며, 또한 많은 경우 도표는 정적인 것으로 충분하며, 어떤 경우에는 동적인 것보다 더 낳다.\n소통을 위한 시각화 재료로서 정적인 도표가 가지는 절대적인 중요성에도 불구하고, 상호작용성(interactivity)과 생동감(animatedness)이 부가된 도표는 어떤 상항에서는 소통의 본질적 가치를 고양하는데 많은 도움을 줄 수 있다.\n먼저, Quarto Document를 만들고 YAML 해더를 작성한다.\n---\ntitle: \"Interactive Visualizetion\"\nauthor: Your_Name\nformat: \n  dashboard:\n    scrolling: true\ntheme: cosmo\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\ngapminder 데이터를 실습의 여러 곳에서 활용할 것이다. 우선 tidyverse와 gapminder패키지를 불러온다.\n\nlibrary(tidyverse)\nlibrary(gapminder)",
    "crumbs": [
      "R 실습: 2025/2",
      "소통하기: 인터랙티브 시각화"
    ]
  },
  {
    "objectID": "lab_09_2025.html#임베딩",
    "href": "lab_09_2025.html#임베딩",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n1 임베딩",
    "text": "1 임베딩\n동적, 반응형 시각화를 직접 제작하는 과정을 배우기 전에 대시보드에 동적, 반응형 시각화를 실현하는 가장 쉬운 방법은 동적, 반응형 시각화가 구현되어 있는 웹사이트를 대시보드에 불러오는 것일 것이다. 이것을 임베딩(embedding)이라고 하는데, HTML의 iframe 태그를 사용한다.\n통계청의 통계놀이터는 다양한 주제에 대해 동적, 반응형 시각화를 제작하여 이용자들에게 제공하고 있다. 해당 홈페이지의 [비주얼 통계]에서 “우리나라 출생아 수와 합계 출산율의 변화”를 검색하면 동적, 반응형 시각화가 구현된 웹페이지를 볼 수 있다. [공유]를 눌러 URL을 복사하고, 아래와 같은 코드를 Quarto 문서에 삽입하면 해당 웹페이지를 임베딩할 수 있다. src=\"\" 부분에 복사한 URL를 붙여 넣는다는 것을 쉽게 알 수 있을 것이다. 여기에 다른 URL을 교체해 넣으면 대부분의 웹사이트를 임베딩할 수 있는데, 임베딩이 불가능하게 막아 뒀거나 광고가 많이 붙어 있는 웹사이트는 잘 안된다. style=\"\" 부분을 적절히 수정하면 임베딩된 웹사이트의 외견을 바꿔볼 수 있다.\n&lt;iframe src=\"https://kosis.kr/edu/share.do?shareID=S0500_16\" \nloading=\"lazy\" style=\"width: 100%; height: 600px; border: \n0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;\n\n\n\n\nOur World in Data는 아름다운 인터랙티브 시각화 자료를 제공하는 것으로 유명하다. 심지어 [공유] 버턴을 눌렀을 때 &lt;/&gt; Embed 라는 옵션이 나타나는 데, 이것을 누르면 위와 같은 iframe 태그 내용이 그대로 나타나기 때문에 복사하여 붙이기만 하면 된다. Chart 탭 뿐만 아니라 Table 탭과 Map 탭도 있으니 눌러서 내용을 확인할 수 있다. 아마도 ECharts 자바스크립트 라이브러리를 사용한 것으로 보인다.\n&lt;iframe src=\"https://ourworldindata.org/grapher/child-mortality?time=earliest..latest&tab=chart\" \nloading=\"lazy\" style=\"width: 100%; height: 600px; border: 0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;\n\n\n\n\n\n\n그림 1: 임베딩 사례: Our World in Data\n\n\nOur World in Data에서 제공하는 다양한 인터랙티브 시각화 자료를 임베딩하는 절차를 요약하면 다음과 같다.\n\nOur World in Data에 접속한다.\n첫 화면의 하단에 있는 ’Data explorers’의 네 개 박스로 이동한다. 인구 관련 데이터에 관심이 있다면 ’Population & Demography’를 선택한다.\n’Population & Demography Data Explorer’에서 제공된 다양한 옵션을 이용해 원하는 인터랙티브 시각화 자료를 완성한다.\n‘Share’를 클릭하고’&lt;/&gt; Embed’를 선택한 후 URL을 복사한다. 흥미로운 점은 위에서 어떤 옵션을 어떻게 설정했느냐에 따라 URL이 달라진다는 사실이다.\niframe 태그의 “src=”에 붙여 넣어 임베딩을 완수한다.",
    "crumbs": [
      "R 실습: 2025/2",
      "소통하기: 인터랙티브 시각화"
    ]
  },
  {
    "objectID": "lab_09_2025.html#테이블",
    "href": "lab_09_2025.html#테이블",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n2 테이블",
    "text": "2 테이블\n우리는 지금까지 테이블(table)의 중요성에 대해 거의 다루지 않았다. 그러나 상호작용형 테이블 혹은 대화형 테이블이 되었을 때, 많은 경우, 테이블은 가장 효과적인 정보 전달 도구가 된다. 특히, 데이터 변형하기를 통해 새로운 요약 테이블을 생성하고, 그것을 대화형으로 제시하는 것은 매우 중요한 데이터사이언스의 과정이다. 여기서는 DT 패키지를 활용하여 간단한 인터랙티브 테이블을 만들어 본다. 웹에서 인터렉티브 테이블을 생성할 수 있게 해주는 다양한 종류의 JavaScript 라이브러리가 존재한다. 예를 들어 DataTables, FlexTable, React Table 등이 있는데, DT 패키지는 DataTables를 쓸 수 있게 해주는 래퍼 패키지이다.\n\nlibrary(DT)\n\n그리고 gapminder 데이터를 datatable() 함수를 통해 불러온다. R 코드를 실행하려면 반드시 코드 청크 안에 코드를 넣어야 한다. 청크 안의 코드는 R이 인식하여 실행하고, 결과를 문서에 출력한다.\n\ndatatable(gapminder)\n\n\n\n\n\n\n결과를 좀 더 크게 보기 위해, ‘Render’ 버튼 바로 오른편에 있는 아이콘을 클릭해 ’Chunk Output in Console’를 선택할 수 있다. 결과 테이블을 이리저리 살펴본다. 언뚯 보면 View() 함수를 활용해 데이터프레임을 살펴보는 것과 유사한 것처럼 보이지만, 부가적인 기능이 제공된다.\nDT 패키지는 테이블의 상호작용성과 관련하여 몇 가지 기능을 제공한다.\n\nPagination: 페이지를 이동할 수 있는 기능\nInstant search: 즉각적인 찾기 기능(Search에 타이핑하기 시작하면 즉각적으로 검색 결과 보여줌)\nMulti-column ordering: 다중 컬럼 정렬 기능(컬럼 하나를 선택한 후 ctrl을 누른 상태에서 다른 컬럼을 선택)\nFiltering: 값을 정렬할 수 있는 기능\nEditable: 셀 값을 수정할 수 있는 기능\nButtons: 셀 숨기기, CSV, PDF, XLSX 등의 확장자로 내보내기 등을 수행하는 버튼 생성 기능\n\n그 중 몇 가지 기능을 여기에서 살펴본다. 자세한 사항은 DT 패키지 홈페이지에 잘 정리되어 있다.\n\n2.1 테이블 CSS 클래스\ndatatable() 함수의 class 인수를 통해 테이블의 외관을 바꿀 수 있다. 다음과 같은 옵션이 가능하다.\n\n\n\n\n\n\nClass name\nDescription\n\n\n\ndisplay\n\nstripe, hover, row-border, order-column을 동시 적용한 디폴트\n\n\ncell-border\n모든 셀의 상하좌우에 경계선 표시\n\n\ncompact\n여백 축소\n\n\nhover\n마우스의 위치에 따라 점멸 효과\n\n\nnowrap\n줄바꿈 없이 텍스트 표시\n\n\norder-column\n정렬의 키가 되는 컬럼에 하이라이트 표시\n\n\nrow-border\n행별 경계선 표시\n\n\nstripe\n행을 스트라이프로 표시\n\n\n\n아래와 같이 cell-border과 compact를 함께 실행해 보고 테이블의 변화를 확인한다.\n\ndatatable(head(gapminder), class = \"cell-border compact\")\n\n\n\n\n\n\n또한 특정 컬럼의 정렬 방식(왼편, 오른편, 중앙)을 변경할 수 있다. 사용가능한 옵션은 다음과 같다.\n\n\nClass name\nDescription\n\n\n\ndt[-head|-body]-left\n왼편 정렬\n\n\ndt[-head|-body]-center\n가운데 정렬\n\n\ndt[-head|-body]-right\n오른편 정렬\n\n\ndt[-head|-body]-justify\n양쪽 맞춤\n\n\ndt[-head|-body]-nowrap\n줄바꿈 없는 맞춤\n\n\n\n아래는 첫 번째와 두 번째 컬럼(country, continent)의 내용(body)을 가운데 정렬로 나타낸다.\n\ndatatable(head(gapminder),\n          options = list(\n            columnDefs = list(list(className = \"dt-body-center\", targets = 1:2))\n          ))\n\n\n\n\n\n\n2.2 테이블 에디팅\neditable 인수를 통해 테이블의 값을 수정할 수 있게 만들 수 있다. 테이블의 특정 셀에 더블클릭하면 수정할 수 있다.\n\ndatatable(head(gapminder), editable = \"cell\")\n\n\n\n\n\n\n2.3 컬럼 필터\n다음과 같은 방식으로 필터를 설정할 수 있다.\n\ndatatable(gapminder, filter = \"top\", \n          options = list(\n            pageLength = 5, \n            autoWidth = TRUE\n          ))\n\n\n\n\n\n\n2.4 버튼 기능\nextenstion에 Buttons, dom에 Bftip, buttons에 c(\"copy\", \"excel\", \"pdf\", \"print\")를 입력하면 버튼 기능을 활성화할 수 있다. 각 인수가 무엇을 의미하는지는 다음의 웹사이트를 참고할 수 있다.\n\ndatatable(gapminder, filter = \"top\",\n          extensions = \"Buttons\",\n          options = list(\n            pageLength = 5,\n            autoWidth = TRUE,\n            dom = \"Bfrtip\",\n            buttons = c(\"copy\", \"excel\", \"pdf\", \"print\")\n          ))",
    "crumbs": [
      "R 실습: 2025/2",
      "소통하기: 인터랙티브 시각화"
    ]
  },
  {
    "objectID": "lab_09_2025.html#그래프",
    "href": "lab_09_2025.html#그래프",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n3 그래프",
    "text": "3 그래프\n\n3.1 인터랙티브 그래프\n인터랙티브 시각화 도구로 최근 널리 각광을 받고 있는 Plotly이다. Plotly는 사실 캐나다 퀘백에 본사를 두고 있는 데이터 시각화 전문 회사 이름이다. 그러나 보통 데이터 시각화용 JavaScript 라이브러리를 일컽는다. 이 라이버러리는 다양한 오픈소스 프로그래밍 언어에서 사용가능하며(이기준 2023), R의 랩퍼 프로그램이 plotly 패키지이다.\n\nlibrary(plotly)\n\ngapminder 데이터를 이용하여 간단한 그래프를 그려보자. 문법이 ggplot2와 크게 다르지 않음을 알 수 있다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  plot_ly(x = ~gdpPercap, y = ~lifeExp, color = ~continent,\n          text = ~paste(\"Country: \", country, \n                        \"&lt;br&gt;GDP per capita: \", gdpPercap, \n                        \"$&lt;br&gt;Life Expectancy at Birth:\", lifeExp))\n\n\n\n\n\n\n줌(zoom), 팬(pan), 박스 선택(box select), 라소 선택(Lasso select), 줌인(zome in), 줌 아웃(zoom out) 등과 같은 상호작용 기능을 확인할 수 있다. 또 그래프 상의 데이터 포인트 위에 마우스를 올리면 text 인수를 통해 설정한 내용을 볼 수 있다. 그리고 범례를 클릭하면 특정 continent의 국가를 나타나지 않게 할 수 있다.\n이와 같이 plotly 패키지를 직접 사용하면 다양한 기능을 활용할 수 있겠지만, plotly 패키지가 제공하는 ggplotly() 함수를 활용하면 ggplot2로 만들어진 그래프를 단숨에 plotly 그래프로 바꿀 수 있다. 물론 정확히 같지는 않다.\n\nP &lt;- gapminder |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() + \n  scale_color_brewer(palette = \"Set2\") +\n  theme_minimal()\nggplotly(P)\n\n\n\n\n\n\n다음 예제 역시 반응형이지만 바로 다음에서 다룰 동적인 특성도 동시에 가지고 있는 그래프를 만드는 것이다. 역시 plotly 패키지를 이용한다.\n\ngapminder |&gt; \n  plot_ly(x = ~log10(gdpPercap), y = ~lifeExp,\n          text = ~paste(\"Country: \", country)) |&gt; \n  add_markers(color = ~continent, size = ~pop, frame = ~year, \n              marker = list(sizeref = 0.2, sizemode = \"area\"))\n\n\n\n\n\n\n하단에 있는 ‘Play’ 버튼을 누르면 연도에 따라 그래프가 바뀌면서 동적인 효과가 나타나게 된다.\n\n3.2 애니메이션 그래프\n이 실습에서는 gganimate 패키지를 활용하여, 움직이는 그래프를 만드는 방법을 익히도록 한다. 물론 움직인다고 해서 인터랙티브한 그래프인 것은 아니다. gganimate 패키지를 설치한 후 불러온다.\n\nlibrary(gganimate)\n\n우선 정적인 그래프를 그린다.\n\nP &lt;- gapminder |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, color = continent)) +\n  geom_point(show.legend = FALSE, alpha = 0.7) +\n  scale_x_log10() +\n  scale_size(range = c(2, 12))\nP\n\n\n\n\n\n\n\n이 그래프는 두 변수 간에 양적인 관련성이 있다는 사실은 명백히 보여주지만, 데이터 변형의 측면에서는 잘못된 것이다. 모든 연도(1952~2007년간 5년 단위)가 나타나 있어서 한 국가가 그래프에 12번 등장한다.\n이를 해결하기 위해 ggplot2 패키지의 facet_wrap() 함수를 활용한다.\n\nP + facet_wrap(~year)\n\n\n\n\n\n\n\n이 그래프는 두 변수간의 양적인 상관관계가 12개 모두의 연도에서 나타난다는 사실을 명확히 보여준다. 그러나 그래프를 세세히 살펴보면 알 수 있듯이, 두 변수의 관련성이라는 측면에서 개별 국가가 시간의 흐름에 따라 어떻게 변화해 나가는지에 대한 사항을 파악하기는 매우 어렵다.\ngganimate 패키지의 transition_time() 함수를 활용하여 동적인 그래프를 작성해 본다.\n\nP + transition_time(year) +\n  labs(title = \"Year: {frame_time}\")\n\n\n\n\n\n\n\n대륙별로 분할하여 표현할 수도 있다.\n\nP + facet_wrap(~continent) +\n  transition_time(year) +\n  labs(title = \"Year: {frame_time}\")\n\n\n\n\n\n\n\n움직임을 조금 더 역동적이게 만들어 볼 수 있다.\n\nP + transition_time(year) +\n  labs(title = \"Year: {frame_time}\") +\n  shadow_wake(wake_length = 0.1, alpha = FALSE)\n\n\n\n\n\n\n\n그래프를 저장하고 싶으면 anim_save() 함수를 활용할 수 있다. ggsave() 함수와 동일한 문법을 갖는다.",
    "crumbs": [
      "R 실습: 2025/2",
      "소통하기: 인터랙티브 시각화"
    ]
  },
  {
    "objectID": "exec_02.html",
    "href": "exec_02.html",
    "title": "R과 데이터사이언스 과정",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 전 과정을 개괄적으로 이해하도록 한다. 특히 그림 1 에 나타나 있는 데이터사이언스 과정 중 특히 네 부분, 데이터 불러오기(importing), 정리하기(tidying), 변형하기(transforming), 시각화하기(visualizing)에 초첨을 둔다. 보통 데이터 정리하기와 변형하기를 합쳐 ’데이터와 씨름하기(data wrangling)’이라고 부르고, 변형하기와 시각화하기를 합쳐 ’데이터 탐색하기(data exploration)’라고 한다. 데이터를 살펴보기 위해 모델링을 사용하는 경우, 일부 모델링하기도 탐색하기에 포함되는 것으로 볼 수도 있다.\n\n\n\n\n\n그림 1: 데이터사이언스의 과정(https://r4ds.hadley.nz/intro.html)\n\n\n데이터사이언스의 다양한 과업을 수행하기 위해 Base R의 함수들이 사용되고 있지만, 보통은 이와 함께 다양한 패키지(package)들이 널리 사용되고 있다. 따라서 본 실습에서는 우선 패키지의 사용과 관련된 부분을 다루고 뒤를 이어 데이터사이언스의 네 과제가 어떻게 이루어지는지 대략적으로 다룰 것이다.\n\n패키지와 tidyverse\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#개요",
    "href": "exec_02.html#개요",
    "title": "R과 데이터사이언스 과정",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 전 과정을 개괄적으로 이해하도록 한다. 특히 그림 1 에 나타나 있는 데이터사이언스 과정 중 특히 네 부분, 데이터 불러오기(importing), 정리하기(tidying), 변형하기(transforming), 시각화하기(visualizing)에 초첨을 둔다. 보통 데이터 정리하기와 변형하기를 합쳐 ’데이터와 씨름하기(data wrangling)’이라고 부르고, 변형하기와 시각화하기를 합쳐 ’데이터 탐색하기(data exploration)’라고 한다. 데이터를 살펴보기 위해 모델링을 사용하는 경우, 일부 모델링하기도 탐색하기에 포함되는 것으로 볼 수도 있다.\n\n\n\n\n\n그림 1: 데이터사이언스의 과정(https://r4ds.hadley.nz/intro.html)\n\n\n데이터사이언스의 다양한 과업을 수행하기 위해 Base R의 함수들이 사용되고 있지만, 보통은 이와 함께 다양한 패키지(package)들이 널리 사용되고 있다. 따라서 본 실습에서는 우선 패키지의 사용과 관련된 부분을 다루고 뒤를 이어 데이터사이언스의 네 과제가 어떻게 이루어지는지 대략적으로 다룰 것이다.\n\n패키지와 tidyverse\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#패키지와-tidyverse-패키지",
    "href": "exec_02.html#패키지와-tidyverse-패키지",
    "title": "R과 데이터사이언스 과정",
    "section": "\n1 패키지와 tidyverse 패키지",
    "text": "1 패키지와 tidyverse 패키지\n\n1.1 패키지\n패키지는 유사한 과업을 수행하는데 도움을 주는 함수들의 묶음 정도로 정의할 수 있다. 현재 CRAN(The Comprehensive R Archive Network)에는 20,000개 정도의 패키지가 등록되어 있다고 한다. CRAN에 패키지를 등록하는게 쉽지 않은 일이기 때문에 GitHub과 같은 곳을 통해 접근 가능한 패키지까지 합치면 도대체 몇 개의 R 패키지가 세상에 존재하는지 알기 어렵다.\n패키지를 사용하기 위해서는 해당 패키지가 사용자의 디바이스에 물리적으로 인스톨되어 있어야 하고, R 세션에서 패키지를 불러와야 한다. 패키지를 인스톨하는 방법은 두 가지 이다. 스크립트 내에서 패키지를 반복해서 인스톨하는 것은 합리적이지 않기 때문에 전자의 관행을 추천한다.\n\nOutput 창의 Packages 탭 선택: Install 아이콘을 클릭하고 패키지 이름 입력\n스크립트 내에서 인스톨하기: install.packages(\"패키지명\")\n\n쌍따옴표 속에 패키지 이름을 타이핑해야 한다. 한번 인스톨이 되면 업데이트하지 않는 한 새롭게 패키지를 인스톨할 필요가 없다. 인스톨된 패키지를 사용하려면 스크립트 내에서 다음과 같이 타이핑하고 실행한다.\n\nlibrary(패키지명)\n\n괄호 속에 패키지명을 기입해야 한다.\n\n\n\n\n\n\n노트\n\n\n\n\n\ninstall.packages()함수에서는 반드시 패키지명을 쌍따옴표로 싸야하지만, library()함수에서는 그렇지 않다. 불러온 패키지는 R 세션이 유지되는 동안 내내 사용할 수 있지만, R 세션을 끝내고 다시 시작하면 다시 library()함수를 이용해 다시 불러와야 한다. 그래서 R 스크립트 파일의 시작 부분에는 패키지를 불러오는 코드를 위치시키고, 다시 스크립트 파일을 열 때마다 그 부분을 재실행하는 것이 좋은 습관이다.\n\n\n\n\n1.2 tidyverse 패키지\n데이터사이언스 과정의 각 단계는 특징적인 과업으로 구성되어 있고, 거기에 맞춰 특징적인 함수들을 장착한 패키지들이 개발되어 왔다. 그런데 최근 RStudio는 데이터사이언스와 밀접히 관련된 패키지들을 모아 일종의 엄브렐러 패키지인 tidyverse를 만들어 제공하고 있다. tidyverse 패키지는 패키지의 패키지인데, 핵심적인 구성 패키지에 다음과 같은 것들이 있다.\n\nggplot2: 시각화하기\ndplyr: 변형하기\ntidyr:정리하기\nreadr: 불러오기\ntibble: 데이터 프레임 관련\nstringr: 문자열 처리 관련\nforcats: 범주 변수(팩터) 처리 관련\npurrr: 함수형 프로그래밍(functional programming) 관련\nlubridate: 일시 및 시간 처리 관련\n\n\n\n\n\n\n그림 2: tidyverse의 핵심 패키지(https://www.tidyverse.org/)\n\n\ntidyverse패키지를 사용하는 것의 장점은 이 패키지만 불러오면 구성 패키지까지 한꺼번에 사용할 수 있게 된다는 점이다. 스크립트 내에서 다음과 같은 코드를 실행한다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#시각화하기",
    "href": "exec_02.html#시각화하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n2 시각화하기",
    "text": "2 시각화하기\n\n2.1 데이터 살펴보기\n이 실습을 위해 남극 파머군도(Palmer Archipelago)에 서식하는 펭귄 성체의 신체 계측 데이터를 사용한다. 이 데이터는 palmerpenguins라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다.\n\nlibrary(palmerpenguins)\n\n이제 이 페키지에 포함되어 있는 penguins라는 이름의 데이터를 불러온다.\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n데이터를 자세히 살펴보면 몇 가지를 알 수 있다.\n\n티블(tibble)이라는 형식의 데이터 프레임이다. 티블은 tidyverse의 공식 데이터 프레임 포맷이다.\n관측개체는 344개, 변수는 8개이다.\nspecies, island, sex 변수의 유형은 팩트형(fctr)이고, bill_length_mm, bill_depth_mm은 실수형(dbl)이고, 나머지는 정수형(int)이다.\n\n변수가 많아지면 전체 데이터를 조망하기 어렵기 때문에, 최초의 tidyverse 함수인 glimpse()를 사용하여 데이터의 행과 열을 바꾸어 보자. 변수 위주로 데이터를 개관하고자 할 때 매우 유용하다.\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\n\n\n\n\n힌트\n\n\n\npenguins데이터 내 속성들에 대한 설명을 보고싶다면 Console에 help(penguins) 또는 ?penguins를 입력한 뒤 실행한다.\n\n\n\n2.2 그래프 만들기\n이 penguins 데이터와 ggplot2 패키지를 이용하여 “펭귄의 날개 길이와 몸무게의 관계”를 표현하는 그래프를 작성해 보자. ggplot2의 문법에 대한 사항은 따로 공부할 기회가 있으므로 여기서는 제작 과정을 한 번 따라가 본다.\n\n2.2.1 플롯 객체의 지정\nggplot()이라는 함수를 통해 플롯 제작을 개시하는 단계이며, 어떤 데이터를 사용할지를 지정한다.\n\nggplot(data = penguins)\n\n\n\n\n\n\n\n\n2.2.2 플롯의 시각속성 매핑\n데이터가 어떤 시각속성(aesthetics)으로 표현될 것인가를 지정한다. 여기서는 간단히 어떤 변수들이 x-축과 y-축에 나타나는지만 지정한다. mapping = aes() 아규먼트가 핵심이다. 보통 mapping은 생략하고 aes()만 쓴다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n\n\n\n\n\n\n\n2.2.3 플롯의 기하객체 지정\n데이터가 어떤 기하객체(geometric object)로 표현될 것인가 혹은 어떤 그래프 유형으로 표현될 것이가를 지정한다. geom 아규먼트가 핵심인데, geom_point()는 데이터를 포인트라고 하는 기하객체로 표현한다는 것을 지정한 것으로 결국 산포도(scatterplot)라는 그래프 유형을 산출하게 된다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n2.2.4 시각속성의 첨가\n이러한 관련성이 펭귄의 종족에 따라 다르게 나타나는지를 탐색하기 위해 color 라는 시각속성을 species라는 변수에 적용한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n2.2.5 기하객체 레이어의 첨가\n두 변수의 관련성을 보여주는 선형 기하객체를 첨가한다. 여기서는 geom_smooth()를 이용하여 OLS 회귀선을 첨가한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n2.2.6 라벨링 등 마무리 작업\nlabs()를 이용하여 그래프의 제목(title), 부제목(subtitle), 축이름, 범례 표제 등을 지정한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\"\n  )",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#변형하기",
    "href": "exec_02.html#변형하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n3 변형하기",
    "text": "3 변형하기\n변형하기와 관련된 함수들은 대부분 dplyr 패키지에 포함되어 있다.\n\n3.1 데이터 살펴보기\n이 실습을 위해 미국 교통통계국(U.S. Bureau of Transportation)이 제공하는 데이터를 사용하는데, 이것은 2013년 한 해 동안 미국 뉴욕시를 출발한 336,776대의 항공기에 대한 정보를 담고 있다. 이 데이터는 nycflights13 이라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다. 그리고 나서 패키지에 포함되어 있는 flights라는 이름의 데이터를 불러온다.\n\nlibrary(nycflights13)\nglimpse(flights)\n\nRows: 336,776\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n\n\n\n\n\n\n힌트\n\n\n\nflights데이터 내 속성들에 대한 설명을 보고싶다면 Console에 help(flights) 또는 ?flights를 입력한 뒤 실행한다.\n\n\n\n3.2 주요 함수\n여기서는 가장 널리 사용되는 6개 함수에 대해서만 개략적으로 다룬다. 그 6개 함수는 select(), filter(), arrange(), mutate(), group_by(), summerize()이다. 조교의 도움을 받아 각 함수가 무슨 일을 한 것인지 이해한다.\n\n3.2.1 select() 함수\n열(변수) 중 일부를 솎아낸다. 즉, 변수의 갯수를 줄인다.\n\nselect(flights, year, month, day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\n\n3.2.2 filter() 함수\n특정 열(변수)에 의거해 조건을 만족하는 행을 솎아낸다. 즉 관측개체의 갯수를 줄인다.\n\nfilter(flights, month == 1 & day == 1)\n\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.3 arrange() 함수\n특정 열(변수)에 의거해 행의 순서를 바꾼다.\n\narrange(flights, year, month, day)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.4 mutate() 함수\n기존의 열(변수)을 변형하여 새로운 열(변수)을 생성한다.\n\nmutate(flights,\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, gain &lt;dbl&gt;, speed &lt;dbl&gt;\n\n\n\n3.2.5 group_by() 함수\n열(변수)(범주형 변수, categorical variables)에 의거해 전체 행을 그룹으로 분할한다. 데이터 프레임이 내부적으로 12개의 달로 분할된다.\n\ngroup_by(flights, month)\n\n# A tibble: 336,776 × 19\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.6 summerize() 함수\n열(변수)의 통계량을 산출하여 새로운 데이터 프레임의 새로운 열(변수)에 저장한다. 모든 항공기의 평균출발지연시간을 계산한 것이다.\n\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  delay\n  &lt;dbl&gt;\n1  12.6\n\n\n위의 group_by() 함수와 결합하면, 그룹별로 열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장할 수 있다. 일단위로 평균출발지연시간을 계산한 것이다.\n\nby_day &lt;- group_by(flights, year, month, day)\nsummarize(by_day, delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day delay\n   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n 1  2013     1     1 11.5 \n 2  2013     1     2 13.9 \n 3  2013     1     3 11.0 \n 4  2013     1     4  8.95\n 5  2013     1     5  5.73\n 6  2013     1     6  7.15\n 7  2013     1     7  5.42\n 8  2013     1     8  2.55\n 9  2013     1     9  2.28\n10  2013     1    10  2.84\n# ℹ 355 more rows",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#정리하기",
    "href": "exec_02.html#정리하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n4 정리하기",
    "text": "4 정리하기\n정리하기와 관련된 함수들은 대부분 tidyr 패키지에 포함되어 있다. 많은 함수가 있지만 가장 중요한 두 개의 함수에만 집중한다.\n\n4.1 데이터 살펴보기\n이 실습에서는 tidyverse 패키지에 포함되어 있는 매우 단순한 데이터를 사용한다. 이 두 데이터는 정돈된 데이터(tidy data)가 아니다. 정돈된 데이터가 무엇인지에 대해서는 다음 장에서 다룬다. 여기서는 정돈되지 않은 데이터를 정돈된 데이터로 만드는 과정을 맛본다.\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n\n\n\n4.2 주요 함수\n\n4.2.1 pivot_longer() 함수\ntable4a에서 1999과 2000은 변수명일 수 없다. year라는 변수의 속성이어야 한다.\n\npivot_longer(\n  table4a, \n  cols = c(`1999`, `2000`),\n  names_to = \"year\",\n  values_to = \"cases\"\n)\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\n\n4.2.2 pivot_wider() 함수\ntable2에서 type 변수는 두 개의 변수명을 포함하고 있다. 즉, cases와 population은 속성값이라기 보다는 변수명이다.\n\npivot_wider(\n  table2, \n  names_from = \"type\",\n  values_from = \"count\"\n)\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#불러오기",
    "href": "exec_02.html#불러오기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n5 불러오기",
    "text": "5 불러오기\n불러오기와 관련된 함수들은 대부분 readr 패키지에 포함되어 있다. 여러 유형의 파일을 불러오기 위해 여러 함수가 존재하지만, 콤마분리값(comma-separated values, CSV) 형식의 데이터를 불러오는 함수(read_csv())만 실습한다.\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\nglimpse(students)\n\nRows: 6\nColumns: 5\n$ `Student ID`   &lt;dbl&gt; 1, 2, 3, 4, 5, 6\n$ `Full Name`    &lt;chr&gt; \"Sunil Huffmann\", \"Barclay Lynn\", \"Jayendra Lyne\", \"Leo…\n$ favourite.food &lt;chr&gt; \"Strawberry yoghurt\", \"French fries\", \"N/A\", \"Anchovies…\n$ mealPlan       &lt;chr&gt; \"Lunch only\", \"Lunch only\", \"Breakfast and lunch\", \"Lun…\n$ AGE            &lt;chr&gt; \"4\", \"5\", \"7\", NA, \"five\", \"6\"",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_02.html#파이프-연산자pipe-operator",
    "href": "exec_02.html#파이프-연산자pipe-operator",
    "title": "R과 데이터사이언스 과정",
    "section": "\n6 파이프 연산자(pipe operator)",
    "text": "6 파이프 연산자(pipe operator)\n우리는 이전 실습에서 할당 연산자(&lt;-)에 대해 배웠다. 오늘 살펴본 다양한 변형의 결과를 다른 데이터 프레임에 담고 싶으면 다음과 같이 할당 연산자를 사용할 수 있다.\n\nflights_day1 &lt;- filter(flights, month == 1 & day == 1)\nglimpse(flights_day1)\n\nRows: 842\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n앞으로 할당 연산자보다 훨씬 더 빈번하게 사용하게 될 연산자를 소개하려고 한다. 그것은 파이프 연산자(pipe operator)라는 것으로, %&gt;% 혹은 |&gt;로 표시하는 것이다. 원래 이 연산자의 원리는 magrittr 패키지에서 처음 소개되었는데, 차츰 R 커뮤니티에 파급되더니 급기야는 대세로 자리잡았다. 그래서 특정 패키지를 깔지 않아도 파이프 연산자를 사용할 수 있게 하기 위해 Base R에 도입되었고(이것을 네이티브 파이프 연산자(native pipe operator)라고 부른다), 부호로 %&gt;% 대신 |&gt;를 사용한다. 둘 사이에 차이는 거의 없지만, 후자가 점점 표준이 되고 있기 때문에 본 수업에서는 그것을 사용한다. 다음의 두 가지에 유의한다.\n\n현재 RStudio의 디폴트는 %&gt;%로 설정되어 있다. 이것을 Tools &gt; Global Options &gt; Code에 가서 ’Use native pipe operator, |&gt; (requires R 4.1+)’를 선택해 주어야 한다. 아래의 그림 3 를 참고하라.\n\n\n\n\n\n\n그림 3: 파이프 연산자(https://r4ds.hadley.nz/data-transform)\n\n\n\n단축키는 Crtl + Shift + M이다. 다른 건 몰라도 이 단축키만은 반드시 기억해야 한다.\n\n다음의 세 코드를 비교해 보라. 우선 아래의 경우는 flights1과 flights2와 같은 중간 변수가 계속 생성되어 메모리를 차지하게 된다.\n\nflights1 &lt;- filter(flights, dest == \"IAH\")\nflights2 &lt;- mutate(flights1, speed = distance / air_time * 60)\nflights3 &lt;- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n혹은 다음과 같이 함수가 다른 함수 속에 계속 포함되는 형식으로 만들 수 있는데, 코드가 매우 복잡해 진다.\n\narrange(\n  select(\n    mutate(\n      filter(\n        flights, \n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n다음은 위 두 경우와 달리 파이프 연산자를 사용한 경우이다. 동일한 결과를 가져다 주지만 훨씬 더 간결하고 직관적이고 이해하기 쉽다. 파이프 연산자의 사용 원리는 뒤에서 자세히 배운다.\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  mutate(speed = distance / air_time * 60) |&gt; \n  select(year:day, dep_time, carrier, flight, speed) |&gt; \n  arrange(desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows",
    "crumbs": [
      "R과 데이터사이언스",
      "R과 데이터사이언스 과정"
    ]
  },
  {
    "objectID": "exec_03.html",
    "href": "exec_03.html",
    "title": "소통하기: Quarto로 대시보드 만들기",
    "section": "",
    "text": "여기서는 데이터사이언스 과정의 ‘소통(communication)’ 단계 혹은 ’데이터로 소통하기’를 위한 핵심 도구로서의 Quarto를 다룬다. 그리고 더 나아가 Quarto를 활용해 대시보드를 만드는 과정에 대해 설명한다.\n\n\n\n\n\n\n힌트\n\n\n\nQuarto는 한글로 ’쿼토’라고 읽는다.",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: Quarto로 대시보드 만들기"
    ]
  },
  {
    "objectID": "exec_03.html#개요",
    "href": "exec_03.html#개요",
    "title": "소통하기: Quarto로 대시보드 만들기",
    "section": "",
    "text": "여기서는 데이터사이언스 과정의 ‘소통(communication)’ 단계 혹은 ’데이터로 소통하기’를 위한 핵심 도구로서의 Quarto를 다룬다. 그리고 더 나아가 Quarto를 활용해 대시보드를 만드는 과정에 대해 설명한다.\n\n\n\n\n\n\n힌트\n\n\n\nQuarto는 한글로 ’쿼토’라고 읽는다.",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: Quarto로 대시보드 만들기"
    ]
  },
  {
    "objectID": "exec_03.html#quarto-입문",
    "href": "exec_03.html#quarto-입문",
    "title": "소통하기: Quarto로 대시보드 만들기",
    "section": "\n1 Quarto 입문",
    "text": "1 Quarto 입문\n\n1.1 Quarto란?\nQuarto는 “과학적, 기술적 출판을 위한 오픈소스 시스템(an open-source scientific and technical publishing system)”으로 정의되는데, 다양한 형식의 저작물(연구 논문, 프레젠테이션, 대시보드, 웹사이트, 블로그, 서적 등)을 다양한 디지털 포맷(HTML, PDF, MS Word, ePub 등)으로 출판할 수 있게 해준다.\nQuarto는 연구 노트, 레포트, 블로그 등을 작성할 수 있게 해준다는 측면에서 ‘개인적’ 도구이지만, 다양한 규모의 프로젝트의 원할한 진행을 도와준다는 측면에서 ‘협업’ 도구이며, 더 나아가 과학 커뮤니티 전체의 재현성(reproducibility) 고양에 도움을 줄 수 있다는 측면에서 ‘사회적’ 도구이기도 하다.\n원래 R 커뮤니티에는 유사한 기능을 수행하는 RMarkdown이라는 도구가 존재했고 여전히 많은 사람들이 사용하고 있다. Quarto는 기존의 RMarkdown에 ’통합’이라는 키워드를 적용시켜 보다 발전된 형태의 저작 시스템으로 거듭난 것이다. 우선 Quarto는 다양한 오픈소스 프로그래밍 언어에서 사용될 수 있다(R, Python, Julia, Observable). 둘째, Quarto는 출판물의 다양한 형식에 구애되지 않는 일관성있는 저작 시스템을 제공한다.\n\n\n\n\n\n그림 1: Quarto의 기본 개념(https://rstudio.github.io/cheatsheets/html/quarto.html)\n\n\nQuarto 다큐먼트의 기본 구문은 마크다운(markdown), 혹은 마크다운의 보다 특수한 형태로서의 팬독(pandoc) 마크다운이다. 마크다운 언어는 마크업(markup) 언어의 일종인데, 마크업 언어는 다큐먼트의 구조와 포맷을 관장하는 텍스트-엔코딩 시스템이다. 그런데 마크업 언어는 배우기 어렵다. 예를 들어, 대표적인 마크업 언어인 HTML은 수많은 태그의 복잡한 위계 구조를 가지고 있어 사용자 입장에서는 읽기도 어렵고, 쓰기도 어렵다. 마크다운 언어는 사용자가 보다 사용하기 쉬운 구문 구조를 제공함으로써 동일한 웹 결과물을 보다 용이하게 제작할 수 있게 도와준다. Quarto는 이러한 마크다운 언어에 기반하고 있다.\n프로그래밍 언어와의 관련성이라는 측면에서 보면, Quarto 다큐먼트는 기본적으로 워드프로세서에 프로그래밍 언어가 부가된 것으로 이해할 수 있다. 워드프로세서가 기본적으로 제공하는 텍스트 작성, 테이블 작성, 그래픽 삽입 등의 기능 외에 코드 편집, 코드 실행, 실행 결과 삽입 등의 기능이 함께 포함되어 있다. 이렇게 작성된 Quarto 다큐먼트는 .qmd라는 확장자를 갖는다. Quarto 다큐먼트를 렌더링하면 knitr 패키지가 마크다운 파일(.md)을 생성하고, pandoc이 그것들을 다양한 포맷의 산출물로 변환한다.\n\n\n\n\n\n그림 2: Quarto의 작동 방식(https://quarto.org/docs/get-started/hello/rstudio.html)\n\n\n\n1.2 Quarto 다큐먼트의 기본 구조\n그림 3 을 바탕으로 Quarto다큐먼트의 기본 구조를 설명하고자 한다. 왼쪽은 비주얼 에디터(visual editor)를 사용한 것이고, 오른쪽은 소스 에디터(source editor)를 사용한 것이다. 소스 에디터는 마크다운 구문을 그대로 사용하는 것이므로 마크다운의 기본 형식에 대한 이해가 선행되어야 한다. 이에 반해 비주얼 에디터는 마치 워드프로세서를 다루듯 메뉴 형식으로 Quarto 다큐먼트를 작성할 수 있다. 비주얼 에디터에 대해서는 뒤에서 상세히 다루기로 한다.\n\n\n\n\n\n그림 3: Quarto의 기본 구조와 비주얼 에디터\n\n\n그림 3 의 왼쪽 그림에서 보다 잘 드러나는 것처럼, Quarto 다큐먼트는 크게 세 부분으로 나뉘어진다.\n\nYAML 헤더(header)\n코드 청크(code chunk)\n마크다운 텍스트\n\n\n1.2.1 YAML 헤더\nYAML 헤더는 Quarto 다큐먼트의 최상단에 위치하는 것으로, 일종의 메타데이터로 다큐먼트의 전반적인 사항을 관장한다. YAML 헤더 부분은 세 개의 대시 부호(- - -)를 통해 다른 부분과 구분된다.\n\n\n\n\n\n\n힌트\n\n\n\nYAML은 YAML Ain’t Markup Language의 약자이며, 한글로 ’예믈’이라고 읽는다.\n\n\nYAML 헤더의 모든 요소는 기본적으로 key: value의 행태를 띤다. key는 항목이고, value는 해당 항목에 대한 옵션값이다. 위의 예에는 title, format, editor의 세 key가 사용되었는데, 제목은 “Hello, Quarto”이며, 산출 포맷은 HTML이며, Quarto 다큐먼트 작성을 비주얼 에디터를 통해 할 것이라는 점을 명시하고 있다.\n다양한 key를 설정할 수 있으며, 다음의 것들이 중요하다.\n\n\n표 1: YAML 헤더의 다양한 key\n\n\n\n\n\n\n\nkey\n설명\n\n\n\ntitle\n다큐먼트 제목\n\n\ndate\n다큐먼트 작성 날짜\n\n\nauthor\n다큐먼트 저자 이름\n\n\nformat\n다양한 포맷 관련 사항의 지정\n\n\ntoc\n목차 삽입\n\n\nnumber-section\n섹션 제목에 자동 번호 부여 여부\n\n\nexecute: echo\n소스 코드의 포함 여부를 글로벌하게 설정, 보통 true\n\n\nexecute: warning\n경고 메시지를 산출물에 나타나게 할지를 글로벌하게 설정, 보통 false\n\n\neditor\n비주얼 에디터와 소스 에디터 중 선택, 보통 visual\n\n\n\n\n\n\n\n1.2.2 코드 청크\n코드 청크는 프로그래밍 언어의 코드가 들어가는 부분이다. R를 사용하는 경우 {r}로 시작한다. 데이터 불러오기, 정리하기, 변형하기, 시각화하기, 탐색하기, 수집하기와 관련된 모든 종류의 코드가 여기에 들어갈 수 있다. 보통 하나의 Quarto 다큐먼트에 다수의 코드 정크가 포함된다. 각 코드 청크 내에서 코드를 실행할 수 있다. 한 단위씩 실행할 때는 Ctrl + Enter 단축기를 사용하지만 한 코드 청크 내 모든 코드를 실행하고자 할 때는 Ctrl + Shift + Enter 단축기를 사용한다.\n각 코드 청크의 앞 부분에 해당 코드 정크와 관련된 다양한 옵션을 #| 형태로 삽입할 수 있다. YAML 헤더에서처럼, key: value의 행태를 띤다. 가장 중요한 옵션은 코드 청크의 내용이나 실행 결과 등이 산출물에 어떻게 표현되는지를 결정하는 것들이다. 다음의 표는 코드를 실행할지의 여부, 코드를 보여줄지의 여부, 코드의 결과를 보여줄지의 여부, 생성되는 플롯을 보여줄지의 여부, 메시지나 경고문을 보여줄지의 여부 등을 관장하는 다양한 옵션을 정리한 것이다.\n\n\n표 2: 다양한 코드 청크 옵션\n\n\n\n\n\n\n\n\n\n\n\n\nOption\nRun code\nShow code\nOutput\nPlots\nMessages\nWarnings\n\n\n\neval: false\nX\n\nX\nX\nX\nX\n\n\ninclude: false\n\nX\nX\nX\nX\nX\n\n\necho: false\n\nX\n\n\n\n\n\n\nresults: hide\n\n\nX\n\n\n\n\n\nfig-show: hide\n\n\n\nX\n\n\n\n\nmessage: false\n\n\n\n\nX\n\n\n\nwarning: false\n\n\n\n\n\nX\n\n\n\n\n\n\n\n1.2.3 마크다운 텍스트\n워드프로세서처럼 텍스트를 작성한다. 섹션 헤더, 하이퍼링크(hyperlink), 이미지 등을 지정할 수 있고, 인라인 코드 청크(inline code chunk)도 삽입할 수 있다. 마크다운 텍스트의 작성에 비주얼 에디터는 큰 역할을 한다. 비주얼 에디터는 마크다운 언어의 사용자 편이성을 한번 더 강화한 것으로 볼 수 있다.\n비주얼 에디터는 다음의 메뉴로 구성된다. 워드프로세서와 비슷한 형태를 가지고 있음을 알 수 있다. 많이 사용되는 기능은 아이콘을 통해 전면에 배치되어 있다.\n\n\n\n\n\n그림 4: 비주얼 에디터의 메뉴바\n\n\n포맷(Format), 삽입(Insert), 테이블(Table) 메뉴 속에 다양한 하위 기능들이 포함되어 있다. Quarto를 마스트하는데 비주얼 에디터의 기능을 숙달하는 것이 필수적이다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n그림 5: 비주얼 에디터의 메뉴 구성\n\n\n\n1.3 기본 Quarto 다큐먼트의 작성\n\n1.3.1 새 Quarto 다큐먼트 열기\nFile &gt; New File &gt; Quarto Document를 실행한다. Title과 Author란에 적절한 텍스트를 기입하고 아래에 위치한 Create 버튼을 클릭한다.\n\n\n\n\n\n1.3.2 Quarto 다큐먼트의 작성\n비주얼 에디터를 통해 아래와 같은 결과물이 나오도록 Quarto 다큐먼트를 작성해본다.\n\n\n\n\n\n그림 6: 렌더링 결과\n\n\n\n1.3.3 Quarto 다큐먼트의 렌더링\n아래의 그림에 나타나 있는 Render 버튼을 클릭해 다큐먼트를 실행한다. 결과는 오른편 하단의 Viewer 탭에 나타난다. 결과를 그림 6 과 비교한다. 최종적인 html은 프로젝트 파일이 들어있는 폴더에 저장되어 있다.",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: Quarto로 대시보드 만들기"
    ]
  },
  {
    "objectID": "exec_03.html#개인-블로그-만들기",
    "href": "exec_03.html#개인-블로그-만들기",
    "title": "소통하기: Quarto로 대시보드 만들기",
    "section": "\n2 개인 블로그 만들기",
    "text": "2 개인 블로그 만들기\n\n2.1 새로운 Quarto Blog 프로젝트 시작하기\n\n2.1.1 File &gt; New Project &gt; Create Project &gt; Quarto Blog를 선택한다.\n\n\n\n\n\n\n\n\n\n\n디렉토리 이름과 경로를 설정하고, 아래에 위치한 Create Project 버튼을 클릭한다.\n\n\n\n\n\n2.2 렌더링하여 결과를 살펴보기\nRender 버튼을 클릭하여 결과를 확인한다. 결과는 오른쪽 패널의 Viewer 탭에 나타난다. Viewer 탭의 Show in new window 아이콘을 클릭하면 웹브라우저 상에 결과를 나타낼 수 있다.\n\n\n\n\nFiles 탭을 클릭하면 프로젝트 폴더에 다음과 같은 파일들이 생성되어 있음을 확인할 수 있다. 각각의 파일이 어떠한 역할을 하는지 파악한다.\n\n\n표 3: Quarto Blog 프로젝트의 파일 구조\n\n\n\nFile\nDescription\n\n\n\n_quarto.yml\nQuarto 프로젝트 파일\n\n\nindex.qmd\n블로그의 홈페이지\n\n\nabout.qmd\n블로그의 어바우트 페이지\n\n\nposts/\n포스트를 포함하고 있는 폴더\n\n\nposts/_metadata.yml\n포스트가 공유하고 있는 옵션들\n\n\nstyles.css\n웹사이트의 CSS\n\n\n\n\n\n\n\n2.3 구성 요소 수정하기\n구성 요소를 수정하여 자신의 개인 블로그를 만들어 나간다.\n\n2.3.1 메타데이터\n\n블로그의 전체적인 모습은 _quarto.yml 파일에 의해 규정된다. _quarto.yml 파일의 내용을 살펴보고 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히, 25개의 테마를 살펴보고, 그 중 하나를 선택한다.\n\n2.3.2 홈페이지(home page)\n\n블로그의 홈페이지는 포스트 디렉토리에 포함되는 모든 포스트의 리스트를 제공하는 것으로 index.qmd 파일에 의해 규정된다. index.qmd 파일의 내용을 살펴보고 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히 리스팅 유형(listing types) 옵션 세개(default, table, grid)를 살펴보고, 그 중 하나를 선택한다.\n\n2.3.3 어바우트 페이지(about page)\n\n어바우트 페이지는 블로그와 블로그의 저작자에 대한 부가 정보를 제공하는 것으로 about.qmd 파일에 의해 규정된다. about.qmd 파일의 내용을 살펴보고 필요한 부분을 수정한다.\n다음의 웹사이트를 참조한다. 특히 템플릿(template) 옵션 다섯개(jolla, trestles, solana, marquee, broadside)를 살펴보고, 그 중 하나를 선택한다.\n\n2.3.4 포스트 디렉토리(posts directory)\n\n블로그의 콘텐츠는 포스트 디렉토리 속에 포함되어 있다. 기본적으로 하나의 포스트는 하나의 폴드인데, 개별 폴드 속에는 index.qmd라는 이름의 Quarto 파일이 들어 있다. 그리고 Quarto 다큐먼트에 포함되어 있는 이미지는 images라는 서브 폴드에 저장되어 있다.\n다음의 절차에 따라 새로운 포스트를 생성해 본다.\n\nposts 디렉토리 아래에 새로운 디렉토리를 생성한다. 이름은 날짜와 주제가 결합된 형태로 하면 좋다.\n새로운 디렉토리에 index.qmd 파일을 생성한다. 아래와 같이 YAML 헤더를 수정하고, 실습 1에서처럼 새로운 포스트를 작성한다.\n\n\n---\ntitle: \"I hate May\"\nauthor: \"Your Name Here\"\ndate: \"09/09/2025\"\ndate-modified: last-modified\n---\n\n\n2.4 블로그를 웹 상에 배포하기\n완성된 개인 블로그를 다음의 절차에 따라 웹에 출판한다. 여기서는 Posit에서 제공하는 무료 출판 사이트인 Quarto Pub을 활용한다.\n\nQuarto Pub에 접속하여 계정을 만든다.\nRStudio에서, 왼쪽 하단부의 Terminal 탭을 누른다.\n프롬프트에 다음과 같이 입력하고 실행한다: quarto publish quarto-pub\n\n다음을 웹사이트를 참고한다.",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: Quarto로 대시보드 만들기"
    ]
  },
  {
    "objectID": "exec_03.html#대시보드-만들기",
    "href": "exec_03.html#대시보드-만들기",
    "title": "소통하기: Quarto로 대시보드 만들기",
    "section": "\n3 대시보드 만들기",
    "text": "3 대시보드 만들기\n여기서는 Quarto를 이용해 데이터 대시보드(dashboard)를 만들어 본다. 대시보드는 단일한 주제에 대한 상호연관된 다양한 정보를 주로 그래픽 형태로 일관성 있게 제시한 것을 말한다. 일반적인 대시보드에서 결국 ’대시보드형 인터랙티브 웹 앱(web app)’을 만드는 것을 지향한다.\n\n3.1 대시보드의 기본 구조\n대시보드는 기본적으로 다섯 가지의 구성요소로 이루어진다. 각각은 메인 바디, 헤더, 내비게이터, 사이드바, 푸터이다.\n\n\n\n\n\n그림 7: 대시보드의 기본 구조(https://blog.zarathu.com/posts/2023-12-11-quarto-dashboard/#tabset)\n\n\n첫째, 메인 바디(main body)는 대시보드의 핵심 요소이다. 메인 바디는 카드(card)라고 불리는 기본 단위들로 구성된다. 개별 카드는 다양한 내용 요소(텍스트, 그래프, 표, 지도, 밸류박스 등)를 가질 수 있다. 즉, 어떤 카드 속에는 그래프가 들어가며, 어떤 카드 속에는 지도가 들어간다. 이러한 카드들은 특정한 레이아웃 요소(페이지, 행, 열, 탭셋 등)를 통해 메인 바디에 배열된다. 페이지(page)는 대시보드 레이아웃 요소 중 최상위 레벨인데, 개별 페이지는 다수의 행(row) 혹은 열(column)로 구성된다. 행 혹은 열을 또다른 행 혹은 열이 아닌 탭 클릭 방식으로 분할하고 싶을 때 탭셋(tabset)이 사용된다.\n둘째, 헤더(header)는 대시보드의 가장 중요한 메타 정보(로고, 제목, 저자 등)를 포함한다.\n셋째, 내비게이터(navigator)는 최상위 레이아웃인 페이지간 이동을 통제한다.\n넷째, 사이드바(sidebar)는 주로 사용자의 인풋(input)을 받을 때 사용되는 것으로, 동적인 대시보드에서 주로 사용된다. Quarto는 사이드바 외에 툴바(toolbar)와 카드인풋(card input)과 같은 옵션을 제공한다.\n다섯째, 푸터(footer)는 헤더와 유사한 기능을 하는데, 주로 부차적인 매타 정도를 포함한다.\n다섯개의 구성 요소 중 가장 중요한 것은 메인 바디, 해더, 내비게이터이다. Quarto는 헤더와 내비게이터를 통합한 내비게이션바(navigation bar)를 제공한다. 사이드바는 Shiny 패키지를 활용한 동적인 대시보드에서는 매우 중요하지만, 이번 실습에서는 사용하지 않는다. 푸터는 가장 지엽적인 요소이다.\n다음의 대시보드를 살펴보자.\n\n\n\n\n\n그림 8: 대시보드의 사례(https://quarto.org/docs/dashboards/)\n\n\n이 대시보드는 크게 내비게이션바와 메인 바디로 구성되어 있다. 네비게이션바에는 다음의 내용이 포함되어 있다.\n\n이 대시보드의 제목(title)은 ’고객이탈(Customer Chrun)’이고 회사 이름은 DEMOCO(로고)이다.\n이 대시보드는 모두 두 개의 페이지(page)로 구성되어 있다. 페이지의 이름은 각각 ’Churn (Standard)’과 ’Data’이다.\n\n메인 바디는 다음과 같은 레이아웃 요소들로 구성되어 있다.\n\n첫 번째 페이지(Churn (Standard))는 세 개의 행(row)으로 구성되어 있다.\n첫 번째 페이지의 첫 번째 행은 세 개의 카드(card)로 구성되어 있는데, 내용 요소는 모두 밸류박스(value box)이다.\n첫 번째 페이지의 두 번째 행은 두 개의 열(즉, 카드)로 구성되어 있는데, 내용 요소는 모두 그래프(graph)이다.\n첫 번째 페이지의 세 번째 행은 단일한 열(즉, 카드)로 구성되어 있는데, 내용 요소는 테이블(table)이다.\n두 번째 페이지에도 다양한 사항이 포함되어 있을 것이다.\n\n3.2 레이아웃 설정\n\n3.2.1 행과 열의 설정\n행(row)과 열(column)은 가장 기본이 되는 레이아웃 요소이다. 기본 원칙은 다음과 같다.\n\n헤더 2(header 2) 레벨이 행과 열의 구분을 일차적으로 결정한다.\n헤더 3(header 3) 레벨이 하위 행과 열의 구분을 이차적으로 결정한다.\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1 \n\n### Column {width=60%}\n\nCard 2-2 \n위와 같이 설정하면 다음과 같은 결과를 얻을 수 있다. Row의 경우는 {height} 태그를 통해서, Column의 경우는 {width}태그를 통해 상대적인 크기를 설정할 수 있다.\n\n\n\n\n\n그림 9: 대시보드의 행렬 구조(https://blog.zarathu.com/posts/2023-12-11-quarto-dashboard/)\n\n\n\n3.2.2 탭셋의 설정\n탭셋(tabset)은 행(row)과 열(column)을 다른 하위 행과 열이 아닌 탭의 설정을 통해 분할하고자 할 때 사용된다.\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30% .tabset}\n\n### Column\n\nCard 2-1 {width=50%}\n\n### Column\n\nCard 2-2 {width=50%}\n위와 같이 설정하면 다음과 같은 결과를 얻을 수 있다. 탭셋의 설정을 위해 {.tabset} 태그가 사용된다는 점에 주의한다.\n\n\n\n\n\n\n\n\n\n\n\n\n그림 10: 대시보드의 탭셋 구조\n\n\n\n3.2.3 페이지의 설정\n페이지(page)는 최상위 레이아웃 요소이다. 기본 원칙은 다음과 같다.\n\n헤더 1(header 1) 레벨이 페이지의 구분을 결정한다.\nQuarto에서는 페이지가 내비게이션바에 나타난다.\n\n# Page A\n\n## Row {height=70%}\n\nCard 1\n\n## Row {height=30%}\n\n### Column {width=40%}\n\nCard 2-1\n\n### Column {width=60%}\n\nCard 2-2\n\n# Page B\n\nCard 3\n위와 같이 설정하면 다음과 같은 결과를 얻을 수 있다. 페이지가 내비게이션바에서 마치 탭셋처럼 존재하는 것에 주의한다.\n\n\n\n\n\n\n\n\n\n\n\n\n그림 11: 대시보드의 페이지 구조\n\n\n\n3.3 내비게이션바와 사이드바의 설정\n\n3.3.1 내비게이션바의 설정\n내비게이션바는 헤더와 내비게이터로 구성된다. 내비게이터는 페이지가 설정된 경우에만 나타나게 된다. 여기서는 헤더에 집중하고자 한다. 대시보드 헤더는 다른 Quarto 다큐먼트와 마찬가지로 YAML 헤더를 통해 통제된다. 다음과 같은 요소들이 중요하다.\n\n제목(title): 대시보드 전체의 이름을 결정한다.\n저자(author): 만든 사람이나 관리 회사의 이름이지만, 부제로 활용되기도 한다.\n\n포맷(format): 기본 설정인 대시보드(dashboard) 하에 다양한 하위 설정이 가능하다.\n\nlogo: 로고 그림 파일을 지정하면 내비게이션바의 왼쪽 끝에 나타난다.\nnav-buttons: github이나 이메일 연결을 설정할 수 있다.\nscrolling: true 설정: 디폴트는 false인데, 레이아웃 요소들의 높이들의 합이 100%가 되도록 일괄적으로 조절된다. true로 지정하면, 개별 내용 요소의 원 크기를 그대로 살리면서 스크롤되게 디자인이 바뀐다. 둘 다를 실험해 보고 자신의 목적에 맞는 것을 고른다.\n\n\n테마(theme): 대시보드의 외관을 한꺼번에 바꿀 수 있다. 모두 25개의 부트스와치(bootswatch) 테마가 존재한다. 여러가지를 실험해 보고 자신의 취향에 맞는 것을 선정한다.\n\n3.3.2 사이드바의 설정\n사이드바(sidebar)는 {.sidebar} 태그를 통해 만들 수 있는데, 헤더 1(header 1) 레벨이므로 특정한 페이지에 종속되지 않는다. 사이드바는 주로 사용자의 투입을 받을 때 사용되기 때문에 동적인 대시보드에 주로 사용된다. 정적인 대시보드의 경우에는 텍스트를 통한 특정 정보의 제공에 사용될 수 있다.\n# {.sidebar}\nSidebar content\n위와 같이 설정하면 다음과 같은 결과를 얻을 수 있다.\n\n\n\n\n\n그림 12: 대시보드의 사이드바 구조(https://blog.zarathu.com/posts/2023-12-11-quarto-dashboard/)\n\n\n\n3.4 카드와 내용 요소\n카드(card)란 특정한 내용 요소(텍스트, 벨류박스, 테이블, 그래프, 지도 등)를 포함하고 있는, 대시보드의 가장 기본적인 단위이다. 다음의 두 가지 사항이 중요하다.\n\n카드의 제목이 중요하다. 완성된 대시보드 상에 등장하기 때문에 이해하기 쉬운 제목이 부여되어야 한다.\n내용 요소에 따라 카드를 작성하는 방법이 조금 다르다.\n\n내용 요소 제작의 세세한 사항은 아래의 “예시 대시보드 만들기”에서 확인한다.\n\n3.4.1 그래프\nQuarto는 그래프 하나를 만들어내는 코드 청크를 하나의 카드로 인식한다. 그래프 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. ggplot2와 같은 정적인 플롯 도구 뿐만 아니라 plotly와 같은 반응형 플롯 도구를 사용하여 그래프 카드를 생성한다.\n\n3.4.2 테이블\nQuarto는 테이블 하나를 디스플레이하는 코드 청크를 하나의 카드로 인식한다. 테이블 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. knitr 패키지의 kable() 함수, gt 패키지의 gt() 함수, DT 패키지의 datatable() 함수 등을 이용해 테이블 카드를 생성한다.\n\n3.4.3 지도\nQuarto는 지도 하나를 디스플레이하는 코드 청크를 하나의 카드로 인식한다. 지도 카드의 제목은 코드 청크 내의 #| title: 옵션을 통해 부여된다. ggplot2와 같은 정적인 지도 제작 도구 뿐만 아니라 leaflet과 같은 반응형 지도 제작 도구를 사용하여 지도 카드를 생성한다.\n\n3.4.4 텍스트\n일종의 텍스트 박스도 하나의 카드로 간주된다. 그래프, 테이블, 지도가 하나의 코드 청크가 하나의 카드로 인식되는데 반해 텍스트 카드는 다른 형식을 취한다. ::: {.card} div를 사용해야 하며 #| title: 옵션을 사용해 제목을 지정해야 한다.\n\n3.4.5 밸류박스\n요약적 수치를 큰 박스 속에 나타내는 것을 밸류박스(value box)라고 하는데, 코드 청크로 표현하지만 형식은 조금 다르다. #| content: valuebox라는 옵션이 반드시 포함되야 하며, 제목을 지정하기 위해 #| title: 옵션도 필요하다. 또한 리스트를 이용해 아이콘(icon), 컬러(color), 수치(value)를 지정해야 한다.\n아이콘은 부트스트랩 아이콘(bootstrap icon)이 사용된다. 적절한 아이콘을 찾고 그 이름을 icon = 옵션을 통해 설정하는 것이 중요하다.\n모든 컬러가 다 사용가능한 것은 아니다. 아래의 표를 참조하여 컬러를 설정해야 한다.\n\n\n표 4: 밸류박스의 컬러 선택\n\n\n\nColor Alias\nDefault Theme Color(s)\n\n\n\nprimary\nBlue\n\n\nsecondary\nGray\n\n\nsuccess\nGreen\n\n\ninfo\nBright Blue\n\n\nwarning\nYellow/Orange\n\n\ndanger\nRed\n\n\nlight\nLight Gray\n\n\ndark\nBlack\n\n\n\n\n\n\n\n3.5 예시 대시보드 만들기\n예시 대시보드(https://sangillee.quarto.pub/my-first-dashboard/)에 접속하여 구성을 살펴본다. 다음의 사항에 주목한다.\n\n내비게이션바에 서울대학교 로고가 있고, 오른쪽 맨 끝애 github 및 이메일 아이콘이 위치해 있다.\n대시보드가 네 개의 페이지(Intro, Graphs, Tables, Maps)로 나뉘어져 있고, 각 페이지마다 행, 열, 탭셋과 같은 레이아웃 요소들이 배치되어 있다.\n\n어떤 식으로 제작할 수 있을지 생각해 본다. 새로운 프로젝트를 생성하고 Quarto 다큐먼트를 생성한다. 아래는 해당 대시보드를 만들기 위해 사용된 코드이다. 참고하여 자신만의 대시보드를 만들어 본다.\n\n3.5.1 YAML 해더\n특히, nav-buttons: 옵션의 지정 형식에 주의한다. scrolling 옵션과 다양한 theme: 옵션을 시험해 본다.\n---\ntitle: \"My First Dashboard\"\nauthor: Sang-Il Lee\nformat: \n  dashboard:\n    logo: snu_logo_2.png\n    nav-buttons: \n      - icon: github\n        href: https://github.com/sangillee66\n        aria-label: GitHub\n      - icon: envelope\n        href: mailto:si_lee@snu.ac.kr\n        aria-label: Mail\n    # scrolling: true\ntheme: default\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n3.5.2 Intro 페이지\nIntro라는 이름의 페이지를 설정한다.\n# Intro\n첫번째 행: Text 카드\n행을 설정하고 행의 상대적인 높이(10%)를 지정한다.\n## Row {height=\"10%\"}\n텍스트 카드를 생성한다. 텍스트 카드를 생성하기 위해 {.card} 태그가 사용되어야 하며, 텍스트 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다.\n::: {.card title=\"Text\"}\nThis is my first dashboard.\n:::\n두번째 행의 탭셋: Histogram of GDP per capita & Table of Mean Values\n행을 설정하고 행의 상대적인 높이(70%)를 지정한다. 탭셋을 생성하기 위해 {.tabset} 태그가 사용되어야 함에 주의한다.\n## Row {.tabset height=\"70%\"}\n그래프 카드를 생성하기 위해 ggplot2 패키지를 활용한다. 그래프 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다.\n#| title: \"Histogram of GDP per capita\"\nlibrary(tidyverse)\nlibrary(gapminder)\ngapminder |&gt; \n  filter(year == 2007) |&gt;\n  ggplot(aes(x = gdpPercap)) +\n  geom_histogram()\n테이블 카드를 생성하기 위해 knitr 패키지의 kable() 함수를 활용한다. 테이블 카드의 제목을 지정하기 위해 title= 옵션이 사용되어야 함에 주의한다.\n#| title: \"Table of Mean Values\"\nlibrary(knitr)\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  summarize(\n    GDP_percap = mean(gdpPercap),\n    Life_Exp = mean(lifeExp),\n    Population = mean(pop),\n    .by = continent\n  ) |&gt; \n  kable()\n세번째 행의 3개의 밸류박스\n행을 설정하고 행의 상대적인 높이(20%)를 지정한다.\n## Row {height=\"20%\"}\n첫번째 밸류박스를 생성한다. #| content: valuebox 옵션과 #| title: 옵션이 사용됨에 주의한다.\n#| content: valuebox\n#| title: \"Number of Countries\"\nn_countries &lt;- gapminder |&gt; distinct(country) |&gt; nrow()\nlist(\n  icon = \"asterisk\",\n  color = \"primary\",\n  value = n_countries\n)\n두번째 밸류박스를 생성한다.\n#| content: valuebox\n#| title: \"First Year\"\nfirst_year &lt;- gapminder |&gt; distinct(year) |&gt; pull() |&gt; first()\nlist(\n  icon = \"airplane\",\n  color = \"secondary\",\n  value = first_year\n세번째 밸류박스를 생성한다.\n#| content: valuebox\n#| title: \"Last Year\"\nlast_year &lt;- gapminder |&gt; distinct(year) |&gt; pull() |&gt; last()\nlist(\n  icon = \"bank\",\n  color = \"success\",\n  value = last_year\n)\n\n3.5.3 Graphs 페이지\nGraphs라는 이름의 페이지를 설정한다.\n# Graphs\n첫번째 행의 그래프 카드: GDP and Life Expectancy\n행을 설정한다.\n## Row\nggplot2 패키지를 활용하여 그래프 카드를 생성한다.\n#| title: GDP and Life Expectancy\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(aes(x = log10(gdpPercap), y = lifeExp)) +\n  geom_point(aes(color = continent), show.legend = FALSE) +\n  geom_smooth() + \n  facet_wrap(~continent, ncol = 5)\n두번째 행의 그래프 카드: Population & Life Expectancy\n첫번째 그래프(Population)를 위한 열을 설정한다.\n### Column\n그래프 카드를 생성한다.\n#| title: Population\ngapminder |&gt; \n  summarize(\n    sum_pop = sum(pop),\n    .by = c(year, continent)\n  ) |&gt; \n  ggplot(aes(x = year, y = sum_pop)) +\n  geom_area(aes(fill = continent)) +\n  labs(x = \"Year\", y = \"Population\", fill = \"Continents\")\n두번째 그래프(Life Expectancy)를 위한 열을 설정한다.\n### Column\n그래프 카드를 생성한다.\n#| title: Life Expectancy\ngapminder |&gt; \n  ggplot(aes(x = year, y = lifeExp)) +\n  geom_line(aes(color = continent, group = country)) +\n  labs(x = \"Year\", y = \"Life Expectancy\", color = \"Continents\")\n\n3.5.4 Tables 페이지\nTables라는 이름의 페이지를 설정한다.\n# Tables\n단일 행을 설정한다.\n## Row\nDT 패키지를 활용하여 테이블 카드를 생성한다.\n#| title: Lookup Table\nlibrary(DT)\ndatatable(gapminder, filter = \"top\", \n          options = list(\n            pageLength = 5, autoWidth = TRUE\n          ))\n\n3.5.5 Maps 페이지\nMaps라는 이름의 페이지를 설정한다.\n# Maps\n단일 행을 설정한다.\n## Row\nleaflet 패키지를 활용하여 지도 카드를 생성한다.\n#| title: A Reference Map \nlibrary(leaflet) \nleaflet() |&gt;  \n  addTiles()\n\n3.6 대시보드를 웹상에 배포하기\n블로그와 마찬가지로 다음의 절차에 따라 완성된 대시보드를 웹 상에 출판한다. 여기서는 Posit에서 제공하는 무료 출판 사이트인 Quarto Pub을 활용한다.\n\nQuarto Pub에 접속하여 계정을 만든다.\nRStudio에서, 왼쪽 하단부의 Terminal 탭을 누른다.\n프롬프트에 다음과 같이 입력하고 실행한다: quarto publish quarto-pub\n나머지 사항에 대해서는 조교의 도움을 받는다.",
    "crumbs": [
      "R과 데이터사이언스",
      "소통하기: Quarto로 대시보드 만들기"
    ]
  },
  {
    "objectID": "exec_10_old.html",
    "href": "exec_10_old.html",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "",
    "text": "여기서는 대시보드의 구성 요소로 활용할 수 있는 다양한 시각화 기법을 익힌다. 우리는 지금까지 도표(차트, 플롯, 그래프, 테이블)를 중심으로 데이터 시각화 기법을 다루었다. 특히 ggplot2 패키지는 이러한 과정에서 핵심적인 역할을 했다. 그런데 지금까지의 모든 도표는 정적(static) 이라는 특징이 있다. 많은 경우 도표는 정적으로 표현될 수 밖에 없으며, 또한 많은 경우 도표는 정적인 것으로 충분하며, 어떤 경우에는 동적인 것보다 더 낳다.\n소통을 위한 시각화 재료로서 정적인 도표가 가지는 절대적인 중요성에도 불구하고, 상호작용성(interactivity)과 생동감(animatedness)이 부가된 도표는 어떤 상항에서는 소통의 본질적 가치를 고양하는데 많은 도움을 줄 수 있다.\n더 나아가 지금까지는 시각적 도구로서 그래프에 집중한 경향이 있다. 시각적 도구로서 지도(maps)가 가지는 가치에도 불구하고 그래프에 비해 복잡한 측면이 있기 때문에 지금까지 다루지 않았다. 그러나, “지도는 텍스트, 테이블, 챠트와 같은 것들 보다 훨씬 더 효과적으로 정보를 전달할 수 있다.”(Dougherty 와/과 Ilyankou 2021)\ngapminder 데이터를 실습의 여러 곳에서 활용할 것이다. 우선 tidyverse와 gapminder패키지를 불러온다.\n\nlibrary(tidyverse)\nlibrary(gapminder)"
  },
  {
    "objectID": "exec_10_old.html#개요",
    "href": "exec_10_old.html#개요",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "",
    "text": "여기서는 대시보드의 구성 요소로 활용할 수 있는 다양한 시각화 기법을 익힌다. 우리는 지금까지 도표(차트, 플롯, 그래프, 테이블)를 중심으로 데이터 시각화 기법을 다루었다. 특히 ggplot2 패키지는 이러한 과정에서 핵심적인 역할을 했다. 그런데 지금까지의 모든 도표는 정적(static) 이라는 특징이 있다. 많은 경우 도표는 정적으로 표현될 수 밖에 없으며, 또한 많은 경우 도표는 정적인 것으로 충분하며, 어떤 경우에는 동적인 것보다 더 낳다.\n소통을 위한 시각화 재료로서 정적인 도표가 가지는 절대적인 중요성에도 불구하고, 상호작용성(interactivity)과 생동감(animatedness)이 부가된 도표는 어떤 상항에서는 소통의 본질적 가치를 고양하는데 많은 도움을 줄 수 있다.\n더 나아가 지금까지는 시각적 도구로서 그래프에 집중한 경향이 있다. 시각적 도구로서 지도(maps)가 가지는 가치에도 불구하고 그래프에 비해 복잡한 측면이 있기 때문에 지금까지 다루지 않았다. 그러나, “지도는 텍스트, 테이블, 챠트와 같은 것들 보다 훨씬 더 효과적으로 정보를 전달할 수 있다.”(Dougherty 와/과 Ilyankou 2021)\ngapminder 데이터를 실습의 여러 곳에서 활용할 것이다. 우선 tidyverse와 gapminder패키지를 불러온다.\n\nlibrary(tidyverse)\nlibrary(gapminder)"
  },
  {
    "objectID": "exec_10_old.html#임베딩",
    "href": "exec_10_old.html#임베딩",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n1 임베딩",
    "text": "1 임베딩\n동적, 반응형 시각화를 직접 제작하는 과정을 배우기 전에 대시보드에 동적, 반응형 시각화를 실현하는 가장 쉬운 방법은 동적, 반응형 시각화가 구현되어 있는 웹사이트를 대시보드에 불러오는 것일 것이다. 이것을 임베딩(embedding)이라고 하는데, HTML의 iframe 태그를 사용한다.\n통계청의 통계놀이터는 다양한 주제에 대해 동적, 반응형 시각화를 제작하여 이용자들에게 제공하고 있다. 해당 홈페이지의 [비주얼 통계]에서 “우리나라 출생아 수와 합계 출산율의 변화”를 검색하면 동적, 반응형 시각화가 구현된 웹페이지를 볼 수 있다. [공유]를 눌러 URL을 복사하고, 아래와 같은 코드를 Quarto 문서에 삽입하면 해당 웹페이지를 임베딩할 수 있다. src=\"\" 부분에 복사한 URL를 붙여 넣는다는 것을 쉽게 알 수 있을 것이다. 여기에 다른 URL을 교체해 넣으면 대부분의 웹사이트를 임베딩할 수 있는데, 임베딩이 불가능하게 막아 뒀거나 광고가 많이 붙어 있는 웹사이트는 잘 안된다. style=\"\" 부분을 적절히 수정하면 임베딩된 웹사이트의 외견을 바꿔볼 수 있다.\n&lt;iframe src=\"https://kosis.kr/edu/share.do?shareID=S0500_16\" \nloading=\"lazy\" style=\"width: 100%; height: 600px; border: \n0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;\n\n\n\n\nOur World in Data는 아름다운 인터랙티브 시각화 자료를 제공하는 것으로 유명하다. 심지어 [공유] 버턴을 눌렀을 때 &lt;/&gt; Embed 라는 옵션이 나타나는 데, 이것을 누르면 위와 같은 iframe 태그 내용이 그대로 나타나기 때문에 복사하여 붙이기만 하면 된다. Chart 탭 뿐만 아니라 Table 탭과 Map 탭도 있으니 눌러서 내용을 확인할 수 있다. 아마도 ECharts 자바스크립트 라이브러리를 사용한 것으로 보인다.\n&lt;iframe src=\"https://ourworldindata.org/grapher/child-mortality?time=earliest..latest&tab=chart\" \nloading=\"lazy\" style=\"width: 100%; height: 600px; border: 0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;\n\n\n\n\n\n\n그림 1: 임베딩 사례: Our World in Data\n\n\nOur World in Data에서 제공하는 다양한 인터랙티브 시각화 자료를 임베딩하는 절차를 요약하면 다음과 같다.\n\nOur World in Data에 접속한다.\n첫 화면의 하단에 있는 ’Data explorers’의 네 개 박스로 이동한다. 인구 관련 데이터에 관심이 있다면 ’Population & Demography’를 선택한다.\n’Population & Demography Data Explorer’에서 제공된 다양한 옵션을 이용해 원하는 인터랙티브 시각화 자료를 완성한다.\n‘Share’를 클릭하고’&lt;/&gt; Embed’를 선택한 후 URL을 복사한다. 흥미로운 점은 위에서 어떤 옵션을 어떻게 설정했느냐에 따라 URL이 달라진다는 사실이다.\niframe 태그의 “src=”에 붙여 넣어 임베딩을 완수한다."
  },
  {
    "objectID": "exec_10_old.html#테이블",
    "href": "exec_10_old.html#테이블",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n2 테이블",
    "text": "2 테이블\n우리는 지금까지 테이블(table)의 중요성에 대해 거의 다루지 않았다. 그러나 상호작용형 테이블 혹은 대화형 테이블이 되었을 때, 많은 경우, 테이블은 가장 효과적인 정보 전달 도구가 된다. 특히, 데이터 변형하기를 통해 새로운 요약 테이블을 생성하고, 그것을 대화형으로 제시하는 것은 매우 중요한 데이터사이언스의 과정이다. 여기서는 DT 패키지를 활용하여 간단한 인터랙티브 테이블을 만들어 본다. 웹에서 인터렉티브 테이블을 생성할 수 있게 해주는 다양한 종류의 JavaScript 라이브러리가 존재한다. 예를 들어 DataTables, FlexTable, React Table 등이 있는데, DT 패키지는 DataTables를 쓸 수 있게 해주는 래퍼 패키지이다.\n\nlibrary(DT)\n\n그리고 gapminder 데이터를 datatable() 함수를 통해 불러온다.\n\ndatatable(gapminder)\n\n\n\n\n\n\n결과를 좀 더 크게 보기 위해, ‘Render’ 버튼 바로 오른편에 있는 아이콘을 클릭해 ’Chunk Output in Console’를 선택할 수 있다. 결과 테이블을 이리저리 살펴본다. 언뚯 보면 View() 함수를 활용해 데이터프레임을 살펴보는 것과 유사한 것처럼 보이지만, 부가적인 기능이 제공된다.\nDT 패키지는 테이블의 상호작용성과 관련하여 몇 가지 기능을 제공한다.\n\nPagination: 페이지를 이동할 수 있는 기능\nInstant search: 즉각적인 찾기 기능(Search에 타이핑하기 시작하면 즉각적으로 검색 결과 보여줌)\nMulti-column ordering: 다중 컬럼 정렬 기능(컬럼 하나를 선택한 후 ctrl을 누른 상태에서 다른 컬럼을 선택)\nFiltering: 값을 정렬할 수 있는 기능\nEditable: 셀 값을 수정할 수 있는 기능\nButtons: 셀 숨기기, CSV, PDF, XLSX 등의 확장자로 내보내기 등을 수행하는 버튼 생성 기능\n\n그 중 몇 가지 기능을 여기에서 살펴본다. 자세한 사항은 DT 패키지 홈페이지에 잘 정리되어 있다.\n\n2.1 테이블 CSS 클래스\ndatatable() 함수의 class 인수를 통해 테이블의 외관을 바꿀 수 있다. 다음과 같은 옵션이 가능하다.\n\n\n\n\n\n\nClass name\nDescription\n\n\n\ndisplay\n\nstripe, hover, row-border, order-column을 동시 적용한 디폴트\n\n\ncell-border\n모든 셀의 상하좌우에 경계선 표시\n\n\ncompact\n여백 축소\n\n\nhover\n마우스의 위치에 따라 점멸 효과\n\n\nnowrap\n줄바꿈 없이 텍스트 표시\n\n\norder-column\n정렬의 키가 되는 컬럼에 하이라이트 표시\n\n\nrow-border\n행별 경계선 표시\n\n\nstripe\n행을 스트라이프로 표시\n\n\n\n아래와 같이 cell-border과 compact를 함께 실행해 보고 테이블의 변화를 확인한다.\n\ndatatable(head(gapminder), class = \"cell-border compact\")\n\n\n\n\n\n\n또한 특정 컬럼의 정렬 방식(왼편, 오른편, 중앙)을 변경할 수 있다. 사용가능한 옵션은 다음과 같다.\n\n\nClass name\nDescription\n\n\n\ndt[-head|-body]-left\n왼편 정렬\n\n\ndt[-head|-body]-center\n가운데 정렬\n\n\ndt[-head|-body]-right\n오른편 정렬\n\n\ndt[-head|-body]-justify\n양쪽 맞춤\n\n\ndt[-head|-body]-nowrap\n줄바꿈 없는 맞춤\n\n\n\n아래는 첫 번째와 두 번째 컬럼(country, continent)의 내용(body)을 가운데 정렬로 나타낸다.\n\ndatatable(head(gapminder),\n          options = list(\n            columnDefs = list(list(className = \"dt-body-center\", targets = 1:2))\n          ))\n\n\n\n\n\n\n2.2 테이블 에디팅\neditable 인수를 통해 테이블의 값을 수정할 수 있게 만들 수 있다. 테이블의 특정 셀에 더블클릭하면 수정할 수 있다.\n\ndatatable(head(gapminder), editable = \"cell\")\n\n\n\n\n\n\n2.3 컬럼 필터\n다음과 같은 방식으로 필터를 설정할 수 있다.\n\ndatatable(gapminder, filter = \"top\", \n          options = list(\n            pageLength = 5, \n            autoWidth = TRUE\n          ))\n\n\n\n\n\n\n2.4 버튼 기능\nextenstion에 Buttons, dom에 Bftip, buttons에 c(\"copy\", \"excel\", \"pdf\", \"print\")를 입력하면 버튼 기능을 활성화할 수 있다. 각 인수가 무엇을 의미하는지는 다음의 웹사이트를 참고할 수 있다.\n\ndatatable(gapminder, filter = \"top\",\n          extensions = \"Buttons\",\n          options = list(\n            pageLength = 5,\n            autoWidth = TRUE,\n            dom = \"Bfrtip\",\n            buttons = c(\"copy\", \"excel\", \"pdf\", \"print\")\n          ))"
  },
  {
    "objectID": "exec_10_old.html#그래프",
    "href": "exec_10_old.html#그래프",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n3 그래프",
    "text": "3 그래프\n\n3.1 인터랙티브 그래프\n인터랙티브 시각화 도구로 최근 널리 각광을 받고 있는 Plotly이다. Plotly는 사실 캐나다 퀘백에 본사를 두고 있는 데이터 시각화 전문 회사 이름이다. 그러나 보통 데이터 시각화용 JavaScript 라이브러리를 일컽는다. 이 라이버러리는 다양한 오픈소스 프로그래밍 언어에서 사용가능하며(이기준 2023), R의 랩퍼 프로그램이 plotly 패키지이다.\n\nlibrary(plotly)\n\ngapminder 데이터를 이용하여 간단한 그래프를 그려보자. 문법이 ggplot2와 크게 다르지 않음을 알 수 있다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  plot_ly(x = ~gdpPercap, y = ~lifeExp, color = ~continent,\n          text = ~paste(\"Country: \", country, \n                        \"&lt;br&gt;GDP per capita: \", gdpPercap, \n                        \"$&lt;br&gt;Life Expectancy at Birth:\", lifeExp))\n\n\n\n\n\n\n줌(zoom), 팬(pan), 박스 선택(box select), 라소 선택(Lasso select), 줌인(zome in), 줌 아웃(zoom out) 등과 같은 상호작용 기능을 확인할 수 있다. 또 그래프 상의 데이터 포인트 위에 마우스를 올리면 text 인수를 통해 설정한 내용을 볼 수 있다. 그리고 범례를 클릭하면 특정 continent의 국가를 나타나지 않게 할 수 있다.\n이와 같이 plotly 패키지를 직접 사용하면 다양한 기능을 활용할 수 있겠지만, plotly 패키지가 제공하는 ggplotly() 함수를 활용하면 ggplot2로 만들어진 그래프를 단숨에 plotly 그래프로 바꿀 수 있다. 물론 정확히 같지는 않다.\n\nP &lt;- gapminder |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() + \n  scale_color_brewer(palette = \"Set2\") +\n  theme_minimal()\nggplotly(P)\n\n\n\n\n\n\n다음 예제 역시 반응형이지만 바로 다음에서 다룰 동적인 특성도 동시에 가지고 있는 그래프를 만드는 것이다. 역시 plotly 패키지를 이용한다.\n\ngapminder |&gt; \n  plot_ly(x = ~log10(gdpPercap), y = ~lifeExp,\n          text = ~paste(\"Country: \", country)) |&gt; \n  add_markers(color = ~continent, size = ~pop, frame = ~year, \n              marker = list(sizeref = 0.2, sizemode = \"area\"))\n\n\n\n\n\n\n하단에 있는 ‘Play’ 버튼을 누르면 연도에 따라 그래프가 바뀌면서 동적인 효과가 나타나게 된다.\n\n3.2 애니메이션 그래프\n이 실습에서는 gganimate 패키지를 활용하여, 움직이는 그래프를 만드는 방법을 익히도록 한다. 물론 움직인다고 해서 인터랙티브한 그래프인 것은 아니다. gganimate 패키지를 설치한 후 불러온다.\n\nlibrary(gganimate)\n\n우선 정적인 그래프를 그린다.\n\nP &lt;- gapminder |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, color = continent)) +\n  geom_point(show.legend = FALSE, alpha = 0.7) +\n  scale_x_log10() +\n  scale_size(range = c(2, 12))\nP\n\n\n\n\n\n\n\n이 그래프는 두 변수 간에 양적인 관련성이 있다는 사실은 명백히 보여주지만, 데이터 변형의 측면에서는 잘못된 것이다. 모든 연도(1952~2007년간 5년 단위)가 나타나 있어서 한 국가가 그래프에 12번 등장한다.\n이를 해결하기 위해 ggplot2 패키지의 facet_wrap() 함수를 활용한다.\n\nP + facet_wrap(~year)\n\n\n\n\n\n\n\n이 그래프는 두 변수간의 양적인 상관관계가 12개 모두의 연도에서 나타난다는 사실을 명확히 보여준다. 그러나 그래프를 세세히 살펴보면 알 수 있듯이, 두 변수의 관련성이라는 측면에서 개별 국가가 시간의 흐름에 따라 어떻게 변화해 나가는지에 대한 사항을 파악하기는 매우 어렵다.\ngganimate 패키지의 transition_time() 함수를 활용하여 동적인 그래프를 작성해 본다.\n\nP + transition_time(year) +\n  labs(title = \"Year: {frame_time}\")\n\n\n\n\n\n\n\n대륙별로 분할하여 표현할 수도 있다.\n\nP + facet_wrap(~continent) +\n  transition_time(year) +\n  labs(title = \"Year: {frame_time}\")\n\n\n\n\n\n\n\n움직임을 조금 더 역동적이게 만들어 볼 수 있다.\n\nP + transition_time(year) +\n  labs(title = \"Year: {frame_time}\") +\n  shadow_wake(wake_length = 0.1, alpha = FALSE)\n\n\n\n\n\n\n\n그래프를 저장하고 싶으면 anim_save() 함수를 활용할 수 있다. ggsave() 함수와 동일한 문법을 갖는다."
  },
  {
    "objectID": "exec_10_old.html#지도",
    "href": "exec_10_old.html#지도",
    "title": "소통하기: 인터랙티브 시각화",
    "section": "\n4 지도",
    "text": "4 지도\n\n4.1 벡터 데이터와 sf 패키지\n지도는 간단히 말해 지리공간적(geospatial) 데이터를 그래픽 형태로 나타낸 것이다. 따라서 지리공간적 데이터를 이해하는 것이 지도 제작의 시발점이 되어야 한다. 지리공간적 데이터는 GIS적 관점에서 벡터(vector) 데이터와 래스터(raster) 데이터로 나뉜다. 벡터 데이터는 지리공간적 사상의 기하학적 형태(형상 데이터)와 그것의 다양한 특성(속성 데이터)을 담고 있는 데이터이다.\n벡터 데이터는 지리공간적 사상을 포인트, 라인, 폴리곤 피처로 구분하고, 개별 피처를 형태와 위치를 개별 피처를 구성하고 있는 버택스의 좌표값을 저장함으로써 구현하는데, 이러한 정보를 담고 있는 것을 형상 데이터라고 한다. 예를 들어 우리나라 17개 시도에 대한 디지털 행정구역도가 여기에 해당한다. 이에 반해 속성 데이터는 포인트, 라인, 폴리곤 등으로 재현된 개별 피처의 다양한 특성을 가지고 있는 것으로 보통 테이블 데이터라고 한다. 예를 들어, 우리나라 17개 시도의 인구수, 인구성장률, 순이동률과 같은 것이다. 형상 데이터가 지리공간적 데이터의 특수성을 더 잘 반영하기 때문에 보통 형상 데이터를 공간 데이터라고도 하면, 벡터 데이터에서는 이 두 종류의 데이터가 기본적으로 독립적이며 보통은 느슨한 형태로 결합되어 있다.\n이에 반해 래스터 데이터는 세상을 동일한 크기의 수 많은 그리드 셀(grid cell)로 구성되어 있다고 보며, 개별 그리드 셀에 속성이 저장되어 있는 데이터를 의미한다. 가장 쉬운 예가 인공위성 영상이다. 인공위성 영상의 특정한 공간해상도를 가진 픽셀로 나뉘어져 있고, 개별 픽셀에 특정한 값(특정한 밴드의 반사값)이 들어가 있다. 따라서 래스터 데이터는 벡터 데이터처럼 형상 데이터와 속성 데이터가 분리되어 있는 것이 아니라 일체형이다. 특수한 경우가 아니라면 하나의 래스터 파일에는 하나의 속성만이 들어가 있다. 이에 반해 벡터 데이터의 속성 파일에는 수많은 변수가 포함될 수 있다.\n지도 제작의 원칙은 동일하지만, 지도로 나타낼 데이터가 벡터 데이터인지 래스터 데이터인지에 혹은 둘 다인지에 따라 지도화의 세부 절차는 달라질 수 있다. 여기서는 벡터 데이터에 기반한 지도 제작에 집중하고자 한다. 속성 데이터는 기본적으로 R의 데이터 프레임과 동일한 개념이므로, 데이터사이언스의 기본 과정을 통해 불러오고, 정돈하고, 변형할 수 있다. 따라서 보다 중요한 것은 형상 데이터를 다루는 것이다.\n벡터 데이터 포맷, 보다 정확하게는 형상 데이터의 포맷으로 가장 널리 사용되고 있는 것이 셰이프 파일(shape file)이다. 셰이프 파일(확장자가 .shp인 파일)은 전세계에서 가장 큰 GIS 회사인 ESRI가 오래전에 개발한 벡터 데이터 포맷으로, 현재 표준 포맷의 역할을 하고 있다. 그런데 셰이프 파일은 동일한 이름을 공유하지만 확장자가 서로 다른 몇 개의 파일의 묶음을 지칭한다는 점을 이해할 필요가 있다. 반드시 다음의 네 파일을 함께 가지고 있어야 한다.\n\n*.shp: 버텍스의 좌표값이 포함된 핵심 파일\n*.dbf: 기본 속성 파일\n*.shx: 공간적 인덱싱 파일\n*.prj: 투영 정보 파일\n\n마지막의 *.prj 파일은 없어도 지도로 나타날 수는 있다. 그러나 다른 셰이프 파일과 함께 지도로 나타내거나 축척막대와 같은 지도 요소를 적절하게 나타내기 위해서는 좌표참조계(CRS) 정보가 포함된 *.prj 파일은 가질 필요가 있다.\nR에서 형상 데이터를 다루는데 있어 거의 표준처럼 사용되고 있는 것이 sf 패키지이다. 기본적으로는 셰이프 파일을 불러오기 위한 st_read() 함수를 주로 사용하게 되겠지만, sf 패키지는 벡터-기반 GIS 오퍼레이션을 위한 폭넓은 함수를 제공한다. 중요한 것을 정리하면 다음과 같다.\n\n\n\n\n\n\n\n구분\n함수\n설명\n\n\n\n읽고 쓰기\n\nst_read()\nread_sf()\n\n셰이프 파일 읽어 들이기\n\n\n\nst_write()\n셰이프 파일 저장\n\n\n투영 관련\nst_crs()\nCRS 정보 확인\n\n\n\nst_transform()\nCRS 바꾸기\n\n\n기하 측정\nst_area()\n면적 계산\n\n\n\nst_length()\n길이 계산\n\n\n\nst_perimeter()\n둘레 계산\n\n\n\nst_distance()\n거리 계산\n\n\n기하 변형\nst_centroid()\n센트로이드 생성\n\n\n\nst_buffer()\n버퍼 생성\n\n\n\nst_boundary()\n가장자리 추출\n\n\n\nst_simplify()\n선 피처 단순화 실행\n\n\n기하 생성\nst_point()\n포인트 피처 생성\n\n\n\nst_vironoi()\n보로노이 폴리곤 생성\n\n\n\nst_convex_hull()\n컨벡스 헐 생성\n\n\n\nst_make_grid()\n규칙 그리드 생성\n\n\n기하 검토\nst_is_valid()\n지오메트리가 밸리드한지 여부 검토\n\n\n\nst_make_valid()\n지오메트리를 밸리드하게 만들기\n\n\n기하 중첩\nst_intersection()\n기하 교집합 중첩\n\n\n\nst_union()\n기하 합집합 중첩\n\n\n\nst_crop()\n기하 크롭 중첩\n\n\n기타\nst_coordinates()\n버택스 좌표값 반환\n\n\n\nst_cast()\n다른 피처 유형으로 변환\n\n\n\nst_as_sf()\nsf 객체로 변환\n\n\n\nst_graticule()\n그래티큘 생성\n\n\n\nst_join()\n공간적 조인 실행\n\n\n\n래스터 데이터를 다루는데는 terra 패키지가 가장 널리 사용되고 있으며, stars패키지가 최근 많은 주목을 받고 있다. stars 패키지와 sf 패키지는 모두 에트저르 페베스마(Edzer Pebesma)가 만들었다. 두 패키지에 대한 설명은 페베스마와 로저 비번드(Roger Bivand)가 함께 쓴 ’R을 활용한 공간데이터사이언스(Spatial Data Science With Applications in R)’에 잘 나타나 있다(Pebesma 와/과 Bivand (2023))\n\n4.2 정적 지도 제작\n\n4.2.1 세계 지도\nggplot2 패키지를 이용하여 정적 지도를 그려본다. ggplot2패키지로 지도를 그린다는 것은 ’지도도 그래프다.’라는 접근법에 기반하고 있다. ggplot2의 문법을 지도 제작으로 확장할 수 있고, 막강한 생태계를 고려할 때 충분히 이점이 있는 접근법이다.\n데이터는 지난 실습에서 사용한 WPP 2024(World Population Prospects 2024)이다. 2024년 전세계 국가별 TFR(Total Fertility Rate, 합계출산율) 지도를 그려본다.\n벡터 데이터를 활용한 지도는 형상 데이터와 속성 데이터를 결합해야만 제작할 수 있다. 여기서 형상 데이터는 전세계 국가 경계 데이터이고, 속성 데이터는 TFR이 포함된 WPP 2024 데이터이다. 형상 데이터는 spData 패키지에 들어 있는 world 객체를 사용한다. 벡터 형식의 데이터는 sf 패키지의 st_as_sf() 함수를 통해 sf 객체로 변환하는 것이 좋다.\n\nlibrary(spData)\nlibrary(sf)\ndata(world)\nworld &lt;- st_as_sf(world)\n\nWPP 2024 데이터를 불러와 2025년만 골라낸다.\n\nwpp_2024 &lt;- read_rds(\"wpp_2024.rds\")\nmy_wpp &lt;- wpp_2024 |&gt; \n  filter(year == 2025)\n\n두 데이터를 left_join() 함수를 이용하여 결합한다. 벡터 데이터의 경우는 늘 반드시 형상 데이터를 중심에 두고 left_join() 함수를 통해 속성 데이터를 불러와 합체해야 한다.\n\nworld_data &lt;- world |&gt;\n  left_join(my_wpp, join_by(iso_a2 == ISO2))\n\n로빈슨 도법(Robinson projection)의 지도를 제작한다. ggplot2 패키지로 지도를 그리는 가장 좋은 방법은 기하객체 함수인 geom_sf()와 좌표 변환 함수인 coord_sf()를 결합하는 것이다. scale_x_continuous()와 scale_y_continuous()의 내용은 그래티큘(경위선망)을 원하는 방식대로 지도에 포함시키기 위한 것이다. 그래프를 world_map이라는 이름의 객체로 저장하는 것은 뒤에서 이 지도를 사용하기 때문이다.\n\nworld_map &lt;- ggplot() +\n  geom_sf(data = world_data, aes(fill = TFR, text = name_long)) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_fill_viridis_c() +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.5, seq(-60, 60, 30), 89.5)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\nworld_map\n\n\n\n\n\n\n\n\n4.2.2 우리나라 지도\n우리나라 지도도 그려본다. ’Lab07: 데이터 수집하기’에서 KOSIS의 API를 통해 수집, 정리한 시군구 단위 지역소멸위험지수를 지도화한다. 우선 우리나라 시군구 행정 경계에 대한 도형(형상, 기하) 데이터가 필요하다. GADM(Database of Global Administrative Areas)는 전 세계 국가별, 행정구역 수준별, 고해상도 디지털 경계 파일을 제공한다. 직접 웹사이트를 방문해 파일을 다운로드할 수도 있지만, 여기서는 geodata 패키지의 도움을 받는다. geodata 패키지는 정말 다양한 종류의 공간 데이터를 쉽게 다운로드할 수 있게 도와준다. 1레벨인 시도 단위와 2레벨인 시군구 단위를 다운받는다. path 아규먼트가 반드시 필요한데, 프로젝트 파일의 폴더도 좋고, 앞으로 geodata 패키지를 통해 다운받을 데이터를 모아둘 곳을 따로 정해두어도 좋다. 그렇지만 할당 연산자를 통해 이름을 부여하면 따로 다운로드된 파일을 다시 부르는 수고는 하지 않아도 된다.\n\nlibrary(geodata)\nlibrary(tmap)\n\nkorea_sd &lt;- gadm(country = \"South Korea\", level = 1, path = \"D:/My R/Geodata/\")\nkorea_sd &lt;- korea_sd |&gt; \n  st_as_sf()\nkorea_sgg &lt;- gadm(country = \"South Korea\", level = 2, path = \"D:/My R/Geodata/\")\nkorea_sgg &lt;- korea_sgg |&gt; \n  st_as_sf()\n\n그런데 파일을 열어보고서 경악한다. 행정구역 코드가 없다. 그래서 이 방법은 포기한다.\n행정구역 파일은 통계청의 통계지리정보서비스에서 구할 수 있다. 다운받는 방법을 익히면 좋겠지만, 시간 절약을 위해 다운받아 정리한 파일을 그냥 제공한다. 프로젝트 폴더에 파일을 저장한 후, 아래의 코드를 통해 불러온다.\n\nsido_shp &lt;- st_read(\"sido.shp\", options = \"ENCODING=CP949\")\nsigungu_shp &lt;- read_sf(\"sigungu.shp\", options = \"ENCODING=CP949\")\n\n두 파일에 대해 서로 다른 함수를 적용한 것을 알 수 있다. st_read() 함수는 가장 보편적으로 사용되는 것으로 불러올 때마다 파일에 대한 정보(지오메트리 유형, 바운딩 박스, CRS 등)가 자동으로 디스플레이된다. 이러한 정보는 항상 유익한 것이지만 보이지 않게 하고 싶을 수도 있다. 이 때 read_sf() 함수를 사용할 수 있다.\n불러들인 파일을 바탕으로 시군구 경계를 그려본다. 지도 제작 전문 패키지인 tmap의 qtm() 함수를 이용하여 시군구 경계에 대한 지도를 빠르게 그려본다. tmap패키지로 지도를 그린다는 것은 ’지도는 지도다.’라는 접근법에 기반하고 있다. tmap의 문법을 새로 배워야 한다는 단점이 있긴 하지만, 지도는 그래프로 환원될 수 없는 고유한 특성이 있고, tmap패키지는 이러한 지도의 고유한 특성을 잘 반영하고 있다. 좀 더 복잡한 tmap의 문법을 사용한 지도 제작은 맨 뒤에서 다루기로 한다.\n\nlibrary(tmap)\nqtm(sigungu_shp)\n\n\n\n\n\n\n\n지역소멸위험지수 데이터를 불러온다. 아래 코드는 지난번 실습 때 rds 파일 포맷으로 저장해 둔 것을 가정한 것이다. 실습의 편의를 위해 파일을 제공하니 프로젝트 폴더에 저장한 후, 아래의 코드를 통해 불러온다.\n\ndata_sigungu &lt;- read_rds(\"data_sigungu.rds\")\n\n도형 데이터(korea_sgg)와 속성 데이터(data_sigungu)를 공통 키(key)를 활용하여 결합한다.\n\nsigungu_data &lt;- sigungu_shp |&gt; \n  left_join(\n    data_sigungu, join_by(SGG1_CD == C1)\n  )\n\n이제 ggplot2 패키지를 이용하여 지도를 제작한다. ’Lab07: 데이터 수집하기’에서 인구소멸위험지수의 시도별 그래프를 제작한 것과 비교해 보라. 그 유사함에 깜짝 놀랄 수도 있다. ggplot2에서는 그래프와 지도의 구분이 없다. 이것은 ggplot2의 장점이자 단점이다.\n\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index_class = case_when(\n      index &lt; 0.2 ~ \"1\",\n      index &gt;= 0.2 & index &lt; 0.5 ~ \"2\",\n      index &gt;= 0.5 & index &lt; 1.0 ~ \"3\",\n      index &gt;= 1.0 & index &lt; 1.5 ~ \"4\",\n      index &gt;= 1.5 ~ \"5\"\n    ),\n    index_class = fct(index_class, levels = as.character(1:5))\n  )\n\nclass_color &lt;- c(\"1\" = \"#d7191c\", \"2\" = \"#fdae61\",\n                 \"3\" = \"#ffffbf\", \"4\" = \"#a6d96a\", \n                 \"5\" = \"#1a9641\")\nggplot() +\n  geom_sf(data = sigungu_data, aes(fill = index_class), show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(name = \"Classes\", \n                    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \n                               \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n                    values = class_color, drop = FALSE) \n\n\n\n\n\n\n\n\n4.3 인터랙티브 지도 제작\n위에서 사용한 plotly 패키지의 ggplotly() 함수를 활용하면 반응형 지도를 생성할 수 있다. 앞의 코드 둘째 줄에 aes()에 text = name_long이 설정되어 있는데, 마우스로 국가를 가리킬 때 이름이 나타날 수 있게 조치한 것이다.\n\nggplotly(world_map)\n\n\n\n\n\n지도 위에서 plotly 가 제공하는 다양한 기능을 적용해 볼 필요가 있다. 인터랙티브 그래프에 비해 인터랙티브 지도의 유용성이 더 높아 보인다.\n우리나라 지도는 다른 방식으로 반응형으로 만들어 본다. 여기서는 ggiraph 패키지를 사용한다. 처음 사용하는 경우라면 먼저 패키지를 인스톨해야 한다. 코드의 전반부는 커서를 특정 시군구 위에 올렸을 때 나타나는 정보를 좀 더 다양하게 하려는 조치이다. 중간의 코드가 핵심인데, 찬찬히 살펴보면 그렇게 복잡하지 않다. 마지막은 완전히 지엽적인 것인데, 커서를 특정 시군구 위에 올렸을 때 색이 회색으로 변하게 하기 위한 것이다.\n\nlibrary(ggiraph)\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = format(index, digits = 4, nsmall = 4),\n    my_tooltip = str_c(\"Name: \", SGG1_FNM, \"\\n Index: \", index)\n  )\ngg &lt;- ggplot() +\n  geom_sf_interactive(\n    data = sigungu_data, \n    aes(\n      fill = index_class, \n      tooltip = my_tooltip, \n      data_id = SGG1_FNM\n      ), \n    show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(\n    name = \"Classes\", \n    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n    values = class_color, drop = FALSE) \ngirafe(ggobj = gg) |&gt; \n  girafe_options(\n    opts_hover(css = \"fill: gray\")\n  )\n\n\n\n\n\n그러나 반응형 지도 제작에 가장 널리 쓰이는 것은 leaflet이다. leaflet은 웹 상의 반응형 지도 제작에 특화된 JavaScript 라이브러리이다. 이 라이브러리를 R에서 쓸 수 있게 도와주는 래퍼 패키지가 leaflet 패키지이다. 패키지 홈페이지가 매우 상세하게 잘 되어 있다. 숙독하기를 권한다.\n\nlibrary(leaflet)\n\n매우 단순한 인터랙티브 지도를 만들어 본다. 자신이 원하는 경위도값과 설명문으로 수정하면 된다.\n\nleaflet() |&gt; \n  addTiles() |&gt; \n  addPopups(126.955184, 37.460422, \"Sang-Il's Office\",\n            options = popupOptions(closeButton = FALSE))\n\n\n\n\n\n\n위에서 작성했던 TFR 세계지도를 leaflet 패키지의 다양한 함수와 아규먼트를 활용하여 인터랙티브 지도를 제작해 본다.\n\nworld_data &lt;- world_data |&gt; filter(!is.na(TFR))\n\nbins &lt;- c(0, 1.5, 2.1, 3, 4, 5, Inf)\npal &lt;- colorBin(\"YlOrRd\", domain = world_data$TFR, bins = bins)\nlabels &lt;- sprintf(\"&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g\",\n  world_data$name_long, world_data$TFR) |&gt; lapply(htmltools::HTML)\n\nleaflet(world_data) |&gt; \n  addProviderTiles(providers$Esri.WorldTopoMap) |&gt; \n  addPolygons(\n    fillColor = ~pal(TFR),\n    weight =  2, \n    opacity = 1,\n    color = \"white\",\n    dashArray = \"3\",\n    fillOpacity = 0.6,\n    highlightOptions = highlightOptions(\n      weight = 5,\n      color = \"#666\",\n      dashArray = \"\",\n      fillOpacity = 0.6,\n      bringToFront = TRUE),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n      textsize = \"15px\",\n      direction = \"auto\")\n  ) |&gt; \n  addLegend(\n    pal = pal, values = ~TFR, opacity = 0.6, title = NULL,\n    position = \"bottomright\"\n  )\n\n\n\n\n\n\n우리나라 시군구 단위의 인구소멸위험지수에 대한 지도를 반응형으로 만들어 본다. 여기서는 tmap을 활용한다. 해당 시군구 위에 클릭하면 지역소멸위험지수가 나타난다.\n\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = as.numeric(index)\n  )\ntmap_mode(mode = \"view\")\nmy_tmap &lt;- tm_shape(sigungu_data) + \n  tm_polygons(\n    col = \"index\",\n    palette = class_color, \n    breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n    labels = c(\"&lt; 0.2\", \"0.2~0.5\", \"0.5~1.0\", \"1.0~1.5\", \"&gt;= 1.5\"),\n    title = \"Classes\", \n    popup.vars=c(\"지역소멸위험지수: \" = \"index\"), \n    popup.format = list(index = list(digits = 3)), \n    id = \"SGG1_FNM\", \n    alpha = 0.6, \n    border.alpha = 0.5\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 2)\nmy_tmap\n\n\n\n\n\ntmap_save(my_tmap, \"지방소멸위험지수.html\")"
  },
  {
    "objectID": "exec_12.html",
    "href": "exec_12.html",
    "title": "R과 데이터사이언스 과정",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 전 과정을 개괄적으로 이해하도록 한다. 특히 그림 1 에 나타나 있는 데이터사이언스 과정 중 특히 네 부분, 데이터 불러오기(importing), 정리하기(tidying), 변형하기(transforming), 시각화하기(visualizing)에 초첨을 둔다. 보통 데이터 정리하기와 변형하기를 합쳐 ’데이터와 씨름하기(data wrangling)’이라고 부르고, 변형하기와 시각화하기를 합쳐 ’데이터 탐색하기(data exploration)’라고 한다. 데이터를 살펴보기 위해 모델링을 사용하는 경우, 일부 모델링하기도 탐색하기에 포함되는 것으로 볼 수도 있다.\n\n\n\n\n\n그림 1: 데이터사이언스의 과정(https://r4ds.hadley.nz/intro.html)\n\n\n데이터사이언스의 다양한 과업을 수행하기 위해 Base R의 함수들이 사용되고 있지만, 보통은 이와 함께 다양한 패키지(package)들이 널리 사용되고 있다. 따라서 본 실습에서는 우선 패키지의 사용과 관련된 부분을 다루고 뒤를 이어 데이터사이언스의 네 과제가 어떻게 이루어지는지 대략적으로 다룰 것이다.\n\n패키지와 tidyverse\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기"
  },
  {
    "objectID": "exec_12.html#개요",
    "href": "exec_12.html#개요",
    "title": "R과 데이터사이언스 과정",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 전 과정을 개괄적으로 이해하도록 한다. 특히 그림 1 에 나타나 있는 데이터사이언스 과정 중 특히 네 부분, 데이터 불러오기(importing), 정리하기(tidying), 변형하기(transforming), 시각화하기(visualizing)에 초첨을 둔다. 보통 데이터 정리하기와 변형하기를 합쳐 ’데이터와 씨름하기(data wrangling)’이라고 부르고, 변형하기와 시각화하기를 합쳐 ’데이터 탐색하기(data exploration)’라고 한다. 데이터를 살펴보기 위해 모델링을 사용하는 경우, 일부 모델링하기도 탐색하기에 포함되는 것으로 볼 수도 있다.\n\n\n\n\n\n그림 1: 데이터사이언스의 과정(https://r4ds.hadley.nz/intro.html)\n\n\n데이터사이언스의 다양한 과업을 수행하기 위해 Base R의 함수들이 사용되고 있지만, 보통은 이와 함께 다양한 패키지(package)들이 널리 사용되고 있다. 따라서 본 실습에서는 우선 패키지의 사용과 관련된 부분을 다루고 뒤를 이어 데이터사이언스의 네 과제가 어떻게 이루어지는지 대략적으로 다룰 것이다.\n\n패키지와 tidyverse\n데이터 시각화하기\n데이터 변형하기\n데이터 정리하기\n데이터 불러오기"
  },
  {
    "objectID": "exec_12.html#지리공간적-데이터와-지도",
    "href": "exec_12.html#지리공간적-데이터와-지도",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n1 지리공간적 데이터와 지도",
    "text": "1 지리공간적 데이터와 지도\n\n1.1 벡터와 래스터 데이터\n지도는 간단히 말해 지리공간적(geospatial) 데이터를 그래픽 형태로 나타낸 것이다. 따라서 지리공간적 데이터를 이해하는 것이 지도 제작의 시발점이 되어야 한다. 지리공간적 데이터는 GIS적 관점에서 벡터(vector) 데이터와 래스터(raster) 데이터로 나뉜다. 벡터 데이터는 지리공간적 사상의 기하학적 형태(형상 데이터)와 그것의 다양한 특성(속성 데이터)을 담고 있는 데이터이다.\n벡터 데이터는 지리공간적 사상을 포인트, 라인, 폴리곤 피처로 구분하고, 개별 피처를 형태와 위치를 개별 피처를 구성하고 있는 버택스의 좌표값을 저장함으로써 구현하는데, 이러한 정보를 담고 있는 것을 형상 데이터라고 한다. 예를 들어 우리나라 17개 시도에 대한 디지털 행정구역도가 여기에 해당한다. 이에 반해 속성 데이터는 포인트, 라인, 폴리곤 등으로 재현된 개별 피처의 다양한 특성을 가지고 있는 것으로 보통 테이블 데이터라고 한다. 예를 들어, 우리나라 17개 시도의 인구수, 인구성장률, 순이동률과 같은 것이다. 형상 데이터가 지리공간적 데이터의 특수성을 더 잘 반영하기 때문에 보통 형상 데이터를 공간 데이터라고도 하면, 벡터 데이터에서는 이 두 종류의 데이터가 기본적으로 독립적이며 보통은 느슨한 형태로 결합되어 있다.\n이에 반해 래스터 데이터는 세상을 동일한 크기의 수 많은 그리드 셀(grid cell)로 구성되어 있다고 보며, 개별 그리드 셀에 속성이 저장되어 있는 데이터를 의미한다. 가장 쉬운 예가 인공위성 영상이다. 인공위성 영상의 특정한 공간해상도를 가진 픽셀로 나뉘어져 있고, 개별 픽셀에 특정한 값(특정한 밴드의 반사값)이 들어가 있다. 따라서 래스터 데이터는 벡터 데이터처럼 형상 데이터와 속성 데이터가 분리되어 있는 것이 아니라 일체형이다. 특수한 경우가 아니라면 하나의 래스터 파일에는 하나의 속성만이 들어가 있다. 이에 반해 벡터 데이터의 속성 파일에는 수많은 변수가 포함될 수 있다.\n지도 제작의 원칙은 동일하지만, 지도로 나타낼 데이터가 벡터 데이터인지 래스터 데이터인지에 혹은 둘 다인지에 따라 지도화의 세부 절차는 달라질 수 있다. 여기서는 벡터 데이터에 기반한 지도 제작에 집중하고자 한다. 속성 데이터는 기본적으로 R의 데이터 프레임과 동일한 개념이므로, 데이터사이언스의 기본 과정을 통해 불러오고, 정돈하고, 변형할 수 있다. 따라서 보다 중요한 것은 형상 데이터를 다루는 것이다.\n\n1.2 셰이프 파일\n벡터 데이터 포맷, 보다 정확하게는 형상 데이터의 포맷으로 가장 널리 사용되고 있는 것이 셰이프 파일(shape file)이다. 셰이프 파일(확장자가 .shp인 파일)은 전세계에서 가장 큰 GIS 회사인 ESRI가 오래전에 개발한 벡터 데이터 포맷으로, 현재 표준 포맷의 역할을 하고 있다. 그런데 셰이프 파일은 동일한 이름을 공유하지만 확장자가 서로 다른 몇 개의 파일의 묶음을 지칭한다는 점을 이해할 필요가 있다. 반드시 다음의 네 파일을 함께 가지고 있어야 한다.\n\n*.shp: 버텍스의 좌표값이 포함된 핵심 파일\n*.dbf: 기본 속성 파일\n*.shx: 공간적 인덱싱 파일\n*.prj: 투영 정보 파일\n\n마지막의 *.prj 파일은 없어도 지도로 나타날 수는 있다. 그러나 다른 셰이프 파일과 함께 지도로 나타내거나 축척막대와 같은 지도 요소를 적절하게 나타내기 위해서는 좌표참조계(CRS) 정보가 포함된 *.prj 파일은 가질 필요가 있다.\n\n1.3 sf 패키지\nR에서 형상 데이터를 다루는데 있어 거의 표준처럼 사용되고 있는 것이 sf 패키지이다. 기본적으로는 셰이프 파일을 불러오기 위한 st_read() 함수를 주로 사용하게 되겠지만, sf 패키지는 벡터-기반 GIS 오퍼레이션을 위한 폭넓은 함수를 제공한다. 중요한 것을 정리하면 다음과 같다.\n\n\n\n\n\n\n\n구분\n함수\n설명\n\n\n\n읽고 쓰기\n\nst_read()\nread_sf()\n\n셰이프 파일 읽어 들이기\n\n\n\nst_write()\n셰이프 파일 저장\n\n\n투영 관련\nst_crs()\nCRS 정보 확인\n\n\n\nst_transform()\nCRS 바꾸기\n\n\n기하 측정\nst_area()\n면적 계산\n\n\n\nst_length()\n길이 계산\n\n\n\nst_perimeter()\n둘레 계산\n\n\n\nst_distance()\n거리 계산\n\n\n기하 변형\nst_centroid()\n센트로이드 생성\n\n\n\nst_buffer()\n버퍼 생성\n\n\n\nst_boundary()\n가장자리 추출\n\n\n\nst_simplify()\n선 피처 단순화 실행\n\n\n기하 생성\nst_point()\n포인트 피처 생성\n\n\n\nst_vironoi()\n보로노이 폴리곤 생성\n\n\n\nst_convex_hull()\n컨벡스 헐 생성\n\n\n\nst_make_grid()\n규칙 그리드 생성\n\n\n기하 검토\nst_is_valid()\n지오메트리가 밸리드한지 여부 검토\n\n\n\nst_make_valid()\n지오메트리를 밸리드하게 만들기\n\n\n기하 중첩\nst_intersection()\n기하 교집합 중첩\n\n\n\nst_union()\n기하 합집합 중첩\n\n\n\nst_crop()\n기하 크롭 중첩\n\n\n기타\nst_coordinates()\n버택스 좌표값 반환\n\n\n\nst_cast()\n다른 피처 유형으로 변환\n\n\n\nst_as_sf()\nsf 객체로 변환\n\n\n\nst_graticule()\n그래티큘 생성\n\n\n\nst_join()\n공간적 조인 실행\n\n\n\n래스터 데이터를 다루는데는 terra 패키지가 가장 널리 사용되고 있으며, stars패키지가 최근 많은 주목을 받고 있다. stars 패키지와 sf 패키지는 모두 에트저르 페베스마(Edzer Pebesma)가 만들었다. 두 패키지에 대한 설명은 페베스마와 로저 비번드(Roger Bivand)가 함께 쓴 ’R을 활용한 공간데이터사이언스(Spatial Data Science With Applications in R)’에 잘 나타나 있다(Pebesma 와/과 Bivand (2023))"
  },
  {
    "objectID": "exec_12.html#정적-지도-제작",
    "href": "exec_12.html#정적-지도-제작",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n2 정적 지도 제작",
    "text": "2 정적 지도 제작\n\n2.1 세계 지도\nggplot2 패키지를 이용하여 정적 지도를 그려본다. ggplot2패키지로 지도를 그린다는 것은 ’지도도 그래프다.’라는 접근법에 기반하고 있다. ggplot2의 문법을 지도 제작으로 확장할 수 있고, 막강한 생태계를 고려할 때 충분히 이점이 있는 접근법이다.\n데이터는 지난 실습에서 사용한 WPP 2024(World Population Prospects 2024)이다. 2024년 전세계 국가별 TFR(Total Fertility Rate, 합계출산율) 지도를 그려본다.\n벡터 데이터를 활용한 지도는 형상 데이터와 속성 데이터를 결합해야만 제작할 수 있다. 여기서 형상 데이터는 전세계 국가 경계 데이터이고, 속성 데이터는 TFR이 포함된 WPP 2024 데이터이다. 형상 데이터는 spData 패키지에 들어 있는 world 객체를 사용한다. 벡터 형식의 데이터는 sf 패키지의 st_as_sf() 함수를 통해 sf 객체로 변환하는 것이 좋다.\n\nlibrary(spData)\nlibrary(sf)\ndata(world)\nworld &lt;- st_as_sf(world)\n\nWPP 2024 데이터를 불러와 2025년만 골라낸다.\n\nwpp_2024 &lt;- read_rds(\"wpp_2024.rds\")\nmy_wpp &lt;- wpp_2024 |&gt; \n  filter(year == 2025)\n\n두 데이터를 left_join() 함수를 이용하여 결합한다. 벡터 데이터의 경우는 늘 반드시 형상 데이터를 중심에 두고 left_join() 함수를 통해 속성 데이터를 불러와 합체해야 한다.\n\nworld_data &lt;- world |&gt;\n  left_join(my_wpp, join_by(iso_a2 == ISO2))\n\n로빈슨 도법(Robinson projection)의 지도를 제작한다. ggplot2 패키지로 지도를 그리는 가장 좋은 방법은 기하객체 함수인 geom_sf()와 좌표 변환 함수인 coord_sf()를 결합하는 것이다. scale_x_continuous()와 scale_y_continuous()의 내용은 그래티큘(경위선망)을 원하는 방식대로 지도에 포함시키기 위한 것이다. 그래프를 world_map이라는 이름의 객체로 저장하는 것은 뒤에서 이 지도를 사용하기 때문이다.\n\nworld_map &lt;- ggplot() +\n  geom_sf(data = world_data, aes(fill = TFR, text = name_long)) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_fill_viridis_c() +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.5, seq(-60, 60, 30), 89.5)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\nworld_map\n\n\n\n\n\n\n\n\n2.2 우리나라 지도\n우리나라 지도도 그려본다. ’Lab07: 데이터 수집하기’에서 KOSIS의 API를 통해 수집, 정리한 시군구 단위 지역소멸위험지수를 지도화한다. 우선 우리나라 시군구 행정 경계에 대한 도형(형상, 기하) 데이터가 필요하다. GADM(Database of Global Administrative Areas)는 전 세계 국가별, 행정구역 수준별, 고해상도 디지털 경계 파일을 제공한다. 직접 웹사이트를 방문해 파일을 다운로드할 수도 있지만, 여기서는 geodata 패키지의 도움을 받는다. geodata 패키지는 정말 다양한 종류의 공간 데이터를 쉽게 다운로드할 수 있게 도와준다. 1레벨인 시도 단위와 2레벨인 시군구 단위를 다운받는다. path 아규먼트가 반드시 필요한데, 프로젝트 파일의 폴더도 좋고, 앞으로 geodata 패키지를 통해 다운받을 데이터를 모아둘 곳을 따로 정해두어도 좋다. 그렇지만 할당 연산자를 통해 이름을 부여하면 따로 다운로드된 파일을 다시 부르는 수고는 하지 않아도 된다.\n\nlibrary(geodata)\nlibrary(tmap)\n\nkorea_sd &lt;- gadm(country = \"South Korea\", level = 1, path = \"D:/My R/Geodata/\")\nkorea_sd &lt;- korea_sd |&gt; \n  st_as_sf()\nkorea_sgg &lt;- gadm(country = \"South Korea\", level = 2, path = \"D:/My R/Geodata/\")\nkorea_sgg &lt;- korea_sgg |&gt; \n  st_as_sf()\n\n그런데 파일을 열어보고서 경악한다. 행정구역 코드가 없다. 그래서 이 방법은 포기한다.\n행정구역 파일은 통계청의 통계지리정보서비스에서 구할 수 있다. 다운받는 방법을 익히면 좋겠지만, 시간 절약을 위해 다운받아 정리한 파일을 그냥 제공한다. 프로젝트 폴더에 파일을 저장한 후, 아래의 코드를 통해 불러온다.\n\nsido_shp &lt;- st_read(\"sido.shp\", options = \"ENCODING=CP949\")\nsigungu_shp &lt;- read_sf(\"sigungu.shp\", options = \"ENCODING=CP949\")\n\n두 파일에 대해 서로 다른 함수를 적용한 것을 알 수 있다. st_read() 함수는 가장 보편적으로 사용되는 것으로 불러올 때마다 파일에 대한 정보(지오메트리 유형, 바운딩 박스, CRS 등)가 자동으로 디스플레이된다. 이러한 정보는 항상 유익한 것이지만 보이지 않게 하고 싶을 수도 있다. 이 때 read_sf() 함수를 사용할 수 있다.\n불러들인 파일을 바탕으로 시군구 경계를 그려본다. 지도 제작 전문 패키지인 tmap의 qtm() 함수를 이용하여 시군구 경계에 대한 지도를 빠르게 그려본다. tmap패키지로 지도를 그린다는 것은 ’지도는 지도다.’라는 접근법에 기반하고 있다. tmap의 문법을 새로 배워야 한다는 단점이 있긴 하지만, 지도는 그래프로 환원될 수 없는 고유한 특성이 있고, tmap패키지는 이러한 지도의 고유한 특성을 잘 반영하고 있다. 좀 더 복잡한 tmap의 문법을 사용한 지도 제작은 맨 뒤에서 다루기로 한다.\n\nlibrary(tmap)\nqtm(sigungu_shp)\n\n\n\n\n\n\n\n지역소멸위험지수 데이터를 불러온다. 아래 코드는 지난번 실습 때 rds 파일 포맷으로 저장해 둔 것을 가정한 것이다. 실습의 편의를 위해 파일을 제공하니 프로젝트 폴더에 저장한 후, 아래의 코드를 통해 불러온다.\n\ndata_sigungu &lt;- read_rds(\"data_sigungu.rds\")\n\n도형 데이터(korea_sgg)와 속성 데이터(data_sigungu)를 공통 키(key)를 활용하여 결합한다.\n\nsigungu_data &lt;- sigungu_shp |&gt; \n  left_join(\n    data_sigungu, join_by(SGG1_CD == C1)\n  )\n\n이제 ggplot2 패키지를 이용하여 지도를 제작한다. ’Lab07: 데이터 수집하기’에서 인구소멸위험지수의 시도별 그래프를 제작한 것과 비교해 보라. 그 유사함에 깜짝 놀랄 수도 있다. ggplot2에서는 그래프와 지도의 구분이 없다. 이것은 ggplot2의 장점이자 단점이다.\n\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index_class = case_when(\n      index &lt; 0.2 ~ \"1\",\n      index &gt;= 0.2 & index &lt; 0.5 ~ \"2\",\n      index &gt;= 0.5 & index &lt; 1.0 ~ \"3\",\n      index &gt;= 1.0 & index &lt; 1.5 ~ \"4\",\n      index &gt;= 1.5 ~ \"5\"\n    ),\n    index_class = fct(index_class, levels = as.character(1:5))\n  )\n\nclass_color &lt;- c(\"1\" = \"#d7191c\", \"2\" = \"#fdae61\",\n                 \"3\" = \"#ffffbf\", \"4\" = \"#a6d96a\", \n                 \"5\" = \"#1a9641\")\nggplot() +\n  geom_sf(data = sigungu_data, aes(fill = index_class), show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(name = \"Classes\", \n                    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \n                               \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n                    values = class_color, drop = FALSE)"
  },
  {
    "objectID": "exec_12.html#인터랙티브-지도-제작",
    "href": "exec_12.html#인터랙티브-지도-제작",
    "title": "소통하기: 지리공간적 시각화",
    "section": "\n3 인터랙티브 지도 제작",
    "text": "3 인터랙티브 지도 제작\n위에서 사용한 plotly 패키지의 ggplotly() 함수를 활용하면 반응형 지도를 생성할 수 있다. 앞의 코드 둘째 줄에 aes()에 text = name_long이 설정되어 있는데, 마우스로 국가를 가리킬 때 이름이 나타날 수 있게 조치한 것이다.\n\nlibrary(plotly)\nggplotly(world_map)\n\n\n\n\n\n지도 위에서 plotly 가 제공하는 다양한 기능을 적용해 볼 필요가 있다. 인터랙티브 그래프에 비해 인터랙티브 지도의 유용성이 더 높아 보인다.\n우리나라 지도는 다른 방식으로 반응형으로 만들어 본다. 여기서는 ggiraph 패키지를 사용한다. 처음 사용하는 경우라면 먼저 패키지를 인스톨해야 한다. 코드의 전반부는 커서를 특정 시군구 위에 올렸을 때 나타나는 정보를 좀 더 다양하게 하려는 조치이다. 중간의 코드가 핵심인데, 찬찬히 살펴보면 그렇게 복잡하지 않다. 마지막은 완전히 지엽적인 것인데, 커서를 특정 시군구 위에 올렸을 때 색이 회색으로 변하게 하기 위한 것이다.\n\nlibrary(ggiraph)\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = format(index, digits = 4, nsmall = 4),\n    my_tooltip = str_c(\"Name: \", SGG1_FNM, \"\\n Index: \", index)\n  )\ngg &lt;- ggplot() +\n  geom_sf_interactive(\n    data = sigungu_data, \n    aes(\n      fill = index_class, \n      tooltip = my_tooltip, \n      data_id = SGG1_FNM\n      ), \n    show.legend = TRUE) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(\n    name = \"Classes\", \n    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n    values = class_color, drop = FALSE) \ngirafe(ggobj = gg) |&gt; \n  girafe_options(\n    opts_hover(css = \"fill: gray\")\n  )\n\n\n\n\n\n그러나 반응형 지도 제작에 가장 널리 쓰이는 것은 leaflet이다. leaflet은 웹 상의 반응형 지도 제작에 특화된 JavaScript 라이브러리이다. 이 라이브러리를 R에서 쓸 수 있게 도와주는 래퍼 패키지가 leaflet 패키지이다. 패키지 홈페이지가 매우 상세하게 잘 되어 있다. 숙독하기를 권한다.\n\nlibrary(leaflet)\n\n매우 단순한 인터랙티브 지도를 만들어 본다. 자신이 원하는 경위도값과 설명문으로 수정하면 된다.\n\nleaflet() |&gt; \n  addTiles() |&gt; \n  addPopups(126.955184, 37.460422, \"Sang-Il's Office\",\n            options = popupOptions(closeButton = FALSE))\n\n\n\n\n\n\n위에서 작성했던 TFR 세계지도를 leaflet 패키지의 다양한 함수와 아규먼트를 활용하여 인터랙티브 지도를 제작해 본다.\n\nworld_data &lt;- world_data |&gt; filter(!is.na(TFR))\n\nbins &lt;- c(0, 1.5, 2.1, 3, 4, 5, Inf)\npal &lt;- colorBin(\"YlOrRd\", domain = world_data$TFR, bins = bins)\nlabels &lt;- sprintf(\"&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g\",\n  world_data$name_long, world_data$TFR) |&gt; lapply(htmltools::HTML)\n\nleaflet(world_data) |&gt; \n  addProviderTiles(providers$Esri.WorldTopoMap) |&gt; \n  addPolygons(\n    fillColor = ~pal(TFR),\n    weight =  2, \n    opacity = 1,\n    color = \"white\",\n    dashArray = \"3\",\n    fillOpacity = 0.6,\n    highlightOptions = highlightOptions(\n      weight = 5,\n      color = \"#666\",\n      dashArray = \"\",\n      fillOpacity = 0.6,\n      bringToFront = TRUE),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"),\n      textsize = \"15px\",\n      direction = \"auto\")\n  ) |&gt; \n  addLegend(\n    pal = pal, values = ~TFR, opacity = 0.6, title = NULL,\n    position = \"bottomright\"\n  )\n\n\n\n\n\n\n우리나라 시군구 단위의 인구소멸위험지수에 대한 지도를 반응형으로 만들어 본다. 여기서는 tmap을 활용한다. 해당 시군구 위에 클릭하면 지역소멸위험지수가 나타난다.\n\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = as.numeric(index)\n  )\ntmap_mode(mode = \"view\")\nmy_tmap &lt;- tm_shape(sigungu_data) + \n  tm_polygons(\n    col = \"index\",\n    palette = class_color, \n    breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n    labels = c(\"&lt; 0.2\", \"0.2~0.5\", \"0.5~1.0\", \"1.0~1.5\", \"&gt;= 1.5\"),\n    title = \"Classes\", \n    popup.vars=c(\"지역소멸위험지수: \" = \"index\"), \n    popup.format = list(index = list(digits = 3)), \n    id = \"SGG1_FNM\", \n    alpha = 0.6, \n    border.alpha = 0.5\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 2)\nmy_tmap\n\n\n\n\n\ntmap_save(my_tmap, \"지방소멸위험지수.html\")"
  },
  {
    "objectID": "exec_12.html#패키지와-tidyverse-패키지",
    "href": "exec_12.html#패키지와-tidyverse-패키지",
    "title": "R과 데이터사이언스 과정",
    "section": "\n1 패키지와 tidyverse 패키지",
    "text": "1 패키지와 tidyverse 패키지\n\n1.1 패키지\n패키지는 유사한 과업을 수행하는데 도움을 주는 함수들의 묶음 정도로 정의할 수 있다. 현재 CRAN(The Comprehensive R Archive Network)에는 20,000개 정도의 패키지가 등록되어 있다고 한다. CRAN에 패키지를 등록하는게 쉽지 않은 일이기 때문에 GitHub과 같은 곳을 통해 접근 가능한 패키지까지 합치면 도대체 몇 개의 R 패키지가 세상에 존재하는지 알기 어렵다.\n패키지를 사용하기 위해서는 해당 패키지가 사용자의 디바이스에 물리적으로 인스톨되어 있어야 하고, R 세션에서 패키지를 불러와야 한다. 패키지를 인스톨하는 방법은 두 가지 이다. 스크립트 내에서 패키지를 반복해서 인스톨하는 것은 합리적이지 않기 때문에 전자의 관행을 추천한다.\n\nOutput 창의 Packages 탭 선택: Install 아이콘을 클릭하고 패키지 이름 입력\n스크립트 내에서 인스톨하기: install.packages(\"패키지명\")\n\n쌍따옴표 속에 패키지 이름을 타이핑해야 한다. 한번 인스톨이 되면 업데이트하지 않는 한 새롭게 패키지를 인스톨할 필요가 없다. 인스톨된 패키지를 사용하려면 스크립트 내에서 다음과 같이 타이핑하고 실행한다.\n\nlibrary(패키지명)\n\n괄호 속에 패키지명을 기입해야 한다.\n\n\n\n\n\n\n노트\n\n\n\n\n\ninstall.packages()함수에서는 반드시 패키지명을 쌍따옴표로 싸야하지만, library()함수에서는 그렇지 않다. 불러온 패키지는 R 세션이 유지되는 동안 내내 사용할 수 있지만, R 세션을 끝내고 다시 시작하면 다시 library()함수를 이용해 다시 불러와야 한다. 그래서 R 스크립트 파일의 시작 부분에는 패키지를 불러오는 코드를 위치시키고, 다시 스크립트 파일을 열 때마다 그 부분을 재실행하는 것이 좋은 습관이다.\n\n\n\n\n1.2 tidyverse 패키지\n데이터사이언스 과정의 각 단계는 특징적인 과업으로 구성되어 있고, 거기에 맞춰 특징적인 함수들을 장착한 패키지들이 개발되어 왔다. 그런데 최근 RStudio는 데이터사이언스와 밀접히 관련된 패키지들을 모아 일종의 엄브렐러 패키지인 tidyverse를 만들어 제공하고 있다. tidyverse 패키지는 패키지의 패키지인데, 핵심적인 구성 패키지에 다음과 같은 것들이 있다.\n\nggplot2: 시각화하기\ndplyr: 변형하기\ntidyr:정리하기\nreadr: 불러오기\ntibble: 데이터 프레임 관련\nstringr: 문자열 처리 관련\nforcats: 범주 변수(팩터) 처리 관련\npurrr: 함수형 프로그래밍(functional programming) 관련\nlubridate: 일시 및 시간 처리 관련\n\n\n\n\n\n\n그림 2: tidyverse의 핵심 패키지(https://www.tidyverse.org/)\n\n\ntidyverse패키지를 사용하는 것의 장점은 이 패키지만 불러오면 구성 패키지까지 한꺼번에 사용할 수 있게 된다는 점이다. 스크립트 내에서 다음과 같은 코드를 실행한다.\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "exec_12.html#시각화하기",
    "href": "exec_12.html#시각화하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n2 시각화하기",
    "text": "2 시각화하기\n\n2.1 데이터 살펴보기\n이 실습을 위해 남극 파머군도(Palmer Archipelago)에 서식하는 펭귄 성체의 신체 계측 데이터를 사용한다. 이 데이터는 palmerpenguins라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다.\n\nlibrary(palmerpenguins)\n\n이제 이 페키지에 포함되어 있는 penguins라는 이름의 데이터를 불러온다.\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n데이터를 자세히 살펴보면 몇 가지를 알 수 있다.\n\n티블(tibble)이라는 형식의 데이터 프레임이다. 티블은 tidyverse의 공식 데이터 프레임 포맷이다.\n관측개체는 344개, 변수는 8개이다.\nspecies, island, sex 변수의 유형은 팩트형(fctr)이고, bill_length_mm, bill_depth_mm은 실수형(dbl)이고, 나머지는 정수형(int)이다.\n\n변수가 많아지면 전체 데이터를 조망하기 어렵기 때문에, 최초의 tidyverse 함수인 glimpse()를 사용하여 데이터의 행과 열을 바꾸어 보자. 변수 위주로 데이터를 개관하고자 할 때 매우 유용하다.\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\n\n\n\n\n힌트\n\n\n\npenguins데이터 내 속성들에 대한 설명을 보고싶다면 Console에 help(penguins) 또는 ?penguins를 입력한 뒤 실행한다.\n\n\n\n2.2 그래프 만들기\n이 penguins 데이터와 ggplot2 패키지를 이용하여 “펭귄의 날개 길이와 몸무게의 관계”를 표현하는 그래프를 작성해 보자. ggplot2의 문법에 대한 사항은 따로 공부할 기회가 있으므로 여기서는 제작 과정을 한 번 따라가 본다.\n\n2.2.1 플롯 객체의 지정\nggplot()이라는 함수를 통해 플롯 제작을 개시하는 단계이며, 어떤 데이터를 사용할지를 지정한다.\n\nggplot(data = penguins)\n\n\n\n\n\n\n\n\n2.2.2 플롯의 시각속성 매핑\n데이터가 어떤 시각속성(aesthetics)으로 표현될 것인가를 지정한다. 여기서는 간단히 어떤 변수들이 x-축과 y-축에 나타나는지만 지정한다. mapping = aes() 아규먼트가 핵심이다. 보통 mapping은 생략하고 aes()만 쓴다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n\n\n\n\n\n\n\n2.2.3 플롯의 기하객체 지정\n데이터가 어떤 기하객체(geometric object)로 표현될 것인가 혹은 어떤 그래프 유형으로 표현될 것이가를 지정한다. geom 아규먼트가 핵심인데, geom_point()는 데이터를 포인트라고 하는 기하객체로 표현한다는 것을 지정한 것으로 결국 산포도(scatterplot)라는 그래프 유형을 산출하게 된다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n2.2.4 시각속성의 첨가\n이러한 관련성이 펭귄의 종족에 따라 다르게 나타나는지를 탐색하기 위해 color 라는 시각속성을 species라는 변수에 적용한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n2.2.5 기하객체 레이어의 첨가\n두 변수의 관련성을 보여주는 선형 기하객체를 첨가한다. 여기서는 geom_smooth()를 이용하여 OLS 회귀선을 첨가한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n2.2.6 라벨링 등 마무리 작업\nlabs()를 이용하여 그래프의 제목(title), 부제목(subtitle), 축이름, 범례 표제 등을 지정한다.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\"\n  )"
  },
  {
    "objectID": "exec_12.html#변형하기",
    "href": "exec_12.html#변형하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n3 변형하기",
    "text": "3 변형하기\n변형하기와 관련된 함수들은 대부분 dplyr 패키지에 포함되어 있다.\n\n3.1 데이터 살펴보기\n이 실습을 위해 미국 교통통계국(U.S. Bureau of Transportation)이 제공하는 데이터를 사용하는데, 이것은 2013년 한 해 동안 미국 뉴욕시를 출발한 336,776대의 항공기에 대한 정보를 담고 있다. 이 데이터는 nycflights13 이라는 패키지에 포함되어 있으므로 해당 패키지를 불러온다. 그리고 나서 패키지에 포함되어 있는 flights라는 이름의 데이터를 불러온다.\n\nlibrary(nycflights13)\nglimpse(flights)\n\nRows: 336,776\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n\n\n\n\n\n\n힌트\n\n\n\nflights데이터 내 속성들에 대한 설명을 보고싶다면 Console에 help(flights) 또는 ?flights를 입력한 뒤 실행한다.\n\n\n\n3.2 주요 함수\n여기서는 가장 널리 사용되는 6개 함수에 대해서만 개략적으로 다룬다. 그 6개 함수는 select(), filter(), arrange(), mutate(), group_by(), summerize()이다. 조교의 도움을 받아 각 함수가 무슨 일을 한 것인지 이해한다.\n\n3.2.1 select() 함수\n열(변수) 중 일부를 솎아낸다. 즉, 변수의 갯수를 줄인다.\n\nselect(flights, year, month, day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\n\n3.2.2 filter() 함수\n특정 열(변수)에 의거해 조건을 만족하는 행을 솎아낸다. 즉 관측개체의 갯수를 줄인다.\n\nfilter(flights, month == 1 & day == 1)\n\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.3 arrange() 함수\n특정 열(변수)에 의거해 행의 순서를 바꾼다.\n\narrange(flights, year, month, day)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.4 mutate() 함수\n기존의 열(변수)을 변형하여 새로운 열(변수)을 생성한다.\n\nmutate(flights,\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60\n  )\n\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, gain &lt;dbl&gt;, speed &lt;dbl&gt;\n\n\n\n3.2.5 group_by() 함수\n열(변수)(범주형 변수, categorical variables)에 의거해 전체 행을 그룹으로 분할한다. 데이터 프레임이 내부적으로 12개의 달로 분할된다.\n\ngroup_by(flights, month)\n\n# A tibble: 336,776 × 19\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n3.2.6 summerize() 함수\n열(변수)의 통계량을 산출하여 새로운 데이터 프레임의 새로운 열(변수)에 저장한다. 모든 항공기의 평균출발지연시간을 계산한 것이다.\n\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  delay\n  &lt;dbl&gt;\n1  12.6\n\n\n위의 group_by() 함수와 결합하면, 그룹별로 열(변수)의 통계량을 산출하여 새로운 열(변수)에 저장할 수 있다. 일단위로 평균출발지연시간을 계산한 것이다.\n\nby_day &lt;- group_by(flights, year, month, day)\nsummarize(by_day, delay = mean(dep_delay, na.rm = TRUE))\n\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day delay\n   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n 1  2013     1     1 11.5 \n 2  2013     1     2 13.9 \n 3  2013     1     3 11.0 \n 4  2013     1     4  8.95\n 5  2013     1     5  5.73\n 6  2013     1     6  7.15\n 7  2013     1     7  5.42\n 8  2013     1     8  2.55\n 9  2013     1     9  2.28\n10  2013     1    10  2.84\n# ℹ 355 more rows"
  },
  {
    "objectID": "exec_12.html#정리하기",
    "href": "exec_12.html#정리하기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n4 정리하기",
    "text": "4 정리하기\n정리하기와 관련된 함수들은 대부분 tidyr 패키지에 포함되어 있다. 많은 함수가 있지만 가장 중요한 두 개의 함수에만 집중한다.\n\n4.1 데이터 살펴보기\n이 실습에서는 tidyverse 패키지에 포함되어 있는 매우 단순한 데이터를 사용한다. 이 두 데이터는 정돈된 데이터(tidy data)가 아니다. 정돈된 데이터가 무엇인지에 대해서는 다음 장에서 다룬다. 여기서는 정돈되지 않은 데이터를 정돈된 데이터로 만드는 과정을 맛본다.\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n\n\n\n4.2 주요 함수\n\n4.2.1 pivot_longer() 함수\ntable4a에서 1999과 2000은 변수명일 수 없다. year라는 변수의 속성이어야 한다.\n\npivot_longer(\n  table4a, \n  cols = c(`1999`, `2000`),\n  names_to = \"year\",\n  values_to = \"cases\"\n)\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\n\n4.2.2 pivot_wider() 함수\ntable2에서 type 변수는 두 개의 변수명을 포함하고 있다. 즉, cases와 population은 속성값이라기 보다는 변수명이다.\n\npivot_wider(\n  table2, \n  names_from = \"type\",\n  values_from = \"count\"\n)\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583"
  },
  {
    "objectID": "exec_12.html#불러오기",
    "href": "exec_12.html#불러오기",
    "title": "R과 데이터사이언스 과정",
    "section": "\n5 불러오기",
    "text": "5 불러오기\n불러오기와 관련된 함수들은 대부분 readr 패키지에 포함되어 있다. 여러 유형의 파일을 불러오기 위해 여러 함수가 존재하지만, 콤마분리값(comma-separated values, CSV) 형식의 데이터를 불러오는 함수(read_csv())만 실습한다.\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\nglimpse(students)\n\nRows: 6\nColumns: 5\n$ `Student ID`   &lt;dbl&gt; 1, 2, 3, 4, 5, 6\n$ `Full Name`    &lt;chr&gt; \"Sunil Huffmann\", \"Barclay Lynn\", \"Jayendra Lyne\", \"Leo…\n$ favourite.food &lt;chr&gt; \"Strawberry yoghurt\", \"French fries\", \"N/A\", \"Anchovies…\n$ mealPlan       &lt;chr&gt; \"Lunch only\", \"Lunch only\", \"Breakfast and lunch\", \"Lun…\n$ AGE            &lt;chr&gt; \"4\", \"5\", \"7\", NA, \"five\", \"6\""
  },
  {
    "objectID": "exec_12.html#파이프-연산자pipe-operator",
    "href": "exec_12.html#파이프-연산자pipe-operator",
    "title": "R과 데이터사이언스 과정",
    "section": "\n6 파이프 연산자(pipe operator)",
    "text": "6 파이프 연산자(pipe operator)\n우리는 이전 실습에서 할당 연산자(&lt;-)에 대해 배웠다. 오늘 살펴본 다양한 변형의 결과를 다른 데이터 프레임에 담고 싶으면 다음과 같이 할당 연산자를 사용할 수 있다.\n\nflights_day1 &lt;- filter(flights, month == 1 & day == 1)\nglimpse(flights_day1)\n\nRows: 842\nColumns: 19\n$ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\n앞으로 할당 연산자보다 훨씬 더 빈번하게 사용하게 될 연산자를 소개하려고 한다. 그것은 파이프 연산자(pipe operator)라는 것으로, %&gt;% 혹은 |&gt;로 표시하는 것이다. 원래 이 연산자의 원리는 magrittr 패키지에서 처음 소개되었는데, 차츰 R 커뮤니티에 파급되더니 급기야는 대세로 자리잡았다. 그래서 특정 패키지를 깔지 않아도 파이프 연산자를 사용할 수 있게 하기 위해 Base R에 도입되었고(이것을 네이티브 파이프 연산자(native pipe operator)라고 부른다), 부호로 %&gt;% 대신 |&gt;를 사용한다. 둘 사이에 차이는 거의 없지만, 후자가 점점 표준이 되고 있기 때문에 본 수업에서는 그것을 사용한다. 다음의 두 가지에 유의한다.\n\n현재 RStudio의 디폴트는 %&gt;%로 설정되어 있다. 이것을 Tools &gt; Global Options &gt; Code에 가서 ’Use native pipe operator, |&gt; (requires R 4.1+)’를 선택해 주어야 한다. 아래의 그림 3 를 참고하라.\n\n\n\n\n\n\n그림 3: 파이프 연산자(https://r4ds.hadley.nz/data-transform)\n\n\n\n단축키는 Crtl + Shift + M이다. 다른 건 몰라도 이 단축키만은 반드시 기억해야 한다.\n\n다음의 세 코드를 비교해 보라. 우선 아래의 경우는 flights1과 flights2와 같은 중간 변수가 계속 생성되어 메모리를 차지하게 된다.\n\nflights1 &lt;- filter(flights, dest == \"IAH\")\nflights2 &lt;- mutate(flights1, speed = distance / air_time * 60)\nflights3 &lt;- select(flights2, year:day, dep_time, carrier, flight, speed)\narrange(flights3, desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n혹은 다음과 같이 함수가 다른 함수 속에 계속 포함되는 형식으로 만들 수 있는데, 코드가 매우 복잡해 진다.\n\narrange(\n  select(\n    mutate(\n      filter(\n        flights, \n        dest == \"IAH\"\n      ),\n      speed = distance / air_time * 60\n    ),\n    year:day, dep_time, carrier, flight, speed\n  ),\n  desc(speed)\n)\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows\n\n\n다음은 위 두 경우와 달리 파이프 연산자를 사용한 경우이다. 동일한 결과를 가져다 주지만 훨씬 더 간결하고 직관적이고 이해하기 쉽다. 파이프 연산자의 사용 원리는 뒤에서 자세히 배운다.\n\nflights |&gt; \n  filter(dest == \"IAH\") |&gt; \n  mutate(speed = distance / air_time * 60) |&gt; \n  select(year:day, dep_time, carrier, flight, speed) |&gt; \n  arrange(desc(speed))\n\n# A tibble: 7,198 × 7\n    year month   day dep_time carrier flight speed\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;\n 1  2013     7     9      707 UA         226  522.\n 2  2013     8    27     1850 UA        1128  521.\n 3  2013     8    28      902 UA        1711  519.\n 4  2013     8    28     2122 UA        1022  519.\n 5  2013     6    11     1628 UA        1178  515.\n 6  2013     8    27     1017 UA         333  515.\n 7  2013     8    27     1205 UA        1421  515.\n 8  2013     8    27     1758 UA         302  515.\n 9  2013     9    27      521 UA         252  515.\n10  2013     8    28      625 UA         559  515.\n# ℹ 7,188 more rows"
  },
  {
    "objectID": "exec_12.html#기본-구조",
    "href": "exec_12.html#기본-구조",
    "title": "R과 데이터사이언스 과정",
    "section": "1 기본 구조",
    "text": "1 기본 구조\nShiny는 크게 세 부분으로 나뉘어 진다(그림 1).\n첫째, ui(혹은 ux) 부분이다. 프론트엔트(front-end) 부분으로 입력을 받고 출력을 표출하는 부분이다.\n둘째, server 부분이다. 백엔드(back-end) 부분으로 받은 입력으로 출력을 산출하는 부분이다.\n셋째, 결합 부분이다. ui와 server 부분을 결합해 웹 앱을 실행하는 부분이다.\n\n\n\n\n\n\n그림 1: Shiny의 구조(https://bookdown.org/hneth/i2ds/shiny.html)\n\n\n\n이건 좀 이상해. 정말 이상해.\n다시 한번\n또 이상일"
  },
  {
    "objectID": "exec_11.html#기본-동작",
    "href": "exec_11.html#기본-동작",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "\n1 기본 동작",
    "text": "1 기본 동작\n\n1.1 기본 구조\nShiny는 크게 세 부분으로 나뉘어 진다(그림 1).\n첫째, UI(혹은 UX) 부분이다. 프론트엔트(front-end) 부분으로 입력을 받고, Server에서 산출된 출력을 표출하는 부분이다.\n둘째, Server 부분이다. 백엔드(back-end) 부분으로 UI에서 받은 입력에 바탕으로 출력을 산출하는 부분이다.\n셋째, 결합 및 실행 부분이다. UI와 Server 부분을 결합해 웹 앱을 실행하는 부분이다. 결합 및 실행은 단일 파일 속에 UI와 Server를 함께 다루는 방식과, 두 개의 파일로 분할하여 다루는 방식으로 나뉜다. 여기서는 전자를 중심으로 설명한다.\n\n\n\n\n\n그림 1: Shiny의 구조(https://bookdown.org/hneth/i2ds/shiny.html)\n\n\n\n1.2 Shiny 프로젝트의 생성\n여기서는 RStudio에서 Shiny 프로젝트를 생성하는 방법에 대해 배운다. New Project &gt; New Directory &gt; Shiny Application을 선택한다. 그림 2 에서 Directory name과 Subdirectory의 위치를 설정한다.\n\n\n\n\n\n그림 2: Shiny 프로젝트의 생성\n\n\n이렇게 하면 Shiny 프로젝트가 생성되고, 자동적으로 app.R이라는 스크립트 파일이 생성된다.\n\n1.3 웹 앱의 생성\napp.R에서 스크립트 윈도우 오른쪽 상단에 위치한 Run App 버튼을 클릭하면 그림 3 과 같은 웹 앱이 새로운 윈도우에 생성된다. 왼편의 슬라이더를 움직이면 오른편의 히스토그램이 변한다는 점을 확인한다. 즉 빈(bin)의 개수를 달리하면서 데이터 분포를 탐색해보기 위한 단순한 웹 앱이 만들어진 것이다.\n\n\n\n\n\n그림 3: 단순한 웹 앱 예시\n\n\n이 단순한 웹 앱을 살펴본다. 다음과 같은 점을 확인할 수 있다.\n첫째, 크게 두 부분으로 구성되어 있는데, 왼편의 슬라이더가 있는 부분과 오른편의 히스토그램이 있는 부분으로 나뉜다. 부차적으로 상단에 제목(“Old Faithful Geyser Data”)이 있는 부분도 존재한다. 이 모든 것이 UI를 구성한다. 위에서 UI는 입력을 받고 출력을 표출한다고 했다. 왼편의 슬라이더바가 입력을 받는 부분이고, 오른편의 플롯 영역이 출력을 표출하는 부분이다.\n둘째, 사용자의 입력은 빈(bin)의 갯수이고, Server는 이 값을 바탕으로 히스토그램이라는 출력을 생성한다. 생성된 출력은 UI로 이동하여 표출된다. 사용자의 입력값이 바뀌면 이 과정이 반복되고 히스토그램이 바뀌게 된다.",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "exec_11.html#함수의-종류",
    "href": "exec_11.html#함수의-종류",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n2 함수의 종류",
    "text": "2 함수의 종류\n\n2.1 입력 함수\n입력 함수 혹은 입력 위젯 생성 함수의 종류는 다양한데, R Shiny Components 웹페이지 기준으로 대략 25개 정도이다. 그림 4 은 그 중 일부를 보여주고 있다.\n\n\n\n\n\n그림 4: 입력 위젯의 종류(https://shiny.posit.co/r/getstarted/build-an-app/reactive-flow/ui-inputs.html)\n\n\n몇 가지 주목할 사항이 있다.\n첫째, 모든 함수의 이름이 *Input() 형식인 것은 아니다. 특히 버튼 형식의 경우 *Button() 혹은 *Buttons() 형식을 띤다. 이 외에 *Link(), *switch()로 끝나는 함수도 있다.\n둘째, 입력 함수에 따라 인수의 종류가 다르다. 자세한 사항은 R Shiny Components 웹페이지를 참조한다.\n\n2.2 출력 함수: 출력 표출 함수와 출력 생성 함수\n출력 함수는 서버에서 생성된 출력을 UI에서 표출해주는 출력 표출(바인딩) 함수와 서버에서 실질적으로 출력을 창출하는 출력 생성 함수로 구분된다. 출력 함수의 종류는 출력의 형식(플롯, 테이블, 텍스트, 이미지 등)에 의해 결정되기 때문에 기본적인 출력의 종류에 따라 출력 표출 함수와 출력 생성 함수가 쌍을 이룰 수 밖에 없다.\n다음은 다섯 가지 기본 출력 함수를 보여준다. 출력 표출 함수는 *Output()의 형식을, 출력 생성 함수는 render*({})의 형식을 취한다.\n\n\n\n\n\n\n\n형식\n출력 표출 함수\n출력 생성 함수\n\n\n\n플롯\nplotOutput(outputID = \"\")\nrenderPlot()\n\n\n테이블\ntableOutput(outputID = \"\")\nrenderTable()\n\n\n일반 텍스트\ntextOutput(outputID = \"\")\nrenderText()\n\n\n사전 포맷된 텍스트\nverbatimeTextOutput(outputID = \"\")\nrenderPrint()\n\n\n이미지\nimageOutput(outputID = \"\")\nrenderImage()\n\n\n\n그런데 특히 주요 시각화 패키지들은 Shiny 웹 앱 구축을 염두에 두고 개별적인 출력 표출 함수와 출력 생성 함수를 제공하고 있다. 중요한 패키지에 대해 이를 정리하면 다음과 같다. 모두 패키지명Output()형식과 render패키지명({})의 형식을 띤다.\n\n\n패키지\n출력 표출 함수\n출력 생성 함수\n\n\n\nDT\nDTOutput(outputID = \"\")\nrenderDT({})\n\n\nreactable\nreactableOutput(outputID = \"\")\nrenderReactable({})\n\n\nplotly\nplotlyOutput(outputID = \"\")\nrenderPlotyl({})\n\n\necharts4r\necharts4rOutput(outputID = \"\")\nrenderEcharts4r({})\n\n\nleaflet\nleafletOutput(outputID = \"\")\nrenderLeaflet({})\n\n\ntmap\ntmapOutput(outputID = \"\")\nrenderTmap({})\n\n\n\nR Shiny Components 웹페이지 기준으로 대략 12개 정도이다.\n출력 형식이 패키지마다 다를 수 있기 때문에 개별 패키지 특수적 함수까지 포함하면",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#입출력-함수의-종류",
    "href": "exec_11.html#입출력-함수의-종류",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "\n3 입출력 함수의 종류",
    "text": "3 입출력 함수의 종류\n\n3.1 입력 함수\n앞에서 언급한 것처럼, 입력 함수 혹은 입력 위젯 생성 함수의 종류는 다양하다. R Shiny Components 웹페이지 기준으로 대략 25개 정도이다. 그림 4 는 그 중 일부를 보여주고 있다.\n\n\n\n\n\n그림 4: 입력 위젯의 종류(https://shiny.posit.co/r/getstarted/build-an-app/reactive-flow/ui-inputs.html)\n\n\n몇 가지 주목할 사항이 있다.\n첫째, 모든 함수의 이름이 *Input() 형식인 것은 아니다. 특히 버튼 형식의 경우 *Button() 혹은 *Buttons() 형식을 띤다. 이 외에 *Link(), *switch()로 끝나는 함수도 있다.\n둘째, 입력 함수의 인수가 중요하다. 입력값에 이름을 부여하는 inputID 인수와 입력 위젯에 나타날 설명 글귀를 지정하는 label 인수는 공통이다. 그러나 나머지 인수는 입력 함수에 따라 달라진다. 위의 예에서 sliderInput() 입력 함수는 min, max, value라는 추가적인 인수를 갖는데, min과 max는 슬라이더의 최대 및 최소값을, value는 기본값을 지정하는 인수이다. 입력 함수별 인수에 대한 자세한 사항은 R Shiny Components 웹페이지를 참조한다.\n\n3.2 출력 함수: 출력 표출 함수와 출력 생성 함수\n출력 함수는 서버에서 생성된 출력을 UI에서 표출해주는 출력 표출(바인딩) 함수와 서버에서 실질적으로 출력을 창출하는 출력 생성 함수(렌더링 함수)로 구분된다. 출력 함수의 종류는 출력의 형식(플롯, 테이블, 텍스트, 이미지 등)에 의해 결정되기 때문에 기본적인 출력의 종류에 따라 출력 표출 함수와 출력 생성 함수가 쌍을 이룰 수 밖에 없다.\n다음은 다섯 가지 기본 출력 함수의 쌍을 보여준다. 출력 표출 함수는 *Output()의 형식을, 출력 생성 함수는 render*({})의 형식을 취한다.\n\n\n표 1: 기본 출력 함수\n\n\n\n\n\n\n\n\n형식\n출력 표출 함수(UI)\n출력 생성 함수(Server)\n\n\n\n플롯\nplotOutput(outputID = \"\")\nrenderPlot({})\n\n\n테이블\ntableOutput(outputID = \"\")\nrenderTable({})\n\n\n일반 텍스트\ntextOutput(outputID = \"\")\nrenderText({})\n\n\n사전 포맷된 텍스트\nverbatimeTextOutput(outputID = \"\")\nrenderPrint({})\n\n\n이미지\nimageOutput(outputID = \"\")\nrenderImage({})\n\n\n\n\n\n\n그런데 특히 주요 시각화 패키지들은 Shiny 웹 앱 구축을 염두에 두고 개별적인 출력 표출 함수와 출력 생성 함수를 제공하고 있다. 중요한 패키지에 대해 이를 정리하면 다음과 같다. 모두 패키지명Output()형식과 render패키지명({})의 형식을 띤다.\n\n\n표 2: 패키지 출력 함수\n\n\n\n\n\n\n\n\n패키지\n출력 표출 함수(UI)\n출력 생성 함수(Server)\n\n\n\nDT\nDTOutput(outputID = \"\")\nrenderDT({})\n\n\nreactable\nreactableOutput(outputID = \"\")\nrenderReactable({})\n\n\nplotly\nplotlyOutput(outputID = \"\")\nrenderPlotyl({})\n\n\necharts4r\necharts4rOutput(outputID = \"\")\nrenderEcharts4r({})\n\n\nleaflet\nleafletOutput(outputID = \"\")\nrenderLeaflet({})\n\n\ntmap\ntmapOutput(outputID = \"\")\nrenderTmap({})\n\n\n\n\n\n\nShiny 웹 앱에서의 활용을 염두에 둔 패키지들은 모두 이러한 출력 함수의 쌍을 제공하고 있다. 따라서 출력 함수는 굉장히 많을 수 있다. R Shiny Components 웹페이지는 기본 5개의 함수쌍에 주요 패키지를 포함하는 12개 정도의 출력 함수쌍을 예시로 제시하고 있다.",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "exec_11.html#shiny의-기본-문법-체계",
    "href": "exec_11.html#shiny의-기본-문법-체계",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "\n2 Shiny의 기본 문법 체계",
    "text": "2 Shiny의 기본 문법 체계\n이제 그림 3 의 웹 앱을 생성한 코드를 살펴보도록 한다. 코드 속에는 다양한 설명이 포함되어 있는데 그것을 제거하고 코드만 남기면 다음만 남는다. 대충 보아도 문법이 tidyverse와는 많이 다르다는 점을 금방 알 수 있다. 따라서 shiny의 문법 체계는 따로 익힐 수 밖에 없다.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n    titlePanel(\"Old Faithful Geyser Data\"),\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(inputId = \"bins\",\n                        label = \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n        mainPanel(\n           plotOutput(outputId = \"distPlot\")\n        )\n    )\n)\n\nserver &lt;- function(input, output) {\n    output$distPlot &lt;- renderPlot({\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\nshinyApp(ui = ui, server = server)\n\n코드를 자세히 살펴보자. 우선 shiny라는 R 패키지를 불러와야 한다. 코드가 ui, server, shinyApp의 세 부분으로 나뉘어져 있다는 것을 알 수 있고, 이것이 위에서 설명한 UI 부분, Server 부분, 결합 및 실행 부분을 담당한다는 점을 쉽게 이해할 수 있다.\n\n2.1 UI 부분\nUI 부분은 다양한 함수들이 위계 구조를 이루고 있는데, 전체 형태를 결정하는 UI 구조 함수(컨테이너 함수)가 입력 함수와 출력 함수를 둘러싸고 있는 구조이다. 그림 4 는 이것을 요약한 것이다.\n\n\n\n\n\n그림 4: UI 컨테이너 함수의 계층 구조 https://mastering-shiny.org/action-layout.html\n\n\n첫째, 컨테이너 함수가 위계 구조를 이루고 있다. 최상위 fluidPage() 함수는 titlePanel()과 sidebarLayout()로 구성되고, sidebarLayout()은 다시 sidebarPanel()과 mainPanel()로 구성된다. 하나씩 위계적으로 살펴보면 다음과 같다.\n\n\nfluidPage() : UI의 최상위 컨테이너로서 전체 UI 구조를 관장하며, 브라우저 화면 크기에 따라 자동으로 늘어나고 줄어드는 반응형 레이아웃을 제공한다. 이러한 특성 때문에 ’fluid’라는 이름이 붙었다. 고정 폭을 가진 레이아웃은 fixedPage()를 통해 정의할 수 있다. Shiny 앱에서는 기본적으로 fluidPage()를 사용한다고 생각하면 된다.\n\ntitlePanel() : 제목이 들어가는 부분이다. 생략가능하다.\n\nsidebarLayout(): UI의 핵심 부분으로, 가장 전형적인 “사이드바 + 메인 영역” 레이아웃을 fluidPage() 내에 생성할 수 있게 해준다.\n\nsidebarPanel(): 입력을 받는 부분으로, 입력 함수 혹은 입력 위젯(widget)을 담는 컨테이너이다.\nmainPanel() : 출력을 표출하는 부분으로, 서버에서 생성된 출력 객체가 UI에 표시될 수 있도록 출력 함수를 담는 컨테이너이다.\n\n\n\n\n\n둘째, sidebarPanel() 내의 sliderInput()은 특정한 입력 함수 혹은 입력 위젯 생성 함수이다. 여기서는 슬라이더 형태의 입력을 받기 때문에 sliderInput() 함수가 사용된 것이다. 입력의 형태에 따라 다양한 입력 함수가 존재하며, 일반적으로 *Input() 형식을 띤다. 뒤에서 자세히 다룬다. 개별 함수는 상호작용형 인터페이스 컴포넌트로 미리 만들어져 있기 때문에 위젯이라고 부른다. sliderInput()은 다양한 인수로 구성되어 있는데, 가장 중요한 것이 inputId 인수이다. 입력 함수는 위젯을 통해 입력값을 받고 그 입력값은 Server의 input 객체의 한 요소가 되는데 inputId 인수는 input 객체에서 해당 요소를 참조할 ’이름’을 지정한다.\n셋째, mainPanel() 내의 plotOutput()은 특정한 출력 함수 혹은 출력 바인딩(binding) 함수이다. 이것은 Server에서 전달받은 출력 즉 output 객체의 요소를 표출한다. 바인딩 함수라고 부르는 것은 출력 요소와 브라우저의 특정 UI 영역을 ’연결(바인드)’하기 때문이다. 출력의 형태가 플롯(plot)이기 때문에 plotOutput() 함수가 사용된 것이다. 출력의 형태에 따라 다양한 출력 표출 함수가 존재하며, 일반적으로 *Output()의 형식을 띤다. 뒤에서 자세히 다룬다. plotOutput() 함수의 가장 중요한 인수는 outputId로 표출할 output 객체의 요소의 ’이름’을 지정한다. plotOutput(outputId = \"distPlot\")는 서버에서 만들어진 \"distPlot\"라는 이름의 플롯(output 객체의 한 요소)을 해당 위치에 표출한다는 의미이다.\n\n결국 UI는 입력을 받고 출력을 표출하는 두 가지 일을 하는데, 전자는 sliderInput()과 같은 입력 함수를 통해 이루어지며, 후자는 plotOutput()과 같은 출력 함수를 통해 이루어진다. 이들 함수는 출력과 입력의 형식에 따라 일반적으로 *Input()과 *Output()의 형태를 띤다.\n\n\n2.2 Server 부분\nServer 부분은 다음과 같은 구조를 가지고 있다.\n첫째, Server 부분은 반드시 함수로 정의되며, 일반적으로 function(input, output){} 혹은 function(input, output, session){}의 형식을 갖는다(input과 output은 필수이지만 session은 부가적으로 정의될 수 있다). 반드시 함수로 정의되어야 하는 것은 input과 output(부가적으로 session)을 인수로 받아, 입력 변화에 따라 반응형 출력이 생성 및 갱신되는 로직을 정의하기 때문입니다.\n둘째, 출력물은 renderPlot({})과 같은 렌더링 함수를 통해 이루어진다. 이렇게 생성된 출력은 ’이름’이 지정되어 Server의 output 객체의 한 요소로 저장된다. 예를 들어, 코드에서 output$distPlot은 생성된 출력에 \"distPlot\"이라는 이름을 부여하고 이를 output 객체에 해당 이름으로 저장함을 의미한다. 이 이름은 UI의 출력 함수 plotOutput(outputId = \"distPlot\")에서 사용되며, 이를 통해 해당 출력이 UI에 표출된다.\n셋째, 출력의 형태가 플롯이기 때문에 renderPlot({}) 함수가 사용된 것이다. 출력의 형태에 따라 다양한 렌더링 함수가 존재하며, 일반적으로 render*({})의 형식을 띤다. 뒤에서 자세히 다룬다.\n넷째, 입력 함수로부터 전달되어 Server의 input 객체의 요소로 저장된 입력값은 렌더링 함수 내부에서 사용된다. 예를 들어, seq(min(x), max(x), length.out = input$bins + 1)에서 sliderInput() 함수로부터 전달된 bins라는 입력값(즉, input 객체의 한 요소)이 seq() 함수 내부에서 사용된다. 입력값이 달라짐에 따라 히스토그램의 모양이 달라지는 이유가 여기에 있다.\n\n결국 Server는 UI에서 전달된 입력에 기반하여 출력을 산출한다. 구체적으로, input$* 형식의 입력값을 Server 내부에서 사용하여 renderPlot({})과 같은 렌더링 함수를 통해 출력을 생성하고, 그 결과를 output$* 형식으로 저장함으로써 UI에 표출될 수 있도록 한다.\n\n\n2.3 결합 및 실행 부분\nUI와 server 부분은 결합되어 하나의 Shiny 웹 앱을 구성하며, 이를 실행하기 위해 shinyApp() 함수가 사용된다. shinyApp(ui = ui, server = server)에서 볼 수 있듯이, shinyApp() 함수에 UI 부분과 Server 부분을 지정함으로써 Shiny 웹 앱이 생성되고 실행된다.\n이것은 단일 파일 방식으로 결합 및 실행을 행하는 것이다. 콘솔창에서 실행하고자 한다면 다음과 같이하면 된다. 파일명에 app.R과 같은 UI와 Server 부분이 모두 포함된 파일의 이름을 지정하면 된다.\n\nrunApp(\"파일명\")\n\n만일 UI와 Server 부분을 다른 파일로 구성하는 분리 파일 방식인 경우는 다음과 같이 진행한다. 우선 UI 부분의 파일을 따로 만든다. 예를 들어 ui.R이라는 스크립트 파일을 다음과 같이 생성한다. 단일 파일 방식과 달리 UI 부분을 ui 객체에 할당하지 않아도 된다.\n\nlibrary(shiny)\n\nfluidPage(\n    titlePanel(\"Old Faithful Geyser Data\"),\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(inputId = \"bins\",\n                        label = \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n        mainPanel(\n           plotOutput(outputId = \"distPlot\")\n        )\n    )\n)\n\n마찬가지로 Server 부분의 파일을 따로 만든다. 예를 들어 server.R이라는 스크립트 파일을 다음과 같이 생성한다. 단일 파일 방식과 달리 Server 부분을 server라는 객체에 할당하지 않아도 된다.\n\nlibrary(shiny)\n\nfunction(input, output) {\n    output$distPlot &lt;- renderPlot({\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\n콘솔 창에서 다음과 같이 실행한다. 이때 지정한 폴더에는 UI 부분을 정의한 파일(예: ui.R)과 server 부분을 정의한 파일(예: server.R)이 포함되어 있어야 한다. 이름은 반드시 ui.R과 server.R이어야 한다.\n\nrunApp(\"폴더명\")\n\n위의 두 가지 방식을 결합한 제3의 길도 있다. 우선 위의 분리 파일 방식과 같이 UI와 Server 부분에 대한 파일을 개별적을 생성한다. 차이점은 반드시 ui와 server 객체를 할당하는 방식으로 이러우져야 한다는 점이다. my_ui.R의 내용은 다음과 같다. 이 방식에서는 UI 부분의 파일 이름이 반드시 ui.R일 필요가 없다.\n\nui &lt;- fluidPage(\n    titlePanel(\"Old Faithful Geyser Data\"),\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(inputId = \"bins\",\n                        label = \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n        mainPanel(\n           plotOutput(outputId = \"distPlot\")\n        )\n    )\n)\n\nmy_server.R의 내용은 다음과 같다. 마찬가지로 Server 부분의 파일의 이름이 server.R일 필요가 없다.\n\nserver &lt;- function(input, output) {\n    output$distPlot &lt;- renderPlot({\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\n그리고 나서 단일 파일 방식과 같이 app.R 파일을 통해 결합한다. app.R 파일의 내용은 다음과 같다.\n\nlibrary(shiny)\n\nsource(\"my_ui.R\")\nsource(\"my_server.R\")\n\nshinyApp(ui = ui, server = server)\n\nUI 파일과 Server 파일을 분리하는 방식은 코드가 매우 복잡할 때 사용하는 것으로 보통은 단일 파일 방식을 사용한다.",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "exec_11.html#반응성-함수",
    "href": "exec_11.html#반응성-함수",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "\n5 반응성 함수",
    "text": "5 반응성 함수\n\n5.1 정의\nShiny의 반응성(reactivity)이란, 입력값의 변화에 따라 관련된 계산과 출력이 자동으로 재실행ㆍ갱신되는 메커니즘을 의미한다. 좀 더 기술적으로 표현하면 반응성은 입력(input)의 변화가 의존 관계(dependency)를 따라 전파되어, 반응형 표현식과 출력이 자동으로 갱신되는 실행 모델이다.\n반응성 함수란, 입력값에 대한 의존성을 추적하고 입력 변화 시 자동으로 재실행되는 함수를 말한다. 따라서 Shiny에서 반응성 함수는 공통적으로 다음 특징을 갖는다.\n\ninput$*에 의존\n입력이 바뀌면 자동으로 재실행\n사용자가 직접 호출하지 않음\nShiny의 반응성 그래프(dependency graph)에 의해 관리됨\n\n5.2 종류\nShiny의 반응성 함수는 역할에 따라 크게 세 부류로 나눌 수 있다.\n\n5.2.1 렌더링 함수: render* 계열\n렌더링 함수는 반응형 계산을 통해 출력물을 생성하고, 그 결과를 output 객체의 요소로 저장하는 함수이다. 일반 형식은 다음과 같다.\n\nrender*({\n  # 반응형 코드\n})\n\n반드시 output$이름 &lt;- render*({ ... }) 형태로 사용되며, 출력의 “최종 종착점”이며, UI의 *Output()과 1:1로 대응된다. 예시는 다음과 같다.\n\noutput$distPlot &lt;- renderPlot({\n  hist(x, breaks = input$bins)\n})\n\n\n5.2.2 반응형 표현식 함수: reactive({})\n\nreactive({})는 입력값에 따라 달라지는 계산 결과를 반응형 객체로 생성하는 함수이다. 입력을 받아 ’반응성 표현식(reactive expression)’을 생성한다. 여기서 반응성 표현식이란 단순히 최종 산출물(값이나 객체)만을 의미하지 않고, 그 산출물을 관리하는 메커니즘(종속성 추적, 지연 실행, 캐싱 등) 포함하는 동적인 객체를 의미한다. 따라서 반드시 함수 형태로 표기한다.\n하나의 입력이 여러 개의 출력 함수(출력 생성 함수)와 결부되는 경우에 주로 사용되는데 동일한 입력의 중복 사용을 회피하기 위해 해당 입력을 반응성 표현식으로 전환하여 다수의 출력 생성 함수에 입력으로 투입할 수 있다.\n일반 형식은 다음과 같다.\n\nr &lt;- reactive({\n  # 반응형 계산\n})\n\n출력이 아니라 중간 계산 결과를 생성하며, 반환값은 반응형 객체가 되고, 값에 접근할 때는 함수 형식으로 반드시 () 를 사용해야 한다. 예시는 다음과 같다.\n\nbins &lt;- reactive({\n  seq(min(x), max(x), length.out = input$bins + 1)\n})\n\noutput$distPlot &lt;- renderPlot({\n  hist(x, breaks = bins())\n})\n\n입력 함수를 통해 받은 input$bins를 읽어 bins라는 새로운 반응형 객체를 생성하고, 그것을 출력 생성 함수에서 투입하는 방식을 보여주고 있다. 반응형 객체는 반드시 bins()처럼 함수 형식으로 호출해야만 한다.\n그런데, 여기서는 사실 reactive({}) 함수가 반드시 필요한 것은 아니다. 즉, 다음과 같이 해도 무방하다.\n\nbins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\noutput$distPlot &lt;- renderPlot({\n  hist(x, breaks = bins)\n})\n\n그러나 출력 생성 함수가 여러 개 사용되고 거기에 bins가 여러 번 사용된다면 위와 같이 하는 것이 훨씬 효율적이다.\n\n5.2.3 반응형 관찰자 함수: observe*() 계열\n반응형 관찰자 함수는 입력 변화에 반응하여 특정 동작(side effect)을 수행하는 함수이다. 대표적인 함수는 다음과 같다.\n\nobserve()\nobserveEvent()\neventReactive() (중간적 성격)\n\n특징은 값을 반화하지 않고, 출력 생성이 목적도 아니다. 주로 상태 변경, 메시지 출력, UI 업데이트에 사용된다. 다음에 예시가 있다.\n\nobserveEvent(input$go, {\n  cat(\"버튼이 눌렸습니다\\n\")\n})\n\n입력 함수 actionButton(inputID = \"go\", ...)로부터 버튼을 누를 때 마다 \"go\"라는 입력 요소의 값(input$go)이 1씩 증가하고, input$go값이 변할 때마다(즉, 버튼이 눌릴 때마다) Server에서 { } 속의 내용을 실행한다. 위의 예시의 경우 버튼을 클리할 때마다 콘솔에 “버튼이 눌렸습니다”가 출력된다.\n좀 더 현실적인 예시를 제시하면 다음과 같다. 버튼 클릭시 계산을 실행하게 할 수 있다.\n\nobserveEvent(input$go, {\n  result &lt;- heavy_calculation()\n  print(result)\n})\n\nUI 요소를 업데이트하게 할 수 있다.\n\nobserveEvent(input$go, {\n  updateSliderInput(session, \"bins\", value = 20)\n})\n\n파일을 저장하게 할 수 있다.\n\nobserveEvent(input$save, {\n  write.csv(data, \"result.csv\")\n})\n\n사실 observeEvent() 함수는 observe() 함수와 매우 유사하다. 아래는 동일하게 작동한다.\n\nobserve({\n  input$go\n  cat(\"버튼이 눌렸습니다\\n\")\n})\n\n그러나 observeEvent()는 이벤트 중심이고, 의존성을 명확히 분리하며, 가독성과 안전성을 높이는 장점이 있다. 따라서 버튼 처리에는 observeEvent()가 권장된다.",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "exec_11.html#웹-앱-배포deployment",
    "href": "exec_11.html#웹-앱-배포deployment",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n5 웹 앱 배포(deployment)",
    "text": "5 웹 앱 배포(deployment)\n웹 앱을 배포하는 방법은 다양할 수 있지만 여기서는 shinyapp.io를 이용하는 방법에 대해 배운다.\n첫째, 해당 홈페이지(https://www.shinyapps.io/)에 접속한다.\n둘째, 계정을 생성한다.\n\n로그인 후 상단 오른쪽 끝 메뉴 “Tokens” 페이지로 이동\n페이지에서 Show를 통해 인증 토큰(Token)과 Secret 확보: Show secret를 클릭하여 secret까지 보이게 한 후 복사하기\n\n셋째, RStudio에 토큰을 설정한다. 단 한 번만 하면 된다.\n\nR 콘솔에 위에서 복사한 내용 붙여넣기 및 실행\n\n넷째, Publish 버튼 클릭\n\n스크립트 윈도우의 오른쪽 상단에 있는 Publish 버튼 클릭\n배포를 원하는 R 파일만 선택\n\n다섯째, URL을 얻는다. 다음의 형식으로 생성된다.\n\nhttps://userid.shinyapps.io/project_name/",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#웹-앱의-공유",
    "href": "exec_11.html#웹-앱의-공유",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "\n6 웹 앱의 공유",
    "text": "6 웹 앱의 공유\n\n6.1 웹 앱 배포(deployment)\n웹 앱을 배포하는 방법은 다양할 수 있지만 여기서는 shinyapp.io를 이용하는 방법에 대해 배운다.\n첫째, 해당 홈페이지(https://www.shinyapps.io/)에 접속한다.\n둘째, 계정을 생성한다.\n\n로그인 후 상단 오른쪽 끝 메뉴 “Tokens” 페이지로 이동\n페이지에서 Show를 통해 인증 토큰(Token)과 Secret 확보: Show secret를 클릭하여 secret까지 보이게 한 후 복사하기\n\n셋째, RStudio에 토큰을 설정한다. 단 한 번만 하면 된다.\n\nR 콘솔에 위에서 복사한 내용 붙여넣기 및 실행\n\n넷째, Publish 버튼 클릭\n\n스크립트 윈도우의 오른쪽 상단에 있는 Publish 버튼 클릭\n배포를 원하는 R 파일만 선택\n\n다섯째, URL을 얻는다. 다음의 형식으로 생성된다.\n\nhttps://userid.shinyapps.io/project_name/\n\n6.2 Quarto와 Shiny의 결합\n\n상황: Quarto 대시보드의 일부 영역에서 Shiny 사용\n\n두 가지 접근\n\n\nShiny 중심 방식: Shiny 웹 앱의 생성\n\nQuarto 대시보드 내에서 Quarto 문법으로 Shiny 웹 앱 구축\nQuarto 대시보드 전체가 Shiny 웹 앱화: shinyapps.io를 통해 배포\n사례: https://sangillee.shinyapps.io/Dashboard_Example/\n\n\n\nQuarto 중심 방식: Quarto 대시보드의 유지\n\nQuarto 대시보드 속에 독립적으로 구축된 Shiny 웹 앱 임베딩\n여전히 Quarto 대시보드: Quarto Pub을 통해 배포\n사례: https://sangillee.snu.ac.kr/dashboard_examples/\n\n\n\n\n\n\n6.2.1 Shiny 중심 방식\n\n\n옵션 1: Quarto를 Shiny 웹 앱의 레이아웃 설정 도구로 사용\n\n\nshiny 패키지: fluidPage()\n\n\ntitlePanel(), SidebarLayout(), sidebarPanel(), mainPanel()\n\n\n\n\nbslib 패키지: page_sidebar()\n\n\nsidebar = sidebar(), card()\n\n\n\n\n\n옵션 2: Quarto 대시보드 내에서 Shiny 웹 앱 구축\nhttps://quarto.org/docs/dashboards/interactivity/shiny-r.html\nYAML 헤더에 다음 첨가: server: shiny\n\nui 부분: 기본적으로는 r 코드 청크 속에 포함, 사이드바와 메인 병렬\n\n사이드바: 레이아웃 구성요소에 넣고 {.sidebar} CSS 클래스 지정 가능\n메인: 사이드바와 다른 레이아웃 구성요소에 넣기 가능\n\n\n\nserver 부분: r 코드 청크 속에 포함, 다음 지정\n\n\n#| context: server 지정\n\n\n\n기타(패키지, 데이터 등) 부분: r 코드 청크 속에 포함, 다음 지정\n\n#| context: setup\n#| include: false\n\n\n\n6.2.2 Quarto 중심 방식\n\n보통 하나의 row에 임베딩\nsrc=\"\" 부분만 교체\n\n&lt;iframe src=\"https://...\" loading=\"lazy\" style=\"width: 100%; height: 600px; border: 0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "exec_11.html#고차-주제",
    "href": "exec_11.html#고차-주제",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "\n7 고차 주제",
    "text": "7 고차 주제\n\n7.1 LLM-기반 ChatBot 웹 앱",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "exec_11.html#bslib-패키지의-활용",
    "href": "exec_11.html#bslib-패키지의-활용",
    "title": "웹 앱 개발: Shiny의 활용",
    "section": "\n5 bslib 패키지의 활용",
    "text": "5 bslib 패키지의 활용",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 활용"
    ]
  },
  {
    "objectID": "exec_11.html#최신-레이아웃-디자인-bslib-패키지",
    "href": "exec_11.html#최신-레이아웃-디자인-bslib-패키지",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "\n4 최신 레이아웃 디자인: bslib 패키지",
    "text": "4 최신 레이아웃 디자인: bslib 패키지\n\n4.1 개요\n위에서 Shiny의 전체 레이아웃은 위계적으로 구성된 레이아웃 함수들에 의해 결정된다고 했다. fluidPage(), titlePanel(), sidebarLayout(), sidebarPanel(), mainPanel() 과 같은 레이아웃를 통해 그림 3 에 나타나 있는 것과 같은 외향의 레이아웃이 완성된 것이다.\n이러한 전통적인 레이아웃 디자인을 보다 현대적인 레이아웃으로 탈바꿈하기 위해 등장한 것이 bslib 패키지이다. bslib 패키지는 Bootstrap을 기반으로 Shiny와 R Markdown을 위한 현대적인 UI 도구 모음을 제공한다. 카드, 밸류 박스, 사이드바 등 재사용 가능한 UI 구성 요소를 통해 Shiny 웹 앱과 문서를 효율적으로 구성할 수 있으며, 테마 시스템을 활용해 웹 앱과 문서의 외관을 유연하게 사용자 정의하고 실시간으로 조정할 수 있다. 또한 최신 Bootstrap 및 Bootswatch를 지원하여, 기본적으로 Bootstrap 3에 의존하는 기존 Shiny 및 R Markdown 환경보다 현대적인 웹 UI 구현을 가능하게 한다.\nbslib 패키지는 shiny 패키지의 기본 레이아웃 함수와는 다른 종류의 함수를 제공한다. 그러므로 조금 더 현대적인 감각의 웹 앱을 생성하기 위해서는 bslib 패키지에서 제공되는 레이아웃 함수에 익숙해져야 한다. 여기서는 bslib 패키지를 통해 그림 3 웹 앱이 어떻게 달라지는지를 살펴본다.\nShiny 패키지는 기본적으로 11개의 예제 웹 앱을 제공한다. 다음과 같이 실행해 본다.\n\nlibrary(shiny)\nrunExample()\n\n이 들 중 첫 번째 예제인 “01_hello”가 그림 3 에 나타나 있는 웹 앱이다. 해당 예제를 실행하려면 다음과 같이 하면 된다.\n\nrunExample(\"01_hello\")\n\n아래의 그림 5 와 같은 웹 앱이 생성된다. 이것을 그림 3 과 비교해 보라. 조금 다르다는 것을 쉽게 알아 챌 수 있는데(왼편 슬라이더바에서 &lt; 를 눌러보라.), 이것이 bslib 패키지를 활용하여 제작된 웹 앱이다.\n\n\n\n\n\n그림 5: bslib 패키지를 활용한 웹 앱의 예제\n\n\n웹 앱 뿐만 아니라 코드도 살펴보려면 다음과 같이 실행하면 된다.\n\nrunExample(\"01_hello\", display = \"showcase\")\n\n삽입되어 있는 설명 부분을 제거하고 코드만 남기면 다음과 같다. 이것을 그림 3 의 코드와 비교해 보라. 오로지 UI 부분의 코드만 다르고, 그것도 레이아웃 함수명만 달라져 있다는 것을 알 수 있다(입출력 함수는 그대로이다). 결국 bslib 패키지는 UI 부분의 레이아웃만 바꾼다.\n\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_sidebar(\n  title = \"Hello Shiny!\",\n  sidebar = sidebar(\n    sliderInput(\n      inputId = \"bins\",\n      label = \"Number of bins:\",\n      min = 1,\n      max = 50,\n      value = 30\n    )\n  ),\n  plotOutput(outputId = \"distPlot\")\n)\n\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    x &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n    hist(\n      x,\n      breaks = bins,\n      col = \"#75AADB\",\n      border = \"white\",\n      xlab = \"Waiting time to next eruption (in mins)\",\n      main = \"Histogram of waiting times\"\n    )\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n첫째, page_sidebar()가 최상위 레이아웃 함수이다. page_sidebar()는 bslib에서 가장 널리 사용되는 페이지 레이아웃 함수로, 전체 너비를 차지하는 헤더(제목)와 사용자 입력을 위한 사이드바를 갖춘 대시보드형 레이아웃을 손쉽게 구성할 수 있도록 설계되었다. page_sidebar()함수는 전통적인 shiny 레이아웃 함수 중 fluidPage(), titlePanel(), sidebarLayout() 함수의 역할을 동시에 수행한다고 생각할 수 있다.\n둘째, page_sidebar() 의 여러 인수가 전통적인 titlePanel() 함수와 sidebarLayout()의 하위 함수인 sidebarPanel() 함수를 대신한다.\n\ntitle: 대시보드의 제목을 설정할 수 있으며, titlePanel() 함수와 동일한 기능을 한다.\nsidebar = sidebar(): sidebarPanel() 함수와 동일한 기능을 한다. sidebarPanel() 함수 속에 입력 함수인 siderInput() 함수가 들어 있었던과 동일하게 sidebar() 속에 siderInput() 함수가 들어 있다.\n\n셋째, 전통적인 Shiny의 mainPanel() 함수 없이 출력 표출 함수(plotOutput())가 막바로 사용된다. 그러나 이것은 가장 단순한 방식으로, card() 함수를 사용하면 보다 풍성한 옵션을 사용할 수 있다. card() 함수 내부에서 card_header()와 card_body()라는 컴포넌트 함수를 활용한다. 아래는 위의 코드에 대해 두 가자 부가적인 조치를 한 것이다. 첫째, card() 함수를 통해 출력 표출 부분을 보완한다. 둘째, 기본 플롯 함수 대신 ggplot2 패키지를 통해 히스토그램을 작성하고 그것을 plotly 패키지의 ggplotly() 함수를 통해 인터랙티브 플롯을 생성한다. plotly 패키지의 출력 생성 및 출력 표출을 위해 renderPlotly({})와 plotlyOutput() 함수가 활용되는 점에 주목한다.\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(plotly)\n\nui &lt;- page_sidebar(\n  title = \"Hello Shiny!\",\n  sidebar = sidebar(\n    sliderInput(\n      inputId = \"bins\",\n      label = \"Number of bins:\",\n      min = 1,\n      max = 50,\n      value = 30\n    )\n  ),\n  card(\n    card_header(\"ggplot2: Histogram\"),\n    card_body(\n      plotlyOutput(outputId = \"distPlot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlotly({\n    x    &lt;- faithful[, 2]\n    gg &lt;- ggplot() +\n      geom_histogram(\n        aes(x = x), bins = input$bins, fill = 'darkgray', color = 'white'\n      ) +\n      labs(\n        x = 'Waiting time to next eruption (in mins)',\n        y = \"Frequencies\",\n        title = 'Histogram of waiting times'\n      )\n    ggplotly(gg)\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\n4.2 컨테이너 함수\n컨테이너 함수란 다른 UI 요소를 담되, 그 자체가 시각적 콘텐츠의 주제가 되지 않고 공간, 전환, 계층 구조를 정의하는 함수이다. 컨테이너 함수는 크게 세 가지로 나뉜다.\n\n페이지 컨테이너: 페이지 전체의 폭, 높ㅇ디, 스크롤 방식 등 최상위 UI 구조를 정의하는 컨테이너로, page_*() 형태를 띤다.\n레이아웃 컨테이너: 페이지 내부에서 여러 UI 요소를 동시에 어떻게 배치할지를 결정하는 컨테이너로, layout_*() 형태를 띤다.\n내비게이션 컨테이너: 여러 UI 패널을 묶어 사용자 상호작용에 따라 표시되는 콘텐츠를 전환하는 컨테이너로, navset_*()의 형태를 띤다.\n\n분류별 컨테이너 함수를 정리하면 표 3 과 같다. 자세한 사항은 bslib 패키지 홈페이지의 Get Started나 Layouts를 참고할 수 있다.\n\n\n표 3: bslib 컨테이너 함수\n\n\n\n\n\n\n\n\n분류\n함수\n특징\n\n\n\n페이지 컨테이너(기본)\n\npage_fixed()\npage_fluid()\npage_fillable()\n\n\n고정형(고정폭: 940픽셀)\n유동형(웹페이지의 전체 폭)\n대시보드형(웹페이지의 전체 폭/높이)\n\n\n\n페이지 컨테이너(확장)\n\npage_sidebar()\npage_navbar()\n\n\n표준형(전역적 사이드바 포함)\n다중 페이지, nav_panel()의 집합\n\n\n\n레이아웃 컨테이너\n\nlayout_siderbar()\nlayout_columns()\nlayout_column_wrap()\n\n\npage_*(), card(), nav_panel() 내부\npage_sidebar() 내부\nnav_panel() 내부\n\n\n\n\n내비게이션 컨테이너\n(페이지/레이아웃 레벨)\n\n\nnavset_tab()\nnavset_pill()\nnavset_underline()\n\n\nnav_panel()의 집합\n\n\n\n내비게이션 컨테이너\n(카드 레벨)\n\n\nnavset_card_tab()\nnavset_card_pill()\nnavset_card_underline()\n\n\nnav_panel()의 집합\n\n\n\n\n\n\n우선 단일 페이지의 구조를 결정하는 페이지 컨테이너를 살펴보면 다음과 같다. page_fixed(), page_fluid(), page_fillable() 는 가장 중요한 세 가지 함수이다. page_fixed()는 중앙 정렬된 고정 폭 페이지 컨테이너이고, page_fluid()는 브라우저 폭에 따라 콘텐츠 영역이 유동적으로 변화는 페이지 컨테이너이고, page_fillable()는 브라우저의 가시 영역을 높이까지 포함해 채우도록 설계된 페이지 컨테이너이다. 그림 6 는 이 세가지 페이지 컨테이너를 비교하고 있다.\n\n\n\n\n\n그림 6: 페이지 컨테이너의 종류(https://shiny.posit.co/r/articles/build/layout-guide/)\n\n\n그러나 가장 중요한 페이지 컨테이너는 page_sidebar()로 bslib 패키지의 표준이다. 이것은 페이지 전체를 채우는 구조 위에 사이드바-메인 영역 분할을 기본으로 제공하는 고수준 페이지 컨테이너이다. 단순히 예기하면 page_sidebar()는 page_fillable()과 레이아웃 컨테이너인 layout_siderbar()를 결합한 것으로 이해할 수 있다. page_navbar()는 상단 내비게이션 바를 페이지의 기본 구조로 표함하여, 여러 화면을 전환하는 앱을 구성하는 고수준 페이지 컨테이너이다. page_navbar()는 개념적으로 페이지 컨테이너와 내비게이션 컨테이너(navbar)을 통합한다.\n레이아웃 컨테이너는 페이지 전체가 아니라 페이지 내부 배치를 담당하는데, 페이지 컨테이너와 달리 중첩 사용이 가능하지만 콘텐츠 자체를 표현하지는 않는다. layout_siderbar()는 사이드바와 메인 콘텐츠 영역으로 화면을 이분하는 레이아웃 컨테이너를 생성하는데 주로 page_*(), card(), nav_panel() 내부 어디에도 존재할 수 있다. layout_columns()는 여러 UI 요소를 동일 행 내의 다중 컬럼으로 배치하는 레이아웃 컨테이너를 생성한다. 컬럼의 수와 폭을 명시적으로 제어할 수 있으며 정돈된 레이아웃 구형에 용이하다. layout_column_wrap()은 컬럼을 행 단위로 자동 줄바꿈하여 반응형 배치를 제공하는 레이아웃 컨테이너이다. 컬럼 폭 기준으로 자동 배치하며 화면 크기에 따라 행 수가 동적으로 변한다.\n내비게이션 컨테이너는 여러 UI 패널을 묶어 사용자 상호작요에 따라 표시되는 콘텐츠를 전환하는 컨테이너로, 페이지 컨테이너나 레이아웃 컨테이너의 내부에서 사용된다. 한 번에 하나의 패널만 활성화되며, 공간 배치가 아니라 상태 전환을 담당한다. navset_tab(), navset_pill(), navset_underline()는 모두 nav_panel()들의 집합으로 구성되며, 콘텐츠 전환의 방식이 다를 뿐이다. navset_tab()는 전통적인 탭 모양을, navset_pill()는 둥근 필(pill) 모양의 버튼을, navset_underline()는 밑줄을 그은 형태를 제공한다. navset_card_tab(), navset_card_pill(), navset_card_underline()은 동일한 기능을 하지만 card 스타일을 기본으로 내장한 컨테이너이다. navset_*() 함수가 페이지 또는 레이아웃의 주요 내비게이션과 같은 비교적 상위 UI 계층에서 사용되는데 반해 navset_card_*() 함수는 주로 콘텐츠 블록 내부에 위치하여 카드 수준의 국소적 전환에 사용된다.\n\n4.3 콘텐츠 컴포넌트: UI 구성 요소\n가장 중요한 컴포넌트에 카드(card), 사이드바(sidebar), 밸류 박스(value box), 툴팁(tooltip)과 팝오버(popover)가 있다. 자세한 사항은 bslib 패키지 홈페이지의 Components를 참고할 수 있다.\n\n4.3.1 카드\n카드(card)는 현대적인 UI에서 가장 널리 사용되는 정보 구성 단위 중 하나이다. 기본적으로 카드는 테두리와 여백을 갖는 직사각형 컨테이너에 불과하지만, 관련된 정보를 의미 있게 묶어 제시할 경우 사용자가 내용을 보다 쉽게 이해하고, 집중하며, 탐색할 수 있도록 돕는다. 이러한 특성 때문에 카드는 대시보드와 UI 설계에서 핵심적인 역할을 하며, 대부분의 성공적인 대시보드 및 UI 프레임워크는 카드를 주요 컴포넌트로 채택하고 있다. card() 함수는 다음과 같은 컴포넌트 함수를 갖는다.\n\ncard_header(): 제목\ncard_body(): 주 콘텐츠(생략 가능: 바로 출력 표출 함수 표시 가능)\ncard_footer(): 부가 설명\n\n4.3.2 사이드바\n사이드바(sidebar)는 필터, 설정, 기타 입력 요소를 사용자가 쉽게 접근할 수 있도록 제공하는 핵심 UI 컴포넌트로, 이들이 제어하는 대화형 기능과 나란히 배치된다는 점이 특징이다. 사이드바를 활용하면 사용자 입력과 결과 출력 간의 관계를 명확히 할 수 있어, 대시보드의 사용성과 탐색성이 크게 향상된다. bslib에서는 page_sidebar()와 page_navbar() 함수를 통해 페이지 수준(page-level)의 사이드바 레이아웃을 기본적으로 제공하며, 이 외에도 다양한 형태의 사이드바 레이아웃을 지원하여 인터페이스의 목적과 복잡도에 따라 유연한 UI 설계를 가능하게 한다.\n\n\n\n\n\n\n노트사이드바 컴포넌트와 사이드바 레이아웃\n\n\n\n\n\n사이드바 컴포넌트와 사이드바 레이아웃은 다르다. 사이드바 레이아웃은 공간을 나누는 구 조를 의미한다면, 사이드바 컴포넌트는 콘텐츠를 담는 UI 블록이다. 입력 위젯, 텍스트, 메뉴 등이 포함되며 독립적인 UI가 의미가 있다. 사이드바 레이아웃의 중요 함수에는 앞에서 살펴본 것과 같은 page_sidebar(), layout_sidebar() 등이 있고, 사이드바 컴포넌트의 대표적인 함수에 sidebar()가 있다.\nbslib에서 제공하는 사이드바 레이아웃은 크게 부유형(floating), 채움형(filling), 다중 페이지/탭형(multi-page/tab)의 세 가지로 구분할 수 있다.\n부유형 레이아웃은 layout_sidebar()를 사용하는데, 페이지의 어느 위치에나 배치할 수 있는 사이드바 레이아웃을 구성할 수 있다. 이 방식은 의미적으로 관련된 입력 요소와 출력 요소를 시각적으로 함께 묶어 제시하는 데 적합하다. 또한 card()와 함께 사용하면 전체 화면 확장(full-screen), 헤더·푸터 추가 등 카드가 제공하는 다양한 기능을 활용할 수 있다.\n채움형 레이아웃은 page_sidebar()를 사용하는데 페이지 전체를 채우는 사이드바 레이아웃을 생성한다. 내부적으로 page_sidebar()는 page_fillable()과 layout_sidebar()를 단순히 감싼(wrapper) 함수에 불과하다. 이 구조를 이해하면, 하나의 채움형 레이아웃 안에 여러 개의 사이드바 레이아웃을 유연하게 배치할 수 있는 가능성이 열린다.\n다중 페이지/탭 레이아웃은 page_navbar()나 navset_card_tab() 내부에서 sidebar 인수를 사용해 사이드바를 구성할 수 있다. 이 경우 사이드바는 페이지 전체를 채우는 동시에, 모든 페이지나 탭에서 동일하게 유지되어 표시된다. 이후에는 페이지별로 서로 다른 레이아웃을 구성하는 방법도 다루겠지만, 모든 페이지에서 동일한 사이드바를 사용하는 것이 바람직한 경우도 많다. 이러한 경우에는 conditionalPanel()을 활용하여 특정 페이지에서만 사이드바의 일부 내용을 표시하거나 숨길 수 있다.\n\n\n\n\n4.3.3 밸류 박스\n밸류 박스(value box)는 대시보드에서 핵심적인 수치나 지표를 한눈에 전달하기 위해 사용되는 UI 컴포넌트이다. 값(value), 설명(label), 아이콘(icon) 등을 함께 제시하여 사용자가 현재 상태나 주요 변화를 빠르게 파악할 수 있도록 돕는다. bslib의 value_box() 함수는 카드(card) 기반 설계를 따르므로 다른 UI 요소들과 시각적으로 일관되게 어우러지며, Shiny의 반응성과 결합해 값이 동적으로 갱신되는 대시보드를 구성하는 데 특히 유용하다.\nvalue_box() 함수는 네 가지 주요 구성 요소로 이루어진다.\n\nvalue는 표시하고자 하는 핵심 수치나 텍스트 값으로, 대시보드에서 가장 중요한 정보를 전달한다. 출력 표출 함수를 사용할 수도 있다.\ntitle은 value 위에 선택적으로 표시되는 설명 텍스트로, 해당 값의 의미나 지표명을 명확히 한다.\nshowcase는 아이콘이나 기타 UI 요소와 같이 value 옆에 함께 배치되는 시각적 요소로, 정보를 보다 직관적으로 인식하도록 돕는다. bs_icon() 컴포넌트 함수를 주로 사용한다.\ntheme은 값 상자의 색상이나 스타일을 조정하는 선택적 설정으로, 대시보드의 전체 디자인과 시각적 일관성을 유지하거나 강조 효과를 줄 수 있다.\n\n4.3.4 툴팁과 팝오버\n툴팁(tooltip)과 팝오버(popover)는 화면을 방해하지 않으면서 추가 정보를 제공하거나 상호작용을 가능하게 하는 유용한 UI 요소이다. 툴팁은 주로 간단한 설명을 표시하는 데 사용되며, 팝오버는 보다 풍부한 정보 제공이나 사용자 입력을 포함한 상호작용을 지원한다. 예를 들어, card_header()에 “도움말” 아이콘과 함께 tooltip()을 부착하면 사용자가 시각화된 데이터에 대한 추가 설명을 손쉽게 확인할 수 있다. 또한 동일한 헤더 영역에 “설정” 아이콘과 popover()를 연결하면 시각화의 매개변수를 직접 제어할 수 있는 인터페이스를 제공할 수 있다. 더 나아가 card_footer()의 링크에 popover()를 적용하면 추가 정보의 표시뿐 아니라 하이퍼링크와 같은 상호작용 요소를 함께 제공할 수 있어, 정보 탐색과 사용자 경험을 동시에 향상시킨다.\n구현 방식 측면에서 보면, 툴팁과 팝오버는 매우 유사하다. 두 컴포넌트 모두 사용자의 상호작용을 통해 표시 여부가 전환되는 트리거(trigger) UI 요소와, 화면에 표시될 메시지 내용을 필요로 한다. tooltip()과 popover()는 공통적으로 첫 번째 인수를 트리거로 취급하며, 이름이 지정되지 않은 나머지 인수들은 메시지 내용으로 사용된다. 또한 popover()의 경우에는 선택적으로 제목(title)을 함께 지정할 수 있다.\n반면, 사용자 경험(UX)과 활용 목적 측면에서는 두 컴포넌트의 성격이 뚜렷이 다르다. 툴팁은 포커스나 마우스 오버(hover)에 의해 표시되는 반면, 팝오버는 클릭을 통해 열리고 닫힌다. 이로 인해 팝오버는 툴팁보다 화면에 더 오래 유지되는, 즉 상대적으로 지속성이 높은 인터페이스이며, 추가적인 사용자 상호작용이 필요한 경우에 적합하다. 따라서 간단한 설명과 같은 읽기 전용(read-only) 정보에는 툴팁을 사용하는 것이 바람직하고, 메시지 자체와의 상호작용이 필요한 경우에는 팝오버를 사용하는 것이 적절하다.\n\n4.4 사용자 정의 테마\nbslib 패키지의 또 다른 중요한 기능은 다양한 사용자 정의 테마(custom theming)의 적용을 용이하게 한다는 점이다. bslib는 Bootstrap 5를 기반으로 한 테마 시스템을 추상화하여, 사용자가 색상, 타이포그래피, 여백, 컴포넌트 스타일 등 핵심 디자인 요소를 일관된 방식으로 제어할 수 있도록 지원한다. 특히 bs_theme()를 중심으로 한 테마 정의 방식은 개별 UI 요소를 일일이 스타일링하는 접근에서 벗어나, 디자인 전반을 하나의 체계적인 설정으로 관리할 수 있게 해준다. 이를 통해 인터랙티브 대시보드나 웹 애플리케이션의 시각적 일관성을 유지하면서도, 목적과 사용자 맥락에 맞는 다양한 테마를 손쉽게 적용할 수 있다. 이러한 사용자 정의 테마 기능은 bslib를 단순한 UI 구성 도구를 넘어, 재현 가능하고 확장 가능한 시각적 설계 도구로 자리매김하게 하는 핵심 요소라 할 수 있다.\n\n4.4.1 bs_theme() 함수\nbs_theme() 함수는 bslib 패키지에서 사용자 정의 테마를 정의하는 핵심 함수로, Bootstrap 기반 UI의 시각적 전반을 하나의 설정 객체로 통합 관리한다. 즉, bs_theme() 함수는 색상, 글꼴, 여백, 컴포넌트 스타일 등 UI 전반의 디자인 규칙을 한 번에 정의하고 이를 Shiny 앱 전체에 일관되게 적요하도록 해주는 테마 객체 생성 함수이다.\nbs_theme() 함수의 주요 인수는 다음과 같다.\n\nversion = 5: 사용할 Bootstrap 버전으로 5가 기본값\nbg = \"#ffffff\", fg = \"#212529\": 기본 배경색 및 기본 텍스트 색상\nprimary = \"#0d6efd\", secondary = \"\", success = \"\", info = \"\", warning = \"\", danger = \"\": Bootstrap의 의미 기반 색상 체계\nbase_font = font_google(\"Noto Sans KR\"), heading_font = font_google(\"Noto Serif KR\"), code_font = font_google(\"JetBrains Mono\"): 본문 텍스트, 제목, 코드 블록의 타이포그래피 일관성 확보\nbase_font_size = \"1rem\": 기본 글자 크기로 rem 단위 사용이 권장 된다.\nspacer = \"1rem\": 여백의 기준 단위\nborder_radius = \"0.5rem\": 카드, 버튼 등의 모서리 둥글기\nbootswatch = \"flatly\": 미리 정의된 Bootswatch 테마\n\n4.4.2 테마 미리보기 및 검증\nbslib 패키지의 bs_theme_preview() 함수는 사용자 정의 테마를 실제 UI 구성 요소에 적용해 보며 시각적 효과를 즉시 확인할 수 있는 테마 미리보기 및 검증 도구이다.\n콘솔에서 함수를 실행하면, 버튼, 카드, 입력 위젯 등 대표 UI 컴포넌트에 테마를 적용해볼 수 있고, 색상 대비, 타이포그래피, 여백 등을 한눈에 점검할 수 있을 뿐만 아니라, 테마 수정의 결과를 즉시 확인해 볼 수 있다. 그림 7 에서 볼 수 있는 것처럼 오른편의 Theme customizer를 조작하여 이러한 기능을 활용해 볼 수 있다.\n\n\n\n\n\n그림 7: be_theme_update() 함수를 활용한 테마 미리보기 및 검증",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "exec_06.html",
    "href": "exec_06.html",
    "title": "시각화하기",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 과정 중 데이터 시각화하기(visualizing)를 다룬다. 그림 1 에 나타나 있는 것처럼, 시각화하기는 데이터사이언스 프로세스 중 핵심적인 분석 부분의 구성요소이다. 데이터 변형과 데이터 시각화를 합쳐 데이터 탐색이라 부르기도 한다.\n\n\n\n\n\n그림 1: 데이터사이언스 프로세스와 시각화(https://r4ds.hadley.nz/visualize.html)\n\n\n데이터 시각화하기는 tidyverse의 핵심 패키지 중의 하나인 ggplot2 에서 제공된다. ggplot2의 gg가 ’그래프의 문법(grammar of graphic)’을 의미하는 것에서 알 수 있는 것처럼, ggplot2는 그래프 제작의 일반 원리를 정교하게 구현하기 위해 만들어졌다. 그림 2 에서 보는 것처럼, 모든 그래프는 8개의 주요 구성 요소로 이루어져 있고, ggplot2는 각각의 구성 요소를 마치 레이어(layer)를 쌓는 것과 같은 방식으로 구현한다(+ 연산자, 즉 레이어 추가 연산자 사용).\n\n\n\n\n\n그림 2: 그래프의 8대 구성 요소(https://initiation.doana-r.com/06-ggplot2#1)\n\n\n우선 tidyverse 패키지를 불러온다.\n\nlibrary(tidyverse)\n\n실습을 위해 ggplot2 패키지 속에 포함되어 있는 mpg 데이터와 diamonds 데이터를 사용한다. mpg 데이터의 11개 변수 중 다음의 세 가지 변수가 특히 중요한데, displ는 자동차의 엔진 크기이고, hwy는 고속도로 연비, class는 자동차의 유형이다. diamond 데이터는 총 54,000개의 다이아몬드에 대한 정보를 담고 있는데, 특히 가격(price) 캐럿(carat), 컬러(color), 투명도(clarity), 컷(cut)이 중요한 변수들이다.",
    "crumbs": [
      "R과 데이터사이언스",
      "시각화하기"
    ]
  },
  {
    "objectID": "exec_06.html#개요",
    "href": "exec_06.html#개요",
    "title": "시각화하기",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 과정 중 데이터 시각화하기(visualizing)를 다룬다. 그림 1 에 나타나 있는 것처럼, 시각화하기는 데이터사이언스 프로세스 중 핵심적인 분석 부분의 구성요소이다. 데이터 변형과 데이터 시각화를 합쳐 데이터 탐색이라 부르기도 한다.\n\n\n\n\n\n그림 1: 데이터사이언스 프로세스와 시각화(https://r4ds.hadley.nz/visualize.html)\n\n\n데이터 시각화하기는 tidyverse의 핵심 패키지 중의 하나인 ggplot2 에서 제공된다. ggplot2의 gg가 ’그래프의 문법(grammar of graphic)’을 의미하는 것에서 알 수 있는 것처럼, ggplot2는 그래프 제작의 일반 원리를 정교하게 구현하기 위해 만들어졌다. 그림 2 에서 보는 것처럼, 모든 그래프는 8개의 주요 구성 요소로 이루어져 있고, ggplot2는 각각의 구성 요소를 마치 레이어(layer)를 쌓는 것과 같은 방식으로 구현한다(+ 연산자, 즉 레이어 추가 연산자 사용).\n\n\n\n\n\n그림 2: 그래프의 8대 구성 요소(https://initiation.doana-r.com/06-ggplot2#1)\n\n\n우선 tidyverse 패키지를 불러온다.\n\nlibrary(tidyverse)\n\n실습을 위해 ggplot2 패키지 속에 포함되어 있는 mpg 데이터와 diamonds 데이터를 사용한다. mpg 데이터의 11개 변수 중 다음의 세 가지 변수가 특히 중요한데, displ는 자동차의 엔진 크기이고, hwy는 고속도로 연비, class는 자동차의 유형이다. diamond 데이터는 총 54,000개의 다이아몬드에 대한 정보를 담고 있는데, 특히 가격(price) 캐럿(carat), 컬러(color), 투명도(clarity), 컷(cut)이 중요한 변수들이다.",
    "crumbs": [
      "R과 데이터사이언스",
      "시각화하기"
    ]
  },
  {
    "objectID": "exec_06.html#핵심-구성-요소-시각속성과-기하객체",
    "href": "exec_06.html#핵심-구성-요소-시각속성과-기하객체",
    "title": "시각화하기",
    "section": "\n1 핵심 구성 요소: 시각속성과 기하객체",
    "text": "1 핵심 구성 요소: 시각속성과 기하객체\n이 8개 구성 요소 중 가장 중요한 것은 ’시각속성(aesthetics)’과 ’기하객체(geometric objects)’이다. 기하객체가 그래프의 전체 구조 혹은 형식을 규정하는 것이라면, 시각속성은 기하객체의 외견을 규정한다. 결국 기하객체는 그래프의 유형(예: 막대 그래프, 산포도 등)과 관련되고, 시각속성은 플롯의 그래픽 속성(예: 컬러, 크기, 모양 등) 혹은 시각 변수(visual variable)과 관련된다. 이 두 가지는 독립적인 요소이지만, 어느 정도는 관련되어 있기도 하다. 특정한 기하객체는 오로지 특정한 시각속성과만 결합한다. 예를 들어 포인트 기하 객체(geom_point())는 크기(size) 시각속성과 관련되지만, 라인 기하객체(geom_line())는 크기 시각속성과는 관련되지 않고 라인폭(linewidth) 시각속성과만 관련되는 식이다.\n\n1.1 시각속성\n시각속성 매핑(aesthetic mapping)이란 특정한 시각속성 혹은 시각변수를 특정한 변수에 부여하는 과정을 의미한다. 이것을 통해 해당 변수의 변동(값의 다양성)을 효과적으로 나타낼 수 있다. 변수는 다양한 값으로 구성되어 있고, 그 값들이 보여주는 다양성을 시각적으로 드러내야 한다. 정성적 변수인 경우는 범주적 차이를 표현해야 하고, 정량적 변수인 경우는 수치적 차이를 표현해야 한다. 여기서 중요한 것은 어떤 시각속성은 정성적 변수와 관련되고, 다른 시각속성은 정량적 변수와 관련된다는 점이다. 시각속성은 aes() 함수를 통해 나타내며, ‘시각속성 = 변수’의 형태로 지정된다. 당연히 여러 개의 시각속성이 동시에 사용될 수 있고, aes() 함수 내에서 콤마로 구분된다. aes()는 두 곳에 지정할 수 있는데, 최상위 함수인 ggplot() 속에 지정하면 ’글로벌’ 지정이, 특정한 geom_*() 속에 지정하면 ‘로컬’ 지정이 된다. 둘의 차이는 뒤에서 살펴본다. ggplot2 패키지가 제공하는 시각속성이 표 1 에 정리되어 있다.\n\n\n표 1: 시각속성 유형\n\n\n\n\n\n\n\n\n\n분류\n시각속성\n설명\n성격\n\n\n\n컬러 관련\naes(color = )\n점/선의 컬러 지정\n정성 &gt; 정량\n\n\n\naes(fill = )\n역/면의 필(컬러) 지정\n정성 &gt; 정량\n\n\n\naes(alpha = )\n점/선/역/면의 투명도 지정\n정성 &lt; 정량\n\n\n차이 표현 관련\naes(size = )\n점의 크기 지정\n정량\n\n\n\naes(shape = )\n점의 모양 지정\n정성\n\n\n\naes(linetype = )\n선의 유형 지정\n정성\n\n\n\naes(linewidth = )\n선의 크기 지정\n정량\n\n\n위치 관련\naes(x = )\nx축 지정\n정성/정량\n\n\n\naes(y = )\ny축 지정\n정성/정량\n\n\n그룹화 관련\naes(group = )\n데이터를 묶는 기준(그룹화 기준) 지정\n정성\n\n\n\n\n\n\n\n\n\n\n\n\n노트\n\n\n\n위치 관련 시각속성에 xmin, ymin, xmax, ymax, xend, yend 등도 있다. 그러나 이것은 변수와 관련되지 않고 도형의 위치나 크기를 정의하는 좌표 매핑용으로만 사용된다. aes() 속에서 정의되기 때문에 시각속성이라 할 수는 있으나, 엄밀한 의미에서는 일종의 매개변수에 해당한다.\n\n\n동일한 기하객체의 시각화에서 시각속성의 선택이 어떤 영향을 미치는지를 살펴본다. 산점도 기하객체(geom_point())를 통해 displ과 hwy의 관계가 class에 따라 어떻게 달라지는지를 시각화한다. 다음의 두 그래프를 비교해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 3: 시각속성: 컬러\n\n\n\n\n\nggplot(mpg, aes(x = displ, y = hwy, shape = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 4: 시각속성: 형태\n\n\n\n\n그림 3 과 그림 4 중 어느 것이 더 효과적이라고 판단하는가? 컬러(color)와 형태(shape)라는 시각속성 외에 크기(size)와 투명도(alpha) 속성을 동일한 데이터에 적용해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, size = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 5: 심미성: 크기\n\n\n\n\n\nggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +\n  geom_point()\n\n\n\n\n\n\n그림 6: 심미성: 투명도\n\n\n\n\n크기와 투명도는 정량적 차이를 나타내는데 적합한 시각속성이기 때문에 class라는 정성적 범주의 차이를 보여주는데는 적합하지 않다. 시각속성 부여에서 가장 중요한 것은 결국 해당 시각속성이 주어진 데이터에 얼마나 부합하느냐에 달려있다.\n\n1.2 기하객체\n기하객체는 그래프의 전체 구조 혹은 형식을 규정하며, 일반적으로 그래프의 유형으로 이해할 수 있다. ggplot2 패키지는 매우 다양한 형태의 기하객체를 제공하며, geom_*() 함수의 형태를 띤다. geom_*() 함수 속에 aes()를 지정할 수 있다(로컬 지정). ggplot2 패키지가 제공하는 기하객체가 표 2 에 정리되어 있다. 가장 빈번하게 사용되는 기하객체에 geom_point(), geom_line(), geom_bar(), geom_boxplot(), geom_histogram(), geom_smooth(), geom_text(), geom_abline() 등이 있다.\n\n\n표 2: 기하객체 유형\n\n\n\n\n\n\n\n\n\n구분\n내용\n기하객체\n이름\n\n\n\n기본 플롯\n점\n\ngeom_point()\ngeom_jitter()\ngeom_count()\n\n\n점플롯(산점도)\n지터플롯\n카운트플롯\n\n\n\n\n선\n\ngeom_line()\ngeom_path()\ngeom_step()\n\n\n선플롯(선그래프)\n경로플롯\n계단플롯\n\n\n\n\n역\n\ngeom_area()\ngeom_ribbon()\n\n\n면적플롯\n리본플롯\n\n\n\n\n막대\n\ngeom_bar()\ngeom_col()\n\n막대플롯\n\n\n통계 플롯\n분포\n\ngeom_boxplot()\ngeom_density()\ngeom_dotplot()\ngeom_histogram()\ngeom_freqpoly()\ngeom_violin()\ngeom_rug()\ngeom_qq_line()\ngeom_qq()\n\n\n박스플롯\n밀도플롯\n도트플롯\n히스토그램\n빈도다각선플롯\n바이올린플롯\n러그플롯\nQ-Q선플롯\nQ-Q선플롯\n\n\n\n\n불확실성\n\ngeom_crossbar()\ngeom_errorbar()\ngeom_errorbarh()\ngeom_linerange()\ngeom_pointrange()\n\n\n십자막대플롯\n세로오차막대플롯\n가로오차막대플롯\n선구간플롯\n점선구간플롯\n\n\n\n\n추세선\n\ngeom_quantile()\ngeom_smooth()\n\n\n분위수회귀플롯\n평활곡선플롯\n\n\n\n도형 표현\n폴리곤\ngeom_polygon()\n다각형플롯\n\n\n\n선\n\ngeom_segment()\ngeom_curve()\ngeom_spoke()\n\n\n선분플롯\n곡선플롯\n스포크플롯\n\n\n\n2D 플롯\n빈도\ngeom_bin_2d()\n2차원빈플롯\n\n\n\n밀도\n\ngeom_density_2d()\ngeom_density_2d_filled()\n\n\n2차원밀도등고선플롯\n채워진2차원밀도등고선플롯\n\n\n\n\n등고선\n\ngeom_contour()\ngeom_contour_filled()\n\n\n등고선플롯\n채워진등고선플롯\n\n\n\n\n직사각형\n\ngeom_raster()\ngeom_rect()\ngeom_tile()\n\n\n래스터플롯\n직사각형플롯\n타일플롯\n\n\n\n\n육각형\ngeom_hex()\n헥스빈플롯\n\n\n기타\n라벨링\n\ngeom_label()\ngeom_text()\n\n\n라벨플롯\n텍스트플롯\n\n\n\n\n참조선\n\ngeom_abline()\ngeom_hline()\ngeom_vline()\n\n\n직선플롯\n수평선플롯\n수직선플롯\n\n\n\n\n지도 제작\n\ngeom_map()\ngeom_sf()\ngeom_sf_label()\ngeom_sf_text()\n\n\n지도플롯\nsf플롯\nsf라벨플롯\nsf텍스트플롯\n\n\n\n\n\n\n\n그림 7 와 그림 8 이 다르게 보이는 것은 기하객체가 하나는 포인트(point)이고 다른 하나는 완만한 선(smooth)이기 때문이다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point()\n\n\n\n\n\n\n그림 7: 기하객체: geom_point()\n\n\n\n\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_smooth()\n\n\n\n\n\n\n그림 8: 기하객체: geom_smooth()\n\n\n\n\n그림 3 과 그림 8 두 개를 결합해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = class)) + \n  geom_point() + \n  geom_smooth()\n\n\n\n\n\n\n그림 9: 기하객체: geom_point() + geom_smooth() 1\n\n\n\n\n원하는 것이 아니다. 왜 이런 결과가 나왔으며, 어떻게 하면 원하는 것을 얻을 수 있을지 생각해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(aes(color = class)) + \n  geom_smooth()\n\n\n\n\n\n\n그림 10: 기하객체: geom_point() + geom_smooth() 2\n\n\n\n\n두 결과의 차이는 color 시각속성을 글로벌하게 적용하느냐 로컬하게 적용하느냐(포인트 기하객체에만 적용)에 달린 것이다. 글로벌 시각속성은 ggplot()속에서 지정하고, 로컬 시각속성은 개별 기하객체(geom_point()) 속에서 지정한다.\n다양한 기하객체는 동일한 데이터를 다양한 방식으로 탐색할 수 있게 해준다. 다음의 세가지 기하객체는 탐색적 데이터 분석에서 널리 사용되는 것이다.\n\nggplot(mpg, aes(x = hwy)) +\n  geom_histogram(binwidth = 2)\n\n\n\n\n\n\n그림 11: 기하객체: geom_histogram()\n\n\n\n\n\nggplot(mpg, aes(x = hwy)) +\n  geom_density()\n\n\n\n\n\n\n그림 12: 기하객체: geom_density()\n\n\n\n\n\nggplot(mpg, aes(x = hwy)) +\n  geom_boxplot()\n\n\n\n\n\n\n그림 13: 기하객체: geom_boxplot()",
    "crumbs": [
      "R과 데이터사이언스",
      "시각화하기"
    ]
  },
  {
    "objectID": "exec_06.html#여타-구성-요소",
    "href": "exec_06.html#여타-구성-요소",
    "title": "시각화하기",
    "section": "\n2 여타 구성 요소",
    "text": "2 여타 구성 요소\n\n2.1 데이터\n데이터는 시각화의 가장 기본적인 요소로, 주로 최상위 함수인 ggplot() 속에서 data 인수로 지정된다. 그러나 개별 기하객체 속에서도 data 인수로 지정될 수 있다. 보통의 경우라면, ggplot() 함수나 특정한 geom_*() 함수 속에서 단일한 데이터 프레임이 한 번 지정되지만, 두 함수에 서로 다른 데이터 프레임이 지정될 수 있고, 또 다른 기하객체 속에 또 다른 데이터 프레임이 지정될 수도 있다.\n\n2.2 스케일\n스케일(scales)은 시각속성 매핑이 구체적으로 어떻게 구현될지를 결정한다. 예를 들어 컬러 시각속성이 적용되었다 하더라도 어떤 컬러가 선정되어 어떻게 배열되는지에 따라 최종 그래프의 모습은 매우 달라질 수 있다. 그러므로 스케일은 시각속성과 불가분의 관계에 있다. ggplot2 패키지가 제공하는 스케일이 표 3 에 정리되어 있다. 많이 사용되는 스케일에 scale_color_brewer(), scale_color_viridis_c(), scale_x_continous(), scale_x_discrete(), scale_y_continous(), scale_y_discrete() 등이 있다.\n\n\n표 3: 스케일 유형\n\n\n\n\n\n\n\n\n분류\n시각속성\n스케일\n\n\n\n컬러 관련\n\ncolor / fill\n\n\nscale_color_identity() / scale_fill_identity()\nscale_color_gradient() / scale_fill_gradient()\nscale_color_gradient2() / scale_fill_gradient2()\nscale_color_gradientn() / scale_fill_gradientn()\nscale_color_brewer() / scale_fill_brewer()\nscale_color_distiller() / scale_fill_distiller()\nscale_color_fermenter() / scale_fill_fermenter()\nscale_color_viridis_d() / scale_fill_viridis_d()\nscale_color_viridis_c() / scale_fill_viridis_c()\nscale_color_viridis_b() / scale_fill_viridis_b()\nscale_color_grey() / scale_fill_grey()\nscale_color_hue() / scale_fill_hue()\nscale_color_steps() / scale_fill_steps()\nscale_color_steps2() / scale_fill_steps2()\nscale_color_stepsn() / scale_fill_stepsn()\nscale_color_manual() / scale_fill_manual()\n\n\n\n\nalpha\n\nscale_alpha()\nscale_alpha_continuous()\nscale_alpha_discrete()\nscale_alpha_binned()\nscale_alpha_ordinal()\nscale_alpha_manual()\n\n\n\n차이 표현 관련\nsize\n\nscale_size()\nscale_size_area()\nscale_size_binned()\nscale_size_binned_area()\nscale_radius()\nscale_size_manual()\n\n\n\n\nshape\n\nscale_shape()\nscale_shape_binned()\nscale_shape_manual()\n\n\n\n\n\nlinetype / linewidth\n\n\nscale_linetype() / scale_linewidth()\nscale_linetype_identity() / scale_linewidth_identity()\nscale_linetype_continuous() / scale_linewidth_continuous()\nscale_linetype_discrete() / scale_linewidth_discrete()\nscale_linetype_binned() / scale_linewidth_binned()\n\n\n\n위치 관련\n\nx / y\n\n\nscale_x_continuous() / scale_y_continuous()\nscale_x_discrete() / scale_y_discrete()\nscale_x_binned() / scale_y_binned()\nscale_x_log10() / scale_y_log10()\nscale_x_reverse() / scale_y_reverse()\nscale_x_sqrt() / scale_y_sqrt()\nscale_x_date() / scale_y_date()\nscale_x_datetime() / scale_y_datetime()\n\n\n\n\n\n\n\n그래프를 다시 살펴본다. 스케일이 어느 부분에 어떻게 적용되었는지 생각해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() \n\n\n\n\n\n\n그림 14: 스케일 설정: 기본값\n\n\n\n\n그림 14 은 아래에서 보는 것처럼, ggplot2가 자동적으로 적용한 세 가지의 스케일 설정에 의거해 만들어진 것이다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_color_discrete()\n\n수정하여 다음과 같이 적용할 수 있다. scale 함수의 각 인수가 어떤 역할을 하는지 생각해 본다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(breaks = seq(15, 40, by = 5)) +\n  scale_color_brewer(palette = \"Set1\", labels = c(\"4\" = \"4-wheel\", \"f\" = \"front\", \"r\" = \"rear\"))\n\n\n\n\n\n\n그림 15: 스케일 설정: 수정\n\n\n\n\nscale_color_brewer() 함수는 ColorBrewer 컬러 스케일을 사용한 것인데 익히고 있으면 많은 도움이 된다. 여기에는 다양한 색배열(color schemes)이 제시되어 있는데, 이것을 ggplot2 패키지에서는 팔레트(palette)라고 부른다. 그림 16 에는 다양한 브루어 컬러 팔레트가 제시되어 있는 데 왼편의 문자가 팔레트의 이름이고(예: YlOrRd), scale_color_brewer() 함수 속에 막바로 사용가능하다. 첫번째 군은 정량적 팔레트 중 순차형(sequential) 팔레트들이고, 두번째 군은 정성적 혹은 범주형(categorical) 팔레트들이고, 세번째 군은 정량적 팔레트 중 분기형(diverging) 팔레트들이다. 변수의 성격에 가장 적절한 팔레트를 선택하는 것이 관건이다.\n\n\n\n\n\n그림 16: ColorBrewer(&lt;http://colorbrewer2.org/&gt;)\n\n\n자신만의 팔레트를 적용할 수도 있다. scale_color_brewer() 대신 scale_color_manual() 함수를 사용하면 된다. 또한 RGB 색상에 대한 HTML 헥스 코드( html hex code)를 사용해도 되고, R에서 부여한 657개의 이름 중에서 골라 사용해도 된다. 색상 이름 및 헥스 코드는 다음 사이트를 참고하라.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(breaks = seq(15, 40, by = 5)) +\n  scale_color_manual(values = c(\"sienna1\", \"slateblue4\", \"#698B22\"))\n\n\n\n\n\n\n그림 17: 스케일 설정: 색상 수정\n\n\n\n\n\n2.3 패싯\n패싯(facets) 레이어는 다면생성(faceting) 과정을 통해 하나의 플롯을 여러개의 하위 플롯으로 쪼갬으로서 생성된다. facet_wrap() 함수가 핵심이다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_wrap(~cyl)\n\n\n\n\n\n\n그림 18: 패싯: facet_wrap()\n\n\n\n\n두 개의 변수에 의거해 패싯을 생성할 수도 있다. facet_wrap() 함수 대신 facet_grid() 함수가 적용된다.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  facet_grid(drv ~ cyl)\n\n\n\n\n\n\n그림 19: 패싯: facet_grid()\n\n\n\n\n\n2.4 통계적 변환\n어떤 시각화 과정은 필연적으로 통계적 변환(statistical transformation)을 수반한다.\n\nggplot(diamonds, aes(x = cut)) + \n  geom_bar()\n\n\n\n\n\n\n그림 20: 통계적 변환: geom_bar()\n\n\n\n\n그림 20 는 그림 21 에서 보는 바와 같이, 원데이터로부터 빈도를 계산(통계적 전환)하고 그것을 그래프로 변환한다.\n\n\n\n\n\n그림 21: 통계적 변환: geom_bar()의 경우(https://r4ds.hadley.nz/layers)\n\n\n모든 geom_*()은 통계적 변환에 대한 인수인 stat에 대해 기본값을 가지고 있다. geom_bar()의 통계적 변환의 기본값은 stat = count 이다. 단일 변수에 대해 빈도 분포에 대한 막대 그래프를 작성할 때는 이 기본값이 잘 작동한다. 그런데, geom_bar()에 단일 변수가 아니라 두 개의 변수가 시각속성에 적용되는 경우(한 변수는 x축에 위치하는 범주 변수, 또 다른 변수는 해당 범주별 빈도값), 적절한 통계적 변환의 유형은 count가 아니라 identity이다. 따라서 이 경우에는 따라 stat = \"identity\"를 반드시 따로 지정해 주어야 한다. 그렇지 않으면 원하는 결과를 얻을 수 없다.\n\ndiamonds |&gt;\n  count(cut) |&gt; \n  ggplot(aes(x = cut, y = n)) +\n  geom_bar(stat = \"identity\")\n\n\n\n\n\n\n그림 22: 통계적 변환: geom_bar()에 stat = identity 지정\n\n\n\n\n그런데 geom_bar()와 유사한 geom_col()이라는 함수를 사용해도 동일한 결과를 얻을 수 있다. geom_col()에서는 통계적 변환의 기본값이 count가 아니라 identity이기 때문에 위와 달리 stat = \"identity\"를 따로 지정할 필요가 없다. 결국 단일 변수에 대한 빈도 분포를 나타내고 싶으면 geom_bar()를, 두 변수를 이용해 빈도 분포를 나타내고 싶으면 geom_col()을 사용하면 된다.\n\ndiamonds |&gt;\n  count(cut) |&gt; \n  ggplot(aes(x = cut, y = n)) +\n  geom_col()\n\n\n\n\n\n\n그림 23: 통계적 변환: geom_col()\n\n\n\n\nafter_stat()이라고 하는 보조 함수를 사용하면, 이 그래프를 절대 빈도가 아닌 상대 빈도 그래프로 변환할 수 있다. 이 역시 통계적 변환 과정이 이면에 숨어 있다. group 인수가 매우 중요하다. 이것을 지정하지 않으면 개별 cut별로 계산하기 때문에 모든 막대가 1이 된다. group = 1로 지정했다는 것은 cut에 관계 없이 모두를 한 덩어리로 생각하고 비중을 구한다는 것을 의미한다. 사실 1이 아니라 어떤 다른 숫자여도 상관이 없다.\n\nggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + \n  geom_bar()\n\n\n\n\n\n\n그림 24: 통계적 변환: geom_bar()에 after_stat() 지정\n\n\n\n\n막대 그래프에 시각속성을 가미하고, position 인수를 통한 위치 조정(position adjustment)을 시도한다.\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar()\n\n\n\n\n\n\n그림 25: position: stack\n\n\n\n\n기하객체에 색상을 지정하고 싶을 때, 0차원(point)과 1차원(line) 객체에는 color라는 시각속성을 적용하지만, 막대 그래프와 같은 2차원(area) 객체에는 fill이라는 시각속성을 적용한다. 자주 혼돈이 되는 부분이다.\n위치 조정을 위해 position 인수를 사용하는데, 네 가지 옵션이 있다.\n\nposition = \"stack\" : 누적 배치. 같은 x축 범주에 속한 여러 집단의 값을 위로 쌓아 올려 표현한다. 전체 합계와 그룹별 비중을 한눈에 보기 쉽다.\nposition = \"identity\": 원자료 그대로 배치. 겹치면 그대로 덮어써서 보이게 된다. 투명도를 조정하지 않으면 겹침 현상 때문에 해석이 어렵다.\nposition = \"dodge\": 옆으로 나란히 배치. 같은 x축 범주에 속한 여러 집단을 옆으로 나란히 분리하여 표현하는데, 그룹 간 비교에 적합하다.\nposition = \"fill\": 누적 비율 배치. \"stack\"과 마찬가지로 쌓되, 전체 높이를 항상 1(100%)에 맞춰 상대적 비율만 보여준다. 전체 규모가 아니라 구성비(비율) 비교에 적합하다.\n\n그림 25 에는 기본값으로 position = \"stack\"이 적용된 것이다. 그림 26 는 position = \"dodge\"를 적용한 것이다 .\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"identity\", alpha = 0.5)\n\n\n\n\n\n\n그림 26: position: identity\n\n\n\n\n그림 27 는 position = \"dodge\"를 적용한 것이다 .\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n그림 27: position: dodge\n\n\n\n\n그림 28 는 position = \"fill\"을 적용한 것이다 .\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n그림 28: position: fill\n\n\n\n\n\n2.5 좌표\n좌표(coordinates) 혹은 좌표계(coordinate systems)는 그래픽 요소들의 위치 결정에 기준이 되는 준거체계이다. 특히 두 가지가 함수가 유용하다. coord_flip() 함수는 축을 전환한다.\n\nggplot(mpg, aes(x = drv, fill = class)) + \n  geom_bar(position = \"fill\") +\n  coord_flip()\n\n\n\n\n\n\n그림 29: coord_clip() 함수\n\n\n\n\ncoord_fixed() 함수는 두 축의 스케일을 절대화하여 동일하게 적용한다. x-축의 10 간격이 y-축의 10 간격과 동일하다. 이것을 적용하지 않으면 x-축이 길어지기 때문에 절대적 비교를 할 수 없게 된다.\n\nggplot(mpg, aes(cty, hwy)) +\n  geom_point() +\n  coord_fixed()\n\n\n\n\n\n\n그림 30: coord_fixed() 함수\n\n\n\n\n\n2.6 테마\n테마(themes)는 그래프의 외양에 영향을 끼치는 또 다른 요소이다. 우선, 전체적인 외양을 한꺼번에 바꿀 수 있다. ggplot2는 그림 31 에서 보는 처럼 모두 8가지 기본 테마를 제공한다.\n\n\n\n\n\n그림 31: ggplot2가 제공하는 테마(https://r4ds.hadley.nz/communication)\n\n\n기본값인 회색빛 배경이 마음에 들지 않았다면 그림 32 처럼 흑백 테마(theme_bw())를 적용할 수도 있다. 다른 테마도 적용해 보고 그 차이를 알아본다.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  theme_bw()\n\n\n\n\n\n\n그림 32: theme_bw() 테마의 지정\n\n\n\n\n이렇게 한꺼번에 그래프의 외관을 바꿀 수도 있지만 theme() 함수를 통해 그래프의 개별 요소 하나씩을 모두 조정할 수 있다. 중요한 그래픽 요소가 그림 33 에 나타나 있다.\n\n\n\n\n\n그림 33: ggplot2 패키지의 테마 요소(https://isabella-b.com/blog/ggplot2-theme-elements-reference/)\n\n\ntheme() 함수를 통해 수정 가능한 그래픽 요소는 그림 33 에 나타나 있는 것보다 훨씬 더 많다. 자세한 사항은 ggplot2 패키지의 해당 웹페이지를 참고한다.\n그림 34 는 몇 가지 요소를 수정한 사례이다.\n\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  labs(\n    title = \"Larger engine sizes tend to have lower fuel economy\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  theme(\n    legend.position = c(0.6, 0.7),\n    legend.direction = \"horizontal\",\n    plot.title = element_text(face = \"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(hjust = 0)\n  )\n\n\n\n\n\n\n그림 34: 개별 요소의 수정: theme() 함수",
    "crumbs": [
      "R과 데이터사이언스",
      "시각화하기"
    ]
  },
  {
    "objectID": "exec_06.html#기타-사항",
    "href": "exec_06.html#기타-사항",
    "title": "시각화하기",
    "section": "\n3 기타 사항",
    "text": "3 기타 사항\n\n3.1 라벨과 주석\nlab() 함수를 활용하면 그래프의 다양한 종류의 라벨을 설정할 수 있다.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  labs(\n    x = \"Engine displacement (L)\",\n    y = \"Highway fuel economy (mpg)\",\n    color = \"Car type\",\n    title = \"Fuel efficiency generally decreases with engine size\",\n    subtitle = \"Two seaters (sports cars) are an exception because of their light weight\",\n    caption = \"Data from fueleconomy.gov\"\n  )\n\n\n\n\n\n\n그림 35: 라벨링\n\n\n\n\n또 다른 기하객체인 geom_text() 혹은 geom_label()를 통해 그래프 속에 텍스트를 삽입할 수 있다. 주석이 겹치는 것을 방지하고자 싶다면 ggrepel 패키지를 사용하면 된다. 새로운 기하객체인 geom_label_repel() 함수가 사용되었는데, label이 하나의 시각속성으로 사용되는 것을 알 수 있다.\n\nlibrary(ggrepel)\nggplot(mpg, aes(displ, hwy)) + \n  geom_point(colour = \"red\") +\n  geom_label_repel(data = mpg |&gt; slice_sample(prop = 0.1), aes(label = class))\n\n\n\n\n\n\n그림 36: 라벨링: ggrepel 패키지\n\n\n\n\n\n3.2 레이아웃\n레이아웃(layout)은 복수의 그래프를 적절히 배치하여 하나의 그래픽으로 융합하는 과정을 의미한다. 수 많은 ggplot2의 확장 패키지(ggplot2 extensions) 중 하나인 patchwork 패키지를 활용하여 자유롭게 레이아웃을 만들 수 있다.\n\nlibrary(patchwork)\np1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  labs(title = \"Plot 1\")\np2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + \n  geom_boxplot() + \n  labs(title = \"Plot 2\")\np1 + p2\n\n\n\n\n\n\n그림 37: 레이아웃: patchwork 패키지\n\n\n\n\n\n3.3 그래프의 저장\n두 가지 방식이 있다.\n첫 번째 방식은 Output 창의 Plots 탭에 있는 Export 버턴을 이용하는 것이다. 다양한 그래픽 포맷 뿐만 아니라 pdf 형식으로도 저장할 수 있다.\n두 번째 방식은 ggplot2 의 ggsave() 함수를 이용하는 것이다. 결과물의 폰트 크기, 가로세로비(aspect ratio), 해상도 등을 종합적으로 고려하여 최적의 세팅값을 찾아야 한다. 자신의 디바이스에 따라 동일한 세팅값이 다른 결과를 산출할 수도 있다.\n\nmy_plot &lt;- ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  labs(\n    title = \"Larger engine sizes tend to have lower fuel economy\",\n    caption = \"Source: https://fueleconomy.gov.\"\n  ) +\n  theme(\n    legend.position = c(0.6, 0.7),\n    legend.direction = \"horizontal\",\n    plot.title = element_text(face = \"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(hjust = 0)\n  )\nggsave(filename = \"my_plot.jpg\", plot = my_plot, width = 8, height = 8 * 0.618, dpi = 600)",
    "crumbs": [
      "R과 데이터사이언스",
      "시각화하기"
    ]
  },
  {
    "objectID": "exec_04.html",
    "href": "exec_04.html",
    "title": "불러오기와 정돈하기",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 과정 중 데이터 불러오기(importing)와 데이터 정돈하기(tidying)에 집중한다. 아래의 그림 1 에서 보는 바처럼, 불러오기와 데이터 정돈하기는 데이터사이언스 프로세스의 첫 두 단계에 해당한다.\n\n\n\n\n\n그림 1: 데이터사이언스 프로세스와 불러오기 및 정돈하기(https://r4ds.hadley.nz/import.html)\n\n\n본격적으로 해당 주제를 다루기 전에 tidyverse의 공식 데이터 프레임 형식인 티블(tibble)에 대해 간단히 설명한다.\n우선 tidyverse 패키지를 불러온다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R과 데이터사이언스",
      "불러오기와 정돈하기"
    ]
  },
  {
    "objectID": "exec_04.html#개요",
    "href": "exec_04.html#개요",
    "title": "불러오기와 정돈하기",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 과정 중 데이터 불러오기(importing)와 데이터 정돈하기(tidying)에 집중한다. 아래의 그림 1 에서 보는 바처럼, 불러오기와 데이터 정돈하기는 데이터사이언스 프로세스의 첫 두 단계에 해당한다.\n\n\n\n\n\n그림 1: 데이터사이언스 프로세스와 불러오기 및 정돈하기(https://r4ds.hadley.nz/import.html)\n\n\n본격적으로 해당 주제를 다루기 전에 tidyverse의 공식 데이터 프레임 형식인 티블(tibble)에 대해 간단히 설명한다.\n우선 tidyverse 패키지를 불러온다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R과 데이터사이언스",
      "불러오기와 정돈하기"
    ]
  },
  {
    "objectID": "exec_04.html#티블tibble",
    "href": "exec_04.html#티블tibble",
    "title": "불러오기와 정돈하기",
    "section": "\n1 티블(tibble)",
    "text": "1 티블(tibble)\n\n1.1 왜 티블인가?\n데이터 프레임은 가장 널리 사용되는 데이터 형식이고, 일반적인 상황이라면 거의 대부분 데이터 프레임을 가지고 데이터사이언스를 한다. Base R은 전통적으로 data.frame 객체를 통해 데이터 프레임을 관리해왔다. tibble은 이러한 data.frame의 현대적 개량 버전으로 이해하면 되고, 조금의 차이는 있지만 대동소이하다. 이 새로운 데이터 프레임 형식은 tidyverse 패키지의 핵심 패키지 중 하나인 tibble 패키지에서 지원된다.\n\n1.2 티블 컬럼 유형\n한 개의 원소 이상의 어레이를 벡터라고 한다. 여기서 각 벡터가 가진 데이터의 성격을 벡터 유형(type)이라고 하고, 컬럼 유형(type) 혹은 데이터 유형이라고도 한다. 앞에서 살펴본 것처럼, 벡터는 숫자형일 수도 있고, 문자형일 수도 있다. 그러나 이러한 컬럼 유형은 훨씬 다양할 수 있다. 여기서는 tibble 패키지가 규정하는 컬럼 유형에 대해 살펴본다. 자세한 내용은 여기를 참조할 수 있다.\n\n\n\n\n\n\n\n\n클래스\n데이터 유형\n예시\n기호\n\n\n\n원자(atomic) 벡터\n논리형(logical)\nTRUE\nlgl\n\n\n\n정수형(integer)\n1L\nint\n\n\n\n실수형(double)\n1.5\ndbl\n\n\n\n문자형(character)\n\"A\"\nchr\n\n\n\n복소수형(complex)\n0+1i\ncpl\n\n\n\n원시형(raw)\nas.raw(1)\nraw\n\n\n리스트(list) 벡터\n리스트(list)\nlist(1)\nlist\n\n\n\n명명 리스트(named list)\nlist(a = 1)\nnamed list\n\n\n빌트인 객체\n범주형(factor)\nfactor(\"A\")\nfct\n\n\n\n순서형(ordered)\nordered(\"a\")\nord\n\n\n\n날짜형(Date)\nSys.Date()\ndate\n\n\n\n날짜시간형(POSIXt)\nSys.time()\ndttm\n\n\n\n시간차이형(difftime)\nvctrs::new_duration(1)\ndrtn\n\n\n데이터 프레임\n데이터 프레임(data.frame)\ndata.frame(a = 1)\ndf[,1]\n\n\n\n티블(tbl_df)\ntibble(a = 1)\ntibble[,1]\n\n\n\n1.3 티블 생성하기\n\n1.3.1 기존 데이터를 티블 포맷으로 변환하기\nBase R에 포함되어 있는 iris라는 데이터 프레임을 사용한다. 아래의 코드를 실행하면 iris 데이터가 data.frame 형식으로 저장되어 있음을 알 수 있다. Base R의 class() 함수의 쓰임새를 확인하라.\n\niris |&gt; \n  glimpse()  \n\nRows: 150\nColumns: 5\n$ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n\nclass(iris)\n\n[1] \"data.frame\"\n\n\nas_tibble() 함수를 이용하여 tibble 객체로 전환한다. 그러면 data.frame 객체가 tibble 객체로 전환된 것을 알 수 있다.\n\niris_tbl &lt;- iris |&gt; \n  as_tibble() \nclass(iris_tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n아래와 같이 데이터를 열어보면, data.frame 객체에서는 볼 수 없는 정보가 나타난다.\n\niris_tbl\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\n행이 150개이고 열이 5개라는 사실이 가장 위에 나타나 있고, 앞의 네개 컬럼의 데이터 유형은 실수형(dbl)이고 마지막 컬럼은 범주형(fct)라는 것을 알 수 있다.\n\n1.3.2 티블 객체를 직접 생성하기\ntibble 객체를 직접 생성하는 방식은 두 가지로 나뉜다.\n\n열-단위 방식(보다 일반적): 우선 열-벡터를 만들고 그것을 결합해 최종적인 tibble 객체를 만든다. tibble() 함수를 이용한다.\n행-단위 방식: 우선 행-벡터를 만들고 그것을 결합해 최종적인 tibble 객체를 만든다. tribble() 함수를 이용한다. tribble은 전치티블(transposed tibble)의 약자이다.\n\n\ntibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n\n# A tibble: 3 × 3\n      x y         z\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 h      0.08\n2     2 m      0.83\n3     5 g      0.6 \n\n\n\ntribble(\n  ~x, ~y, ~z,\n  1, \"h\", 0.08,\n  2, \"m\", 0.83,\n  5, \"g\", 0.60\n)\n\n# A tibble: 3 × 3\n      x y         z\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 h      0.08\n2     2 m      0.83\n3     5 g      0.6 \n\n\n\n1.4 유용한 티블 함수\n\n1.4.1 행이름 관련 함수\n행이름(row name)은 개별 행에 고유한 이름이 부여된 것으로, Base R의 data.frame 객체는 행이름으로 row.names라는 속성을 갖는다. 비롯 이것이 속성이긴 하지만 다른 컬럼 속성과는 구별되며 하나의 숨겨진 속성처럼 취급된다. 그런데 tibble 패키지는 행이름 지정을 권장하지 않고, 행이름을 지정하는 간단한 함수도 제공하지 않는다. 타이디버스 철학은 행이름을 숨겨진 속성처럼 취급하기 보다는 하나의 명시적인 컬럼으로 취급하는 것이 더 낳다는 관점에 기반한다. 그러나 tibble 패키지는 row.names를 가진 data.frame 객체에 적용할 수 있는 몇 가지 행이름 관련 함수를 제공한다.\n위에서와 동일하게 단순한 티블 객체를 생성한다.\n\ntbl_1 &lt;- tibble(\n  x = c(1, 2, 5), \n  y = c(\"h\", \"m\", \"g\"),\n  z = c(0.08, 0.83, 0.60)\n)\n\n행이름(row.name)를 지정한다. tibble 객체를 data.frame 객체로 전환해 베이스 R의 함수인 row.names()를 이용해 행이름을 지정한다.\n\ndf_1 &lt;- as.data.frame(tbl_1)\nrow.names(df_1) &lt;- c(\"A\", \"B\", \"C\")\ndf_1\n\n  x y    z\nA 1 h 0.08\nB 2 m 0.83\nC 5 g 0.60\n\n\nremove_rownames() 함수를 이용해 행이름을 제거할 수 있다.\n\ndf_1 |&gt; remove_rownames()\n\n  x y    z\n1 1 h 0.08\n2 2 m 0.83\n3 5 g 0.60\n\n\nrownames_to_column() 함수를 이용해 행이름을 또 다른 컬럼으로 전환할 수 있다.\n\ndf_1 |&gt; rownames_to_column(\"name\")\n\n  name x y    z\n1    A 1 h 0.08\n2    B 2 m 0.83\n3    C 5 g 0.60\n\n\ncolumn_to_rownames() 함수를 이용해 특정 컬럼을 행이름으로 전환할 수 있다.\n\ndf_1 |&gt; rownames_to_column(\"name\") |&gt; \n  column_to_rownames(\"name\")\n\n  x y    z\nA 1 h 0.08\nB 2 m 0.83\nC 5 g 0.60\n\n\n\n1.4.2 행 혹은 열 삽입 함수\n다음과 같이 한 행을 삽입한다.\n\ntbl_1 |&gt; add_row(x = 10, y = \"u\", z = 0.75)\n\n# A tibble: 4 × 3\n      x y         z\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 h      0.08\n2     2 m      0.83\n3     5 g      0.6 \n4    10 u      0.75\n\n\n다음과 같은 방식으로 여러 행을 삽입할 수 있다.\n\ntbl_1 |&gt; \n  add_row(x = c(10, 15), y = c(\"u\", \"x\"), z = c(0.75, 1.10))\n\n# A tibble: 5 × 3\n      x y         z\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 h      0.08\n2     2 m      0.83\n3     5 g      0.6 \n4    10 u      0.75\n5    15 x      1.1 \n\n\n다음과 같이 한 열을 삽입한다.\n\ntbl_1 |&gt; add_column(p = c(\"TRUE\", \"TRUE\", \"FALSE\"))\n\n# A tibble: 3 × 4\n      x y         z p    \n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n1     1 h      0.08 TRUE \n2     2 m      0.83 TRUE \n3     5 g      0.6  FALSE\n\n\n다음과 같은 방식으로 여러 열을 삽입할 수 있다.\n\ntbl_1 |&gt; \n  add_column(p = c(\"TRUE\", \"TRUE\", \"FALSE\"), q = c(1L, 2L, 3L))\n\n# A tibble: 3 × 5\n      x y         z p         q\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt;\n1     1 h      0.08 TRUE      1\n2     2 m      0.83 TRUE      2\n3     5 g      0.6  FALSE     3",
    "crumbs": [
      "R과 데이터사이언스",
      "불러오기와 정돈하기"
    ]
  },
  {
    "objectID": "exec_04.html#데이터-불러오기",
    "href": "exec_04.html#데이터-불러오기",
    "title": "불러오기와 정돈하기",
    "section": "\n2 데이터 불러오기",
    "text": "2 데이터 불러오기\n\n2.1 readr 패키지\n\n2.1.1 파일 형식\nreadr 패키지는 다양한 함수를 이용해 다양한 형식의 데이터를 불러올 수 있게 도와준다.\n\nread_csv(): 콤마분리(comma-separated values, CSV) 형식의 파일\nread_csv2(): 세미콜론분리(semicolon-separated) 형식의 파일\nread_tsv(): 탭구분(tab-delimited) 형식의 파일\nread_delim(): 여타의 구분 형식의 파일\nread_fwf(): 고정폭(fixed-width) 형식의 파일\nread_table(): 공백구분 형식의 파일\nread_log(): 아파치 형식(Apache-style)의 로그 파일\n\n2.1.2 컬럼 파싱 함수들\n컬럼의 내용 중 특정한 유형의 정보만 추출하는 것을 파싱(parsing)이라고 한다. 이러한 파싱은 새로운 데이터를 읽어들이는 과정에서 파싱을 하는 경우와 기존의 벡터에서 특정 유형을 값을 추출하기 위해 파싱하는 경우의 두 가지로 나뉠 수 있는데, 데이터 유형별로 쌍둥이 함수가 존재한다.\n\n\n데이터 유형\n새로운 벡터 불러들이기\n기존 벡터에 적용하기\n\n\n\n논리형(logical)\ncol_logical()\nparse_logical()\n\n\n정수형(integer)\ncol_integer()\nparse_integer()\n\n\n실수형(double)\ncol_double()\nparse_double()\n\n\n문자형(character)\ncol_character()\nparse_character()\n\n\n일시형(datetime)\ncol_datetime()\nparse_datetime()\n\n\n날짜형(date)\ncol_date()\nparse_date()\n\n\n시간형(time)\ncol_time()\nparse_time()\n\n\n범주형(factor)\ncol_factor()\nparse_factor()\n\n\n추측형(guess)\ncol_guess()\nparse_guess()\n\n\n수치형(number)\ncol_number()\nparse_number()\n\n\n\n새로운 벡터를 위한 파싱은 데이터를 불러들이는 과정에서 컬럼 별로 미리 데이터 유형을 지정하면 여러가지로 이점이 있기 때문에 중요하다. 간단한 사례를 살펴보자.\n\nread_csv(\"\n  logical,numeric,date,string\n  TRUE,1,2021-01-15,abc\n  false,4.5,2021-02-15,def\n  T,Inf,2021-02-16,ghi\n\")\n\n# A tibble: 3 × 4\n  logical numeric date       string\n  &lt;lgl&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt; \n1 TRUE        1   2021-01-15 abc   \n2 FALSE       4.5 2021-02-15 def   \n3 TRUE      Inf   2021-02-16 ghi   \n\n\n데이터가 깔끔하게 주어진다면 데이터를 불러드리는 과정에 개별 컬럼의 유형을 지정할 필요가 없다. 그러나 현실이 이렇게 간단하지 않을 수 있고, 좀 더 복잡한 예제는 다음에서 다루도록 한다.\n\n2.1.3 read_csv() 함수의 활용\n지난번 실습에서 사용한 데이터를 면밀히 살펴본다.\n\nstudents &lt;- read_csv(\"https://pos.it/r4ds-students-csv\")\nstudents\n\n# A tibble: 6 × 5\n  `Student ID` `Full Name`      favourite.food     mealPlan            AGE  \n         &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;\n1            1 Sunil Huffmann   Strawberry yoghurt Lunch only          4    \n2            2 Barclay Lynn     French fries       Lunch only          5    \n3            3 Jayendra Lyne    N/A                Breakfast and lunch 7    \n4            4 Leon Rossini     Anchovies          Lunch only          &lt;NA&gt; \n5            5 Chidiegwu Dunkel Pizza              Breakfast and lunch five \n6            6 Güvenç Attila    Ice cream          Lunch only          6    \n\n\n다음의 몇 가지 점이 불만족스럽다.\n\n변수명: 특히 Student ID와 Full Name 변수명은 규칙에 어긋난다. 변수명 속에 공란이 있으면 좋지 않다. 이런 이름을 비구문명(non-syntactic name)이라고 하고, 백틱(` `)으로 둘러싸여 표시된다. 나중에 문제를 일으킬 수 있다.\n변수 형식: mealPlan은 문자형(chr)이 아니라 팩트형(fct)이며, AGE는 문자형(chr)이 아니라 수치형(dbl)이 적절하다.\n결측치(NA): favourite.food의 ’N/A’는 형식에 맞지 않아 결측치가 아니라 문자로 취급된다. 따라서 ’N/A’가 결측치임을 알려주어야 한다.\n\n이러한 점을 반영하여 csv 파일을 다시 불러오기한다. 여기서 여러 인수의 기능을 이해하는 것이 중요하다. skip 인수는 몇번 째 행까지를 읽지 않을 것인가를 지정한다. col_names 인수는 컬럼 이름을 지정한다. col_types 인수는 컬럼의 유형을 미리 설정하는데, 여기에 위에서 언급한 파싱 함수가 사용된다. na 인수는 어떤 셀 값(여기서는 “N/A”)을 결측치(NA)로 취급할 것인가를 지정한다.\n\nstudents &lt;- read_csv(\n  \"https://pos.it/r4ds-students-csv\", \n  skip = 1, \n  col_names = c(\"student_id\", \"full_name\", \"favorite_food\", \"meal_plan\", \"age\"),\n  col_types = cols(\n    meal_plan = col_factor(),\n    age = col_number()),\n  na = c(\"N/A\")\n  )\nstudents\n\n# A tibble: 6 × 5\n  student_id full_name        favorite_food      meal_plan             age\n       &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;\n1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4\n2          2 Barclay Lynn     French fries       Lunch only              5\n3          3 Jayendra Lyne    &lt;NA&gt;               Breakfast and lunch     7\n4          4 Leon Rossini     Anchovies          Lunch only             NA\n5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch    NA\n6          6 Güvenç Attila    Ice cream          Lunch only              6\n\n\n\n2.2 엑셀 파일\n\n2.2.1 readxl 패키지\n가장 널리 사용되는 스프레드시트(spreadsheet) 형식인 엑셀 파일을 불러들이기 위해서는 readxl이라는 패키지가 필요하다. tidyverse의 핵심 패키지는 아니지만 일종의 친척 패키지라 할 수는 있다. tidyverse에 포함되어 있지 않기 때문에 따로 인스톨하고 library() 함수를 통해 불러와야 한다.\n\nlibrary(readxl)\n\n가장 널리 사용되는 명령어는 다음의 세 가지이다.\n\nread_xls(): xls 확장자를 가진 엑셀 파일 불러오기\nread_xlsx(): xlsx 확장자를 가진 엑셀 파일 불러오기\nread_excel(): xls 혹은 xlsx 확장자를 가진 엑셀 파일 불러오기\n\n2.2.2 read_excel() 함수의 활용\nWorld Population Prospects 2024 데이터를 직접 다운받아 실습을 진행하고자 한다. 이 데이터셋은 매우 중요하다. 다음의 절차에 따라 해당 엑셀 파일을 다운로드한다.\n\nWPP 웹사이트(https://population.un.org/wpp/)에 접속한다.\nDownload Data Files를 클릭한다.\n\n\n\n\n\n\n그림 2: WPP 데이터 홈페이지(https://population.un.org/wpp/)\n\n\n\n다음의 파일을 클릭한다: Compact (most used: estimates and medium projections) (XLSX)\n\n\n\n\n\n\n그림 3: WPP 데이터 선택\n\n\n\n엑셀 파일(WPP2024_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT.xlsx)을 다운로드하여 자신의 프로젝트 폴더에 저장한다.\n\nR 바깥에서 다운로드한 파일을 열어 어떠한 정보가 어떠한 방식으로 수록되어 있는지 살펴본다. 데이터 불러오기를 위해 다음의 네 가지 사항에 유의해야 함을 이해한다.\n\n16번 행까지는 불필요한 영역이다.\n17번 행을 변수명으로 사용할 경우 많은 문제점이 발생한다.\n결측치는 공란이거나 ‘…’ 기호로 표시되어 있다.\n첫 번째 워킹시트(Estimates)에는 1950~2023의 데이터가, 두 번째 워킹시트(Medium variant)에는 2024~2100년의 데이터가 수록되어 있다. 나중에 결합해야한다.\n\n우선 엑셀 파일을 그대로 불러와 본다.\n\nread_excel(\n  \"WPP2024_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT.xlsx\", \n  sheet = \"Estimates\" \n  )\n\n# A tibble: 21,995 × 65\n   ...1  ...2  ...3  ...4  `United Nations`  ...6  ...7  ...8  ...9  ...10 ...11\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;             &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  \"Population Divi… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 2 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  \"Department of E… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 3 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;             &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 4 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  \"World Populatio… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 5 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  \"File GEN/01/REV… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 6 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  \"Estimates, 1950… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 7 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  \"POP/DB/WPP/Rev.… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 8 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  \"© July 2024 by … &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n 9 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  \"Suggested citat… &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n10 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;             &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; \n# ℹ 21,985 more rows\n# ℹ 54 more variables: ...12 &lt;chr&gt;, ...13 &lt;chr&gt;, ...14 &lt;chr&gt;, ...15 &lt;chr&gt;,\n#   ...16 &lt;chr&gt;, ...17 &lt;chr&gt;, ...18 &lt;chr&gt;, ...19 &lt;chr&gt;, ...20 &lt;chr&gt;,\n#   ...21 &lt;chr&gt;, ...22 &lt;chr&gt;, ...23 &lt;chr&gt;, ...24 &lt;chr&gt;, ...25 &lt;chr&gt;,\n#   ...26 &lt;chr&gt;, ...27 &lt;chr&gt;, ...28 &lt;chr&gt;, ...29 &lt;chr&gt;, ...30 &lt;chr&gt;,\n#   ...31 &lt;chr&gt;, ...32 &lt;chr&gt;, ...33 &lt;chr&gt;, ...34 &lt;chr&gt;, ...35 &lt;chr&gt;,\n#   ...36 &lt;chr&gt;, ...37 &lt;chr&gt;, ...38 &lt;chr&gt;, ...39 &lt;chr&gt;, ...40 &lt;chr&gt;, …\n\n\n끔찍하다. 위의 네 가지 사항을 감안하여 다음과 같은 코드를 실행한다.\n\nnew_names &lt;- c(\"index\", \"variant\", \"region_name\", \"notes\", \"location_code\", \n               \"ISO3\", \"ISO2\", \"SDMX\", \"type\", \"parent_code\", \"year\", \"pop_jan_total\", \n               \"pop_jul_total\", \"pop_jul_total_male\", \"pop_jul_total_female\", \"pop_den\", \"sex_ratio\", \n               \"median_age\", \"natural_change\", \"RNC\", \"pop_change\", \"PGR\", \n               \"doubling_time\", \"births\", \"births_by_f1519\", \"CBR\", \"TFR\", \"NRR\", \n               \"mean_age_childbearing\", \"sex_ratio_birth\", \"deaths_total\", \n               \"deaths_male\", \"deaths_female\", \"CDR\", \"life_exp_total\", \n               \"life_exp_male\", \"life_exp_female\", \"life_exp_15_total\", \n               \"life_exp_15_male\", \"life_exp_15_female\", \"life_exp_65_total\", \n               \"life_exp_65_male\", \"life_exp_65_female\", \"life_exp_80_total\", \n               \"life_exp_80_male\", \"life_exp_80_female\", \"infant_deaths\", \n               \"IMR\", \"live_births\", \"under_five_deaths\", \"mort_under_five\", \n               \"mort_bf_40_total\", \"mort_bf_40_male\", \"mort_bf_40_female\", \"mort_bf_60_total\", \n               \"mort_bf_60_male\", \"mort_bf_60_female\", \"mort_bt_1550_total\", \n               \"mort_bt_1550_male\", \"mort_bt_1550_female\", \"mort_bt_1560_total\", \n               \"mort_bt_1560_male\", \"mort_bt_1560_female\", \"net_migrants\", \"NMR\")\n\nwpp_2024_estimates &lt;- read_excel(\n  \"D:/My R/Population Geography/WPP2024_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT.xlsx\",\n  sheet = \"Estimates\",\n  skip = 17, \n  col_names = new_names,\n  col_types = c(rep(\"guess\", 3), \"text\", \"guess\", rep(\"text\", 2), rep(\"guess\", 58)),\n  na = c(\"...\", \"\")\n)\n\nwpp_2024_future &lt;- read_excel(\n  \"D:/My R/Population Geography/WPP2024_GEN_F01_DEMOGRAPHIC_INDICATORS_COMPACT.xlsx\",\n  sheet = \"Medium variant\",\n  skip = 17, \n  col_names = new_names,\n  col_types = c(rep(\"guess\", 3), \"text\", \"guess\", rep(\"text\", 2), rep(\"guess\", 58)),\n  na = c(\"...\", \"\")\n)\n\nwpp_2024 &lt;- bind_rows(wpp_2024_estimates, wpp_2024_future)\n\nwpp_2024 &lt;- wpp_2024 |&gt; \n  filter(\n    type != \"Label/Separator\"\n  ) |&gt; \n  mutate(\n    across(\n      c(pop_jan_total, pop_jul_total, pop_jul_total_male, pop_jul_total_female, \n        natural_change, pop_change, births, deaths_total, \n        deaths_male, deaths_female, net_migrants), \\(x) x * 1000\n    )\n  )\n\nview(wpp_2024)\n\n위의 코드는 다음의 단계로 진행된 것이다.\n\n변수명을 새로 지정해 둔다.\nread_excel() 함수를 이용하여 시트명이 “Estimates”(1950-2023)인 것을 불러들인다. sheet, skip, col_names, col_types, na과 같은 인수가 사용된다. sheet 인수는 엑셀 시트의 이름을 지정하고, skip 인수는 몇번 째 행까지를 읽지 않을 것인가를 지정한다. col_names 인수는 컬럼 이름을 지정하는데, 미리 만들어 둔 new_names 객체가 지정된 것을 볼 수 있다. col_types 인수는 컬럼의 유형을 미리 설정하는데, “skip”, “guess”, “logical”, “numeric”, “date”, “text”, “list” 중 선택을 할 수 있다. 불러들인 후 다시 지정할 수도 있지만 미리 해두면 불러 들이는 시간을 좀 더 단축할 수 있다.\n동일한 방식으로 시트명이 “Medium variant”(2024-2100)인 것을 불러들인다. 동일한 인수가 사용된다.\nbind_rows() 함수를 이용하여 두 객체를 결합한다.\n불필요한 행(type 컬럼이 “Label/Separator”로 되어 있는 경우)을 제거하고, 단위가 1,000으로 설정되어 있는 변수들을 원 변수값으로 되돌린다.\n\n나중에 사용하기 위해, writexl 패키지의 write_xlsx() 함수를 이용하여 엑셀 파일로 저장한다.\n\nlibrary(writexl)\nwrite_xlsx(wpp_2024, \"wpp_2024.xlsx\")\n\n그런데, 저장된 파일을 read_excel() 함수로 다시 불러 들이면 컬럼 형식에 대한 정보가 사라져 버리는 등의 에러가 발생한다. 이런 점 때문에 다음과 같은 대안이 존재한다. readr 패키지의 write_rds() 함수로 저장하고, 다시 read_rds() 함수로 불러들이면 정확히 동일한 것을 얻을 수 있다. RDS는 R에서만 사용되는 데이터 이진 포맷(binary format)이다.\n\nwrite_rds(wpp_2024, \"wpp_2024.rds\")\nread_rds(\"wpp_2024.rds\")\n\n# A tibble: 44,847 × 65\n   index variant   region_name notes location_code ISO3  ISO2   SDMX type \n   &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n 1     1 Estimates World       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 2     2 Estimates World       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 3     3 Estimates World       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 4     4 Estimates World       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 5     5 Estimates World       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 6     6 Estimates World       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 7     7 Estimates World       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 8     8 Estimates World       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n 9     9 Estimates World       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n10    10 Estimates World       &lt;NA&gt;            900 &lt;NA&gt;  &lt;NA&gt;      1 World\n# ℹ 44,837 more rows\n# ℹ 56 more variables: parent_code &lt;dbl&gt;, year &lt;dbl&gt;, pop_jan_total &lt;dbl&gt;,\n#   pop_jul_total &lt;dbl&gt;, pop_jul_total_male &lt;dbl&gt;, pop_jul_total_female &lt;dbl&gt;,\n#   pop_den &lt;dbl&gt;, sex_ratio &lt;dbl&gt;, median_age &lt;dbl&gt;, natural_change &lt;dbl&gt;,\n#   RNC &lt;dbl&gt;, pop_change &lt;dbl&gt;, PGR &lt;dbl&gt;, doubling_time &lt;dbl&gt;, births &lt;dbl&gt;,\n#   births_by_f1519 &lt;dbl&gt;, CBR &lt;dbl&gt;, TFR &lt;dbl&gt;, NRR &lt;dbl&gt;,\n#   mean_age_childbearing &lt;dbl&gt;, sex_ratio_birth &lt;dbl&gt;, deaths_total &lt;dbl&gt;, …\n\n\n\n2.3 데이터 쓰기\nreadr 패키지는 write_csv(), write_delim()와 같은 함수를 제공한다. 엑셀 파일을 저장하기 위해서는 writexl 패키지의 write_xlsx() 함수를 사용한다. 혹은 openxlsx 패키지의 write.xlsx() 함수를 사용할 수도 있다.",
    "crumbs": [
      "R과 데이터사이언스",
      "불러오기와 정돈하기"
    ]
  },
  {
    "objectID": "exec_04.html#데이터-정돈하기",
    "href": "exec_04.html#데이터-정돈하기",
    "title": "불러오기와 정돈하기",
    "section": "\n3 데이터 정돈하기",
    "text": "3 데이터 정돈하기\n데이터 정돈하기는 ’지저분한 데이터(messy data)’를 ’정돈된 데이터(tidy data)’로 만드는 과정을 의미한다. 정돈된 데이터는 다음의 세 가지 속성을 갖는다.\n\n개별 변수(variable)는 열(컬럼, column) 하나를 차지한다. 즉, 개별 열에는 하나의 변수가 위치한다.\n개별 관측개체(observation)는 하나의 행(로, row)을 차지한다. 즉, 개별 행에는 하나의 관측개체가 위치한다.\n개별 값(value)은 하나의 셀(cell)을 차지한다. 즉, 개별 셀에는 하나의 값이 위치한다.\n\n이 세가지 속성 중 하나라도 위배하는 데이터는 정돈된 데이터가 아니다. 어떤 데이터이건 그것이 정돈된 데이터이기만 하다면, 표준적인 툴을 통해 해당 데이터를 다른 데이터와 동일한 방식으로 다룰 수 있다. 데이터 정리하기에 특화된 패키지가 tidyverse 패키지의 핵심 패키지 중의 하나인 tidyr 패키지이다.\n데이터 정돈하기는 다음의 세 가지 범주로 나뉜다.\n\n데이터 구조 변형: 가장 중요한 오퍼레이션으로 데이터 늘이기와 데이터 넓히기기가 포함된다.\n컬럼의 결합 및 분할: 두 개 이상의 컬럼을 하나의 컬럼으로 결합하거나 한 컬럼을 두 개 이상의 컬럼으로 분할한다.\n결측치 처리: 결측치가 포함된 행을 다양한 방식으로 처리한다.\n\n\n3.1 데이터 구조 변형\n여기서는 데이터 늘이기(lengthening data)와 데이터 넓히기(widening data)에 집중한다. 데이터 늘이기는 행을 늘이는 방식으로 데이터 구조를 변형하는 것이고, 데이터 넓히기는 컬럼의 숫자를 늘이는 방식으로 데이터 구조를 변형하는 것이다.\n\n3.1.1 데이터 늘이기\n실습을 위해 tidyverse 패키지에 포함되어 있는 billboard 데이터를 사용한다. 이 데이터셋에는 2000년 한해 동안 노래의 주별 순위 정보가 포함되어 있다.\n\nbillboard\n\n# A tibble: 317 × 79\n   artist     track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n   &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 2 Pac      Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n 2 2Ge+her    The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n 3 3 Doors D… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n 4 3 Doors D… Loser 2000-10-21      76    76    72    69    67    65    55    59\n 5 504 Boyz   Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n 6 98^0       Give… 2000-08-19      51    39    34    26    26    19     2     2\n 7 A*Teens    Danc… 2000-07-08      97    97    96    95   100    NA    NA    NA\n 8 Aaliyah    I Do… 2000-01-29      84    62    51    41    38    35    35    38\n 9 Aaliyah    Try … 2000-03-18      59    53    38    28    21    18    16    14\n10 Adams, Yo… Open… 2000-08-26      76    76    74    69    68    67    61    58\n# ℹ 307 more rows\n# ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;,\n#   wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;,\n#   wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,\n#   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;,\n#   wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;,\n#   wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, …\n\n\n관측개체는 개별 노래이며 앞의 세 변수(artist, track, data.entered)는 노래 관련 속성이고, 나머지 76개 변수(wk1~wk76)는 76주간 개별 노래의 순위를 나타낸다. 어떤 주인가는 변수일 수 없으므로 week라는 변수를 생성하여 개별주가 변수값이 되게 데이터를 변형할 필요가 있다.\n\nbillboard |&gt; \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\"\n  )\n\n# A tibble: 24,092 × 5\n   artist track                   date.entered week   rank\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n 7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n 8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n 9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n# ℹ 24,082 more rows\n\n\ncols는 새로 생성될 변수의 변수값이 되어야 할 현 데이터셋의 변수들을 지정한다. names_to는 cols를 통해 지정된 변수명이 변수값으로 들어갈 새로 운 변수의 이름을 지정한다. values_to는 cols 변수들의 변수값들이 들어갈 새로운 변수의 이름을 지정한다.\n그런데, 좀 더 복잡한 데이터 늘이기의 상황이 있을 수 있다. tidyverse 패키지에 포함되어 있는 who2 데이터를 사용한다. 이것은 WHO(world Health Organization, 세계보건기구)에서 제공한 데이터로서 1980~2013년 전세계 209개국의 결핵 환자수에 대한 데이터이다.\n\nglimpse(who2)\n\nRows: 7,240\nColumns: 58\n$ country    &lt;chr&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\",…\n$ year       &lt;dbl&gt; 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989,…\n$ sp_m_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_m_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sp_f_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_m_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ sn_f_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_m_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_014   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_1524  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_2534  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_3544  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_4554  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_5564  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ep_f_65    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_014  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_1524 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_2534 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_3544 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_4554 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_5564 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_m_65   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_014  &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_1524 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_2534 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_3544 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_4554 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_5564 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ rel_f_65   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n\n\ncountry와 year은 분명한 변수이지만 나머지 56개 변수는 무엇인지 알 수 없다. 그런데 잘 살펴보면, 변수명에 어떤 패턴이 있다는 것을 알 수 있다. 모두 세 부분으로 나뉘어져 있는데, 첫 번째 부분은 진단법(sp, rel, ep)과 관련되어 있고, 두 번째 부분은 성(m, f)과 관련되어 있고, 세 번째 부분은 연령(014, 1524, 2534, 3544, 4554, 5564, 65)과 관련되어 있다. 56개 변수의 셀 값은 모두 케이스(환자수)를 의미한다. 이 지저분한 데이터를 pivot_longer() 함수를 이용해 정돈된 데이터로 만들어 본다.\n\nwho2 |&gt; \n  pivot_longer(\n    cols = !c(country, year),\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_sep = \"_\",\n    values_to = \"count\"\n  )\n\n# A tibble: 405,440 × 6\n   country      year diagnosis gender age   count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt;\n 1 Afghanistan  1980 sp        m      014      NA\n 2 Afghanistan  1980 sp        m      1524     NA\n 3 Afghanistan  1980 sp        m      2534     NA\n 4 Afghanistan  1980 sp        m      3544     NA\n 5 Afghanistan  1980 sp        m      4554     NA\n 6 Afghanistan  1980 sp        m      5564     NA\n 7 Afghanistan  1980 sp        m      65       NA\n 8 Afghanistan  1980 sp        f      014      NA\n 9 Afghanistan  1980 sp        f      1524     NA\n10 Afghanistan  1980 sp        f      2534     NA\n# ℹ 405,430 more rows\n\n\n각 인수의 역할에 대해 이해하는 것이 중요하다. 그리고 정돈된 데이터를 만들기 위해 왜 데이터 ’늘이기’를 해야하는지 생각해 본다.\n이것보다 좀 더 복잡한 데이터 늘이기의 상황이 있을 수 있다. 간단한 예시인 household 데이터를 살펴보자.\n\nhousehold\n\n# A tibble: 5 × 5\n  family dob_child1 dob_child2 name_child1 name_child2\n   &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;       &lt;chr&gt;      \n1      1 1998-11-26 2000-01-29 Susan       Jose       \n2      2 1996-06-22 NA         Mark        &lt;NA&gt;       \n3      3 2002-07-11 2004-04-05 Sam         Seth       \n4      4 2004-10-10 2009-08-27 Craig       Khai       \n5      5 2000-12-05 2005-02-28 Parker      Gracie     \n\n\n자세히 살펴보면 변수명에 두 개의 변수(dob, name)와 또 다른 변수(child)의 두 숫자(1, 2)가 포함되어 있다. 각 family별로 최대 두 명까지의 자녀가 있고 각 자녀별로 생년월일과 이름에 대한 정보가 포함되어 있다. 첫 행은 첫 번째 가정의 첫 번째 자녀의 생년월일은 1998년 11월 26일이고 이름은 Susan이며, 두 번째 자녀의 생년월일은 2000년 1월 29일이고 이름은 Jose이다. 분리자인 “_”이 존재하므로 dob와 name은 두 변수로 분리하고, 첫번째 자녀인지 두번째 자녀인지를 알려주는 또 다른 변수를 생성해야 한다. 이를 위해 .value라고 하는 특별한 것을 사용한다.\n\nhousehold |&gt; \n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), \n    names_sep = \"_\", \n    values_drop_na = TRUE\n  )\n\n# A tibble: 9 × 4\n  family child  dob        name  \n   &lt;int&gt; &lt;chr&gt;  &lt;date&gt;     &lt;chr&gt; \n1      1 child1 1998-11-26 Susan \n2      1 child2 2000-01-29 Jose  \n3      2 child1 1996-06-22 Mark  \n4      3 child1 2002-07-11 Sam   \n5      3 child2 2004-04-05 Seth  \n6      4 child1 2004-10-10 Craig \n7      4 child2 2009-08-27 Khai  \n8      5 child1 2000-12-05 Parker\n9      5 child2 2005-02-28 Gracie\n\n\nnames_to = c(\".value\", \"child\")와 names_sep = \"_\"는 네 개의 변수(dob_child1, dob_child2, name_child1, name_child2)의 이름을 크게 두 부분으로 분할하여 앞 부분(dob와 name)을 새로운 변수로 생성하고, 뒷 부분(child1, child2)는 child라는 변수를 새로 생성하여 그것은 변수값으로 전환한다. 결국 변수명의 일부는 새로운 변수명이 되고, 또 다른 일부는 변수값이 되는 것이다. 이렇게 되면 values_to 아규먼트가 필요없게 된다. 마지막에 있는 values_drop_na 아규먼트도 중요한 역할을 하는데, 두 번째 가정은 한 자녀만을 가지고 있기 때문에 결측값이 포함되어 있는데 그것을 최종 결과에 포함시키지 않는 일을 한다.\n\n3.1.2 데이터 넓히기\n실습을 위해 tidyverse 패키지에 포함되어 있는 cms_patient_experience 데이터를 사용한다. 이것은 미국의 Centers of Medicare and Meicaid Services가 제공한 데이터이다.\n\ncms_patient_experience\n\n# A tibble: 500 × 5\n   org_pac_id org_nm                           measure_cd measure_title prf_rate\n   &lt;chr&gt;      &lt;chr&gt;                            &lt;chr&gt;      &lt;chr&gt;            &lt;dbl&gt;\n 1 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       63\n 2 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       87\n 3 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       86\n 4 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       57\n 5 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       85\n 6 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       24\n 7 0446162697 ASSOCIATION OF UNIVERSITY PHYSI… CAHPS_GRP… CAHPS for MI…       59\n 8 0446162697 ASSOCIATION OF UNIVERSITY PHYSI… CAHPS_GRP… CAHPS for MI…       85\n 9 0446162697 ASSOCIATION OF UNIVERSITY PHYSI… CAHPS_GRP… CAHPS for MI…       83\n10 0446162697 ASSOCIATION OF UNIVERSITY PHYSI… CAHPS_GRP… CAHPS for MI…       63\n# ℹ 490 more rows\n\n\n이 데이터도 정돈된 데이터가 아니다. 자세히 살펴보면 다음과 같은 사실을 알 수 있다.\n\norg_pac_id와 org_nm 변수는 의료조직의 식별자와 이름이다.\n의료조직별로 6개씩의 열을 차지하고 있는데, 6개의 열은 measure_cd와 measure_title에 나타나 있는 것과 같은 6개의 서로 다른 조사 항목을 나타낸다.\n마지막의 prf_rate는 조사 항목별 점수이다.\n\npivot_wider() 함수를 이용하여, 행에는 개별 의료조직이, 열에는 개별 조사 항목이 나타나는 정돈된 데이터를 만들어 본다.\n\ncms_patient_experience |&gt; \n  pivot_wider(\n    id_cols = starts_with(\"org\"),\n    names_from = measure_cd,\n    values_from = prf_rate\n  )\n\n# A tibble: 95 × 8\n   org_pac_id org_nm CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5 CAHPS_GRP_8\n   &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 0446157747 USC C…          63          87          86          57          85\n 2 0446162697 ASSOC…          59          85          83          63          88\n 3 0547164295 BEAVE…          49          NA          75          44          73\n 4 0749333730 CAPE …          67          84          85          65          82\n 5 0840104360 ALLIA…          66          87          87          64          87\n 6 0840109864 REX H…          73          87          84          67          91\n 7 0840513552 SCL H…          58          83          76          58          78\n 8 0941545784 GRITM…          46          86          81          54          NA\n 9 1052612785 COMMU…          65          84          80          58          87\n10 1254237779 OUR L…          61          NA          NA          65          NA\n# ℹ 85 more rows\n# ℹ 1 more variable: CAHPS_GRP_12 &lt;dbl&gt;\n\n\n이제 어떤 의료조직이 어떤 항목에서 얼마의 점수를 받았는지를 일목요연하게 알아 볼 수 있다. id_cols는 각 행의 완전한 고유성을 위해 필요한 모든 변수를 지정한다. 사례의 경우 org가 들어가는 org_pac_id와 org_nm이 그 역할을 하는데, 사실 둘은 판별자로서 동일한 것이기 때문에 둘 중 하나만 사용해도 된다. 그러나 그러면 최종 산출물에서 지정되지 않은 컬럼은 나타나지 않기 때문에 동일한 기능을 하더라도 모두 지정하는 것이 좋다. 여러개의 변수가 집합적으로 판별자 역할을 하는 경우가 많이 있으며, 그럴 경우 해당 변수를 모두 지정해 주어야 한다. 하나라도 누락되면 에러가 발생하거나 원치 않는 결과를 얻게 된다. names_from은 새로이 생성될 변수들의 이름을 변수값으로 가지고 있는 변수명을 지정한다. values_from은 새로 생성될 변수들의 변수값이 될 값이 어떤 변수로부터 오는지를 지정한다. 정돈된 데이터를 만들기 위해 이번에는 왜 데이터 ’넓히기’를 해야했는지 생각해 본다.\n\n3.2 컬럼의 결합 및 분할\n\n3.2.1 컬럼 결합하기\n두 개 이상의 컬럼을 연합하여 하나의 새로운 컬럼을 생성한다. 우선 간단한 예제 티블 객체를 생성한다.\n\nb_tibble &lt;- tibble(\n  country = c(\"A\", \"A\", \"B\", \"B\"),\n  century = c(\"19\", \"20\", \"19\", \"20\"),\n  year = c(\"99\", \"00\", \"99\", \"00\")\n)\nb_tibble\n\n# A tibble: 4 × 3\n  country century year \n  &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;\n1 A       19      99   \n2 A       20      00   \n3 B       19      99   \n4 B       20      00   \n\n\ncentury와 year 컬럼을 결합하여 새로운 컬럼을 생성한다.\n\nb_tibble |&gt; unite(century, year, col = \"year\", sep = \"\")\n\n# A tibble: 4 × 2\n  country year \n  &lt;chr&gt;   &lt;chr&gt;\n1 A       1999 \n2 A       2000 \n3 B       1999 \n4 B       2000 \n\n\n\n3.2.2 컬럼 분할하기\n하나의 컬럼을 두 개 이상의 컬럼으로 분할한다. 우선 간단한 예제 티블 객체를 생성한다.\n\nc_tibble &lt;- tibble(\n  country = c(\"A\", \"A\", \"B\", \"B\"),\n  year = c(\"1999\", \"2000\", \"1999\", \"2000\"),\n  rate = c(\"0.7K/19M\", \"2K/20M\", \"37K/172M\", \"80K/174M\")\n)\nc_tibble\n\n# A tibble: 4 × 3\n  country year  rate    \n  &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;   \n1 A       1999  0.7K/19M\n2 A       2000  2K/20M  \n3 B       1999  37K/172M\n4 B       2000  80K/174M\n\n\nrate 컬럼을 분할하여 새로운 두 개의 컬럼을 생성한다. 컬럼이 늘어 나는 것이므로 separate_wider_delim() 함수를 통해 수행한다.\n\nc_tibble |&gt; separate_wider_delim(\n  rate, delim = \"/\", names = c(\"cases\", \"pop\") \n)\n\n# A tibble: 4 × 4\n  country year  cases pop  \n  &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 A       1999  0.7K  19M  \n2 A       2000  2K    20M  \n3 B       1999  37K   172M \n4 B       2000  80K   174M \n\n\n유사한 기능을 하는 파생 함수에 separate_wider_position()과 separate_wider_regex() 함수도 있다.\n하나의 셀 속의 값을 분할하는 것은 위와 동일하지만, 분할된 값을 새로운 컬럼으로 옮기는 방식이 아니라 동일한 행의 새로운 열로 옮기는 방식 역시 가능한다. 행을 늘이기 때문에 separate_longer_delim() 함수를 사용한다.\n\nc_tibble |&gt; separate_longer_delim(\n  rate, delim = \"/\"\n)\n\n# A tibble: 8 × 3\n  country year  rate \n  &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;\n1 A       1999  0.7K \n2 A       1999  19M  \n3 A       2000  2K   \n4 A       2000  20M  \n5 B       1999  37K  \n6 B       1999  172M \n7 B       2000  80K  \n8 B       2000  174M \n\n\n유사한 기능을 하는 파생 함수에 separate_longer_position() 함수도 있다.\n\n3.3 결측치(NA) 처리\n해당 셀에 데이터가 존재하지 않는 경우 그것을 결측치(missing value)라 하고, R에서는 보통 NA(Not Available)이라고 한다. tidyr 패키지는 이러한 결측치를 다루기 위한 몇 가지 유용한 함수를 제공한다. 우선 간단한 예제 티블 객체를 생성한다.\n\nd_tibble &lt;- tibble(\n  x1 = c(\"A\", \"B\", \"C\", \"D\", \"E\"), \n  x2 = c(1, NA, NA, 3, 4),\n  x3 = c(NA, TRUE, FALSE, NA, FALSE)\n)\nd_tibble\n\n# A tibble: 5 × 3\n  x1       x2 x3   \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 A         1 NA   \n2 B        NA TRUE \n3 C        NA FALSE\n4 D         3 NA   \n5 E         4 FALSE\n\n\n\n3.3.1 결측치를 포함한 행 삭제하기\ndrop_na() 함수를 통해 결측치가 포함된 행을 삭제할 수 있다. 우선 어떤 컬럼에서라도 NA를 가지는 모든 행을 삭제한다.\n\nd_tibble |&gt; drop_na()\n\n# A tibble: 1 × 3\n  x1       x2 x3   \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 E         4 FALSE\n\n\n특정한 컬럼에 NA를 가지는 행만 삭제할 수 있다.\n\nd_tibble |&gt; drop_na(x2)\n\n# A tibble: 3 × 3\n  x1       x2 x3   \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 A         1 NA   \n2 D         3 NA   \n3 E         4 FALSE\n\n\n\nd_tibble |&gt; drop_na(x3)\n\n# A tibble: 3 × 3\n  x1       x2 x3   \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 B        NA TRUE \n2 C        NA FALSE\n3 E         4 FALSE\n\n\n\n3.3.2 결측치를 주변 값을 이용해 채워넣기\nfill() 함수는 위나 아래의 값을 이용해 NA를 대체하는 것이다. 방향의 “down”은 기본값으로 위의 값을 기준으로 아래 방향으로 채움이 이루어진다는 것이다.\n\nd_tibble |&gt; fill(x2, .direction = \"down\")\n\n# A tibble: 5 × 3\n  x1       x2 x3   \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 A         1 NA   \n2 B         1 TRUE \n3 C         1 FALSE\n4 D         3 NA   \n5 E         4 FALSE\n\n\n방향을 다르게 지정할 수도 있다. “up”은 아래의 값을 기준으로 위 방향으로 채움이 이루어진다는 것이다.\n\nd_tibble |&gt; fill(x2, .direction = \"up\")\n\n# A tibble: 5 × 3\n  x1       x2 x3   \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 A         1 NA   \n2 B         3 TRUE \n3 C         3 FALSE\n4 D         3 NA   \n5 E         4 FALSE\n\n\n이렇게 하면 아래에 참조할 것이 없는 다섯 번째 행의 값은 그대로 NA로 남게 된다. 이를 해소하기 위해 “updown”으로 설정할 수 있는데, 먼저 위 방향으로 채움이 이루어지고 NA가 여전히 존재하는 경우 아래 방향의 채움이 이루어진다.\n\nd_tibble |&gt; fill(x2, .direction = \"updown\")\n\n# A tibble: 5 × 3\n  x1       x2 x3   \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 A         1 NA   \n2 B         3 TRUE \n3 C         3 FALSE\n4 D         3 NA   \n5 E         4 FALSE\n\n\n\n3.3.3 결측치를 특정 값으로 채워넣기\nraplace_na() 함수를 통해 특정 값을 지정해 NA를 대체할 수 있다.\n\nd_tibble |&gt; replace_na(\n  list(x2 = 0, x3 = TRUE)\n)\n\n# A tibble: 5 × 3\n  x1       x2 x3   \n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n1 A         1 TRUE \n2 B         0 TRUE \n3 C         0 FALSE\n4 D         3 TRUE \n5 E         4 FALSE\n\n\n\n3.3.4 암묵적 결측치 처리\n암묵적(implicit) 결측치란 데이터셋에 아예 존재하지 않아 기록되지 않은 결측치를 말하는데, 행의 부재 형태로 나타난다. 예시를 위해 간단한 티블 객체를 생성한다.\n\ne_tibble &lt;- tibble(\n  x1 = c(\"A\", \"B\", \"B\"), \n  x2 = c(\"X\", \"X\", \"Y\"),\n  x3 = c(3, 4, 5)\n)\ne_tibble\n\n# A tibble: 3 × 3\n  x1    x2       x3\n  &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n1 A     X         3\n2 B     X         4\n3 B     Y         5\n\n\n여기서 x1과 x2는 범주형 변수이고, 모두 4가지(A-X, A-Y, B-X, B-Y)이 가능하다. 하지만 현재 데이터셋에는 A-Y가 존재하지 않는데, 이 때 이것을 암묵적 결측치라고 부른다. 암묵적 결측치를 명시적 결측치로 만드는 것이 필요한 상황이 있을 수 있는데, complete() 함수를 통해 암묵적 결측치를 확인할 수 있다.\n\ne_tibble |&gt; complete(x1, x2)\n\n# A tibble: 4 × 3\n  x1    x2       x3\n  &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n1 A     X         3\n2 A     Y        NA\n3 B     X         4\n4 B     Y         5\n\n\nA-Y에 대한 x3의 셀의 NA로 나타나는 것을 확인할 수 있다. 앞의 fill() 함수와 유사한 방식으로 해당 결측치를 채울수도 있다.\n\ne_tibble |&gt; complete(x1, x2, fill = list(x3 = 0))\n\n# A tibble: 4 × 3\n  x1    x2       x3\n  &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n1 A     X         3\n2 A     Y         0\n3 B     X         4\n4 B     Y         5\n\n\n암묵적 결측치의 확인이 목적이 아니라 모든 카테고리의 조합 상황을 확인하고 싶을 때는 expand() 함수를 사용한다.\n\ne_tibble |&gt; expand(x1, x2)\n\n# A tibble: 4 × 2\n  x1    x2   \n  &lt;chr&gt; &lt;chr&gt;\n1 A     X    \n2 A     Y    \n3 B     X    \n4 B     Y",
    "crumbs": [
      "R과 데이터사이언스",
      "불러오기와 정돈하기"
    ]
  },
  {
    "objectID": "exec_05.html",
    "href": "exec_05.html",
    "title": "변형하기",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 과정 중 데이터 변형하기(transformation)를 다룬다. 그림 1 에서 볼 수 있는 것처럼, 데이터 변형하기는 데이터사이언스 프로세스의 핵심적인 분석 부분의 구성요소이다.\n\n\n\n\n\n그림 1: 데이터사이언스 프로세스와 변형하기(https://r4ds.hadley.nz/transform.html)\n\n\n데이터 변형하기와 관련된 대부분의 함수는 tidyverse의 핵심 패키지 중의 하나인 dplyr 에서 제공된다. 데이터 변형하기는 크게 다음의 두 가지 범주로 나뉜다.\n\n단일 테이블 조작: 데이터 변형하기의 핵심 부분으로, 한 데이터 프레임의 데이터 구조를 조작한다.\n다중 테이블 결합: 두 개 이상의 데이터 프레임을 결합하는 방식을 다룬다.\n\n두 가지 모두 데이터 테이블이 입력되고, 데이터 테이블이 출력된다.\n우선 tidyverse 패키지를 불러온다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R과 데이터사이언스",
      "변형하기"
    ]
  },
  {
    "objectID": "exec_05.html#개요",
    "href": "exec_05.html#개요",
    "title": "변형하기",
    "section": "",
    "text": "여기서는 R로 데이터사이언스를 하는 과정 중 데이터 변형하기(transformation)를 다룬다. 그림 1 에서 볼 수 있는 것처럼, 데이터 변형하기는 데이터사이언스 프로세스의 핵심적인 분석 부분의 구성요소이다.\n\n\n\n\n\n그림 1: 데이터사이언스 프로세스와 변형하기(https://r4ds.hadley.nz/transform.html)\n\n\n데이터 변형하기와 관련된 대부분의 함수는 tidyverse의 핵심 패키지 중의 하나인 dplyr 에서 제공된다. 데이터 변형하기는 크게 다음의 두 가지 범주로 나뉜다.\n\n단일 테이블 조작: 데이터 변형하기의 핵심 부분으로, 한 데이터 프레임의 데이터 구조를 조작한다.\n다중 테이블 결합: 두 개 이상의 데이터 프레임을 결합하는 방식을 다룬다.\n\n두 가지 모두 데이터 테이블이 입력되고, 데이터 테이블이 출력된다.\n우선 tidyverse 패키지를 불러온다.\n\nlibrary(tidyverse)",
    "crumbs": [
      "R과 데이터사이언스",
      "변형하기"
    ]
  },
  {
    "objectID": "exec_05.html#단일-테이블-조작",
    "href": "exec_05.html#단일-테이블-조작",
    "title": "변형하기",
    "section": "\n1 단일 테이블 조작",
    "text": "1 단일 테이블 조작\n단일 테이블 조작과 관련된 함수는 다시 네 가지로 범주화된다.\n\n행 함수: 행(관측 개체)에 작동하는 함수, 즉 행의 변화를 야기하는 함수\n열 함수: 열(변수)에 작동하는 함수, 즉 열의 변화를 야기하는 함수\n그룹 함수: 그룹에 작동하는 함수\n데이터 프레임 함수: 데이터 프레임 전체에 작동하는 함수\n\n이번 실습에서는 행 함수, 열 함수, 그룹 함수에 집중한다. 사용할 데이터는 World Bank가 gapmider.org를 통해 무료로 배포하는 것으로 gapmider 패키지에 포함되어 있다. gapmider 패키지를 인스톨하고 불러온다. 데이터가 어떻게 구성되어 있는지 살펴본다.\n\nlibrary(gapminder)\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n1.1 행 함수\n\n1.1.1 filter() 함수\n특정 열(변수)과 관련된 조건을 만족하는 행을 선정한다. 행의 길이가 준다.\n\ngapminder |&gt; \n  filter(continent == \"Europe\")\n\n# A tibble: 360 × 6\n   country continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Albania Europe     1952    55.2 1282697     1601.\n 2 Albania Europe     1957    59.3 1476505     1942.\n 3 Albania Europe     1962    64.8 1728137     2313.\n 4 Albania Europe     1967    66.2 1984060     2760.\n 5 Albania Europe     1972    67.7 2263554     3313.\n 6 Albania Europe     1977    68.9 2509048     3533.\n 7 Albania Europe     1982    70.4 2780097     3631.\n 8 Albania Europe     1987    72   3075321     3739.\n 9 Albania Europe     1992    71.6 3326498     2497.\n10 Albania Europe     1997    73.0 3428038     3193.\n# ℹ 350 more rows\n\n\n\ngapminder |&gt; \n  filter(pop &gt; 50000000 & gdpPercap &gt; 30000)\n\n# A tibble: 9 × 6\n  country        continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;          &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 France         Europe     2007    80.7  61083916    30470.\n2 Germany        Europe     2002    78.7  82350671    30036.\n3 Germany        Europe     2007    79.4  82400996    32170.\n4 Japan          Asia       2007    82.6 127467972    31656.\n5 United Kingdom Europe     2007    79.4  60776238    33203.\n6 United States  Americas   1992    76.1 256894189    32004.\n7 United States  Americas   1997    76.8 272911760    35767.\n8 United States  Americas   2002    77.3 287675526    39097.\n9 United States  Americas   2007    78.2 301139947    42952.\n\n\n\ngapminder |&gt; \n  filter(year == 2007 & (lifeExp &gt; 82 | gdpPercap &gt; 40000))\n\n# A tibble: 7 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Hong Kong, China Asia       2007    82.2   6980412    39725.\n2 Ireland          Europe     2007    78.9   4109086    40676.\n3 Japan            Asia       2007    82.6 127467972    31656.\n4 Kuwait           Asia       2007    77.6   2505559    47307.\n5 Norway           Europe     2007    80.2   4627926    49357.\n6 Singapore        Asia       2007    80.0   4553009    47143.\n7 United States    Americas   2007    78.2 301139947    42952.\n\n\n\n1.1.2 slice() 함수\nfilter() 함수와 마찬가지로 행의 숫자를 줄인다. slice() 함수 자체 보다는 slice_head(), slice_tail(), slice_max(), slice_min()과 같은 패밀리 함수가 더 널리 사용된다. 그런데 이 함수들은 작동 방식에 따라 두 가지로 구분된다.\n\n특정 열(변수)과 관계 없이, 행의 위치에 의거해 행을 선정: slice(), slice_head(), slice_tail()\n특정 열(변수)에 따른, 행의 위치에 의거해 행을 선정: slice_max(), slice_min()\n\n몇 번째에서 몇 번째 사이의 행만을 골라낸다.\n\ngapminder |&gt; \n  slice(1:5)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n\n\n가장 앞에 위치한 몇 개(n)의 행만을 골라낸다. 실질적으로 위와 동일하다.\n\ngapminder |&gt; \n  slice_head(n = 5)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n\n\n가장 뒤에 위치한 몇 개(n)의 행만을 골라낸다.\n\ngapminder |&gt; \n  slice_tail(n = 5)\n\n# A tibble: 5 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Zimbabwe Africa     1987    62.4  9216418      706.\n2 Zimbabwe Africa     1992    60.4 10704340      693.\n3 Zimbabwe Africa     1997    46.8 11404948      792.\n4 Zimbabwe Africa     2002    40.0 11926563      672.\n5 Zimbabwe Africa     2007    43.5 12311143      470.\n\n\n특정 열(변수)에 따라 값이 가장 큰 몇 개(n)의 행만을 골라낸다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  slice_max(gdpPercap, n = 5)\n\n# A tibble: 5 × 6\n  country       continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Norway        Europe     2007    80.2   4627926    49357.\n2 Kuwait        Asia       2007    77.6   2505559    47307.\n3 Singapore     Asia       2007    80.0   4553009    47143.\n4 United States Americas   2007    78.2 301139947    42952.\n5 Ireland       Europe     2007    78.9   4109086    40676.\n\n\n특정 열(변수)에 따라 값이 가장 작은 것들 중 주어진 비중(prop) 만큼의 행만을 골라낸다.\n\ngapminder |&gt; \n  filter(year == 2007 & continent == \"Asia\") |&gt; \n  slice_min(lifeExp, prop = 0.1)\n\n# A tibble: 3 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       2007    43.8 31889923      975.\n2 Iraq        Asia       2007    59.5 27499638     4471.\n3 Cambodia    Asia       2007    59.7 14131858     1714.\n\n\n\n\n\n\n\n\n노트\n\n\n\nslice 함수는 데이터 프레임이 적용되는 것으로 모두 데이터 프레임을 산출한다. 그런데 유사한 작업을 벡터에 적용하는 함수들이 존재한다. slice_head(), slice_tail(), slice()에 대응하는 dplyr 벡터 함수로 first(), last(), nth()가 있다. 그런데 후자의 함수를 벡터가 아닌 데이터 프레임이 적용하면 slice 함수와 동일한 결과가 산출된다.\n\n\n\n1.1.3 arrange() 함수\n특정 열(변수)과 관련된 조건에 의거해 행의 순서를 바꾼다. 행의 길이에는 변화가 없다.\n\ngapminder |&gt; \n  arrange(lifeExp)\n\n# A tibble: 1,704 × 6\n   country      continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Rwanda       Africa     1992    23.6 7290203      737.\n 2 Afghanistan  Asia       1952    28.8 8425333      779.\n 3 Gambia       Africa     1952    30    284320      485.\n 4 Angola       Africa     1952    30.0 4232095     3521.\n 5 Sierra Leone Africa     1952    30.3 2143249      880.\n 6 Afghanistan  Asia       1957    30.3 9240934      821.\n 7 Cambodia     Asia       1977    31.2 6978607      525.\n 8 Mozambique   Africa     1952    31.3 6446316      469.\n 9 Sierra Leone Africa     1957    31.6 2295678     1004.\n10 Burkina Faso Africa     1952    32.0 4469979      543.\n# ℹ 1,694 more rows\n\n\ndesc() 보조 함수(helper function)는 내림차순으로 행을 배열한다.\n\ngapminder |&gt; \n  arrange(lifeExp, desc(year))\n\n# A tibble: 1,704 × 6\n   country      continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Rwanda       Africa     1992    23.6 7290203      737.\n 2 Afghanistan  Asia       1952    28.8 8425333      779.\n 3 Gambia       Africa     1952    30    284320      485.\n 4 Angola       Africa     1952    30.0 4232095     3521.\n 5 Sierra Leone Africa     1952    30.3 2143249      880.\n 6 Afghanistan  Asia       1957    30.3 9240934      821.\n 7 Cambodia     Asia       1977    31.2 6978607      525.\n 8 Mozambique   Africa     1952    31.3 6446316      469.\n 9 Sierra Leone Africa     1957    31.6 2295678     1004.\n10 Burkina Faso Africa     1952    32.0 4469979      543.\n# ℹ 1,694 more rows\n\n\n\n1.1.4 distinct() 함수\n특정 열(변수)에 의거해 중복이 없이 고유한 행만을 골라낸다. 행의 길이가 준다.\ngapminder 데이터와 관련하여 다음의 코드는 어떤 정보를 우리에게 주는지 생각해 본다.\n\ngapminder |&gt; \n  distinct(country)\n\n# A tibble: 142 × 1\n   country    \n   &lt;fct&gt;      \n 1 Afghanistan\n 2 Albania    \n 3 Algeria    \n 4 Angola     \n 5 Argentina  \n 6 Australia  \n 7 Austria    \n 8 Bahrain    \n 9 Bangladesh \n10 Belgium    \n# ℹ 132 more rows\n\n\n.keep_all 아규먼트를 이용하면 나머지 열도 함께 나타낼 수 있다. 나머지 열의 값이 무엇인지 생각해 본다.\n\ngapminder |&gt; \n  distinct(continent, .keep_all = TRUE)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Albania     Europe     1952    55.2  1282697     1601.\n3 Algeria     Africa     1952    43.1  9279525     2449.\n4 Argentina   Americas   1952    62.5 17876956     5911.\n5 Australia   Oceania    1952    69.1  8691212    10040.\n\n\n\n1.2 열 함수\n\n1.2.1 select() 함수\n열(변수)의 일부를 선택한다. 열의 길이가 준다.\n\ngapminder |&gt; \n  select(year, country, gdpPercap)\n\n# A tibble: 1,704 × 3\n    year country     gdpPercap\n   &lt;int&gt; &lt;fct&gt;           &lt;dbl&gt;\n 1  1952 Afghanistan      779.\n 2  1957 Afghanistan      821.\n 3  1962 Afghanistan      853.\n 4  1967 Afghanistan      836.\n 5  1972 Afghanistan      740.\n 6  1977 Afghanistan      786.\n 7  1982 Afghanistan      978.\n 8  1987 Afghanistan      852.\n 9  1992 Afghanistan      649.\n10  1997 Afghanistan      635.\n# ℹ 1,694 more rows\n\n\n열(변수)의 일부를 선택하지 않는다. 역시 열의 길이가 준다. 실질적으로 위와 동일한 결과가 산출된다. ! 부호 대신 - 부호를 사용할 수 있다. 전자가 선호된다.\n\ngapminder |&gt; \n  select(!c(lifeExp, continent, pop))\n\n# A tibble: 1,704 × 3\n   country      year gdpPercap\n   &lt;fct&gt;       &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan  1952      779.\n 2 Afghanistan  1957      821.\n 3 Afghanistan  1962      853.\n 4 Afghanistan  1967      836.\n 5 Afghanistan  1972      740.\n 6 Afghanistan  1977      786.\n 7 Afghanistan  1982      978.\n 8 Afghanistan  1987      852.\n 9 Afghanistan  1992      649.\n10 Afghanistan  1997      635.\n# ℹ 1,694 more rows\n\n\nstarts_with(), ends_with(), contains()와 같은 보조 함수를 잘 활용하면 효율적으로 필요한 변수만을 선정할 수 있다.\n\ngapminder |&gt; \n  select(starts_with(\"c\"))\n\n# A tibble: 1,704 × 2\n   country     continent\n   &lt;fct&gt;       &lt;fct&gt;    \n 1 Afghanistan Asia     \n 2 Afghanistan Asia     \n 3 Afghanistan Asia     \n 4 Afghanistan Asia     \n 5 Afghanistan Asia     \n 6 Afghanistan Asia     \n 7 Afghanistan Asia     \n 8 Afghanistan Asia     \n 9 Afghanistan Asia     \n10 Afghanistan Asia     \n# ℹ 1,694 more rows\n\n\n\n1.2.2 mutate() 함수\n기존의 열(변수)에 기반하여 새로운 변수를 생성한다. 열의 길이가 늘어난다.\n\ngapminder |&gt; \n  mutate(\n    gdp_billion = gdpPercap * pop / 10^9\n  )\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap gdp_billion\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.        6.57\n 2 Afghanistan Asia       1957    30.3  9240934      821.        7.59\n 3 Afghanistan Asia       1962    32.0 10267083      853.        8.76\n 4 Afghanistan Asia       1967    34.0 11537966      836.        9.65\n 5 Afghanistan Asia       1972    36.1 13079460      740.        9.68\n 6 Afghanistan Asia       1977    38.4 14880372      786.       11.7 \n 7 Afghanistan Asia       1982    39.9 12881816      978.       12.6 \n 8 Afghanistan Asia       1987    40.8 13867957      852.       11.8 \n 9 Afghanistan Asia       1992    41.7 16317921      649.       10.6 \n10 Afghanistan Asia       1997    41.8 22227415      635.       14.1 \n# ℹ 1,694 more rows\n\n\n여러개의 변수를 동시에 생성할 수 있다. row_number() 보조 함수는 값에 순위를 부여하는 것이고, .keep = \"used\"는 결과에 변수 생성에 동원된 변수만을 포함시키게 해 준다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  mutate(\n    gdpPercap_rank = row_number(gdpPercap),\n    lifeExp_highlow = lifeExp &gt; 30000,\n    .keep = \"used\"\n  )\n\n# A tibble: 142 × 4\n   lifeExp gdpPercap gdpPercap_rank lifeExp_highlow\n     &lt;dbl&gt;     &lt;dbl&gt;          &lt;int&gt; &lt;lgl&gt;          \n 1    43.8      975.             19 FALSE          \n 2    76.4     5937.             70 FALSE          \n 3    72.3     6223.             72 FALSE          \n 4    42.7     4797.             64 FALSE          \n 5    75.3    12779.            101 FALSE          \n 6    81.2    34435.            130 FALSE          \n 7    79.8    36126.            132 FALSE          \n 8    75.6    29796.            122 FALSE          \n 9    64.1     1391.             30 FALSE          \n10    79.4    33693.            128 FALSE          \n# ℹ 132 more rows\n\n\n\n\n\n\n\n\n노트\n\n\n\ndplyr 패키지는 데이터에 순위를 부여하는 여러 가지 방식을 제공하는데, row_number(), min_rank(), dense_rank(), percent_rank(), cumu_dist() 등이 있다. 자세한 사항은 맨 아래에 있는 기타 벡터 함수를 참고하면 된다.\n\n\n\n1.2.3 rename() 함수\n변수의 이름을 바꾼다. 열의 길이에는 변화가 없다. = 부호의 왼쪽에 있는 것이 새로운 변수명이다.\n\ngapminder |&gt; \n  rename(\n    gdp_percap = gdpPercap,\n    left_exp = lifeExp\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year left_exp      pop gdp_percap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;      &lt;dbl&gt;\n 1 Afghanistan Asia       1952     28.8  8425333       779.\n 2 Afghanistan Asia       1957     30.3  9240934       821.\n 3 Afghanistan Asia       1962     32.0 10267083       853.\n 4 Afghanistan Asia       1967     34.0 11537966       836.\n 5 Afghanistan Asia       1972     36.1 13079460       740.\n 6 Afghanistan Asia       1977     38.4 14880372       786.\n 7 Afghanistan Asia       1982     39.9 12881816       978.\n 8 Afghanistan Asia       1987     40.8 13867957       852.\n 9 Afghanistan Asia       1992     41.7 16317921       649.\n10 Afghanistan Asia       1997     41.8 22227415       635.\n# ℹ 1,694 more rows\n\n\n패밀리 함수인 rename_with()를 이용하면 다른 것도 가능하다. tolower은 변수명을 소문자로 바꾸는 보조 함수이고, toupper은 대문자로 바꾸는 보조 함수이다.\n\ngapminder |&gt; \n  rename_with(\n    tolower, starts_with(\"l\")\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeexp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n1.2.4 relocate() 함수\n변수의 위치를 바꾼다. 열의 길이에는 변화가 없다. 기입한 변수들이 맨 앞으로 이동한다.\n\ngapminder |&gt; \n  relocate(year, continent)\n\n# A tibble: 1,704 × 6\n    year continent country     lifeExp      pop gdpPercap\n   &lt;int&gt; &lt;fct&gt;     &lt;fct&gt;         &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1  1952 Asia      Afghanistan    28.8  8425333      779.\n 2  1957 Asia      Afghanistan    30.3  9240934      821.\n 3  1962 Asia      Afghanistan    32.0 10267083      853.\n 4  1967 Asia      Afghanistan    34.0 11537966      836.\n 5  1972 Asia      Afghanistan    36.1 13079460      740.\n 6  1977 Asia      Afghanistan    38.4 14880372      786.\n 7  1982 Asia      Afghanistan    39.9 12881816      978.\n 8  1987 Asia      Afghanistan    40.8 13867957      852.\n 9  1992 Asia      Afghanistan    41.7 16317921      649.\n10  1997 Asia      Afghanistan    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n.before나 .after 아규먼트를 사용하여 해당 변수를 어떤 변수의 앞이나 뒤로 보낼 수 있다.\n\ngapminder |&gt; \n  relocate(pop, .before = lifeExp )\n\n# A tibble: 1,704 × 6\n   country     continent  year      pop lifeExp gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;    &lt;int&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952  8425333    28.8      779.\n 2 Afghanistan Asia       1957  9240934    30.3      821.\n 3 Afghanistan Asia       1962 10267083    32.0      853.\n 4 Afghanistan Asia       1967 11537966    34.0      836.\n 5 Afghanistan Asia       1972 13079460    36.1      740.\n 6 Afghanistan Asia       1977 14880372    38.4      786.\n 7 Afghanistan Asia       1982 12881816    39.9      978.\n 8 Afghanistan Asia       1987 13867957    40.8      852.\n 9 Afghanistan Asia       1992 16317921    41.7      649.\n10 Afghanistan Asia       1997 22227415    41.8      635.\n# ℹ 1,694 more rows\n\n\n\n1.2.5 pull() 함수\n데이터 프레임의 한 컬럼을 벡터로 추출한다.\n\ngapminder |&gt; pull(lifeExp) |&gt; mean()\n\n[1] 59.47444\n\n\n\n\n\n\n\n\n노트\n\n\n\nBase R이 벡터 기반 연산에 강점이 있는 반면 tidyverse는 데이터 프레임별 연산에 강점이 있다. 이렇다 보니 Base R의 많은 벡터 기반 함수를 tidyverse에서 사용할 때 불편함을 느낄 수 있다. 이러한 문제점을 경감해 줄 수 있는 것이 pull() 함수이다. 예를 들어 위의 코드를 Base R에서 쓰면 다음과 같다.\n\nmean(gapminder$lifeExp)\n\n동일한 것을 정규 tidyverse문법에 맞추어 쓰면 다음과 같다.\n\ngapminder |&gt; \n  summarize(\n    mean_lifeExp = mean(lifeExp)\n  )\n\n좀 성가시게 길어지는 측면이 있다. 이 때 pull() 함수는 유용하게 사용될 수 있고, tidyverse문법을 지키면서도 코드를 좀 더 간명하게 표현할 수 있다.\n\n\n\n1.3 그룹 함수\n\n1.3.1 group_by() 함수\n특정 범주 열(변수)에 의거해 행을 분할한다. 행의 길이는 변하지 않는다.\n우선 하나의 범주 변수에 의거해 그룹화한다. 산출물을 보면 year에 의거해 행이 12개의 그룹으로 나누어졌음을 알 수 있다(두 번째 줄: Group: year [12]).\n\ngapminder |&gt; \n  group_by(year)\n\n# A tibble: 1,704 × 6\n# Groups:   year [12]\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n두 개 이상의 범주 변수에 의거해 그룹화할 수도 있다.\n\ngapminder |&gt; \n  group_by(year, continent)\n\n# A tibble: 1,704 × 6\n# Groups:   year, continent [60]\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n1.3.2 summarize() 함수\n주어진 열(변수)에 대한 통계 요약값을 계산하고 그것으로 이루어진 새로운 데이터 프레임을 생성한다. 엄밀히 말해 기존 열(변수)을 변형한다기 보다는 기존 데이터 프레임으로부터 새로운 데이터 프레임을 생성한다고 볼 수 있다. summarize() 함수는 대부분의 경우 group_by() 함수와 함께 사용된다. 다음의 둘을 비교해 보라.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  summarize(\n    mean_gdpPercap = mean(gdpPercap)\n  )\n\n# A tibble: 1 × 1\n  mean_gdpPercap\n           &lt;dbl&gt;\n1         11680.\n\n\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  group_by(continent) |&gt; \n  summarize(\n    mean_gdpPercap = mean(gdpPercap)\n  )\n\n# A tibble: 5 × 2\n  continent mean_gdpPercap\n  &lt;fct&gt;              &lt;dbl&gt;\n1 Africa             3089.\n2 Americas          11003.\n3 Asia              12473.\n4 Europe            25054.\n5 Oceania           29810.\n\n\n좀 더 복잡한 확장이 가능하다. 마지막의 n()은 특별한 요약 함수로, 어떤 아규먼트도 없이 단독으로 사용되며 “현재(current)” 그룹의 빈도값을 산출한다.\n\ngapminder |&gt; \n    group_by(continent, year) |&gt; \n    summarize(\n      mean_gdpPercap = mean(gdpPercap),\n      sd_gdpPercap = sd(gdpPercap),\n      mean_pop = mean(pop),\n      sd_pop = sd(pop),\n      n = n()\n    )\n\n# A tibble: 60 × 7\n# Groups:   continent [5]\n   continent  year mean_gdpPercap sd_gdpPercap  mean_pop    sd_pop     n\n   &lt;fct&gt;     &lt;int&gt;          &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;\n 1 Africa     1952          1253.         983.  4570010.  6317450.    52\n 2 Africa     1957          1385.        1135.  5093033.  7076042.    52\n 3 Africa     1962          1598.        1462.  5702247.  7957545.    52\n 4 Africa     1967          2050.        2848.  6447875.  8985505.    52\n 5 Africa     1972          2340.        3287.  7305376. 10130833.    52\n 6 Africa     1977          2586.        4142.  8328097. 11585184.    52\n 7 Africa     1982          2482.        3243.  9602857. 13456243.    52\n 8 Africa     1987          2283.        2567. 11054502. 15277484.    52\n 9 Africa     1992          2282.        2644. 12674645. 17562719.    52\n10 Africa     1997          2379.        2821. 14304480. 19873013.    52\n# ℹ 50 more rows\n\n\ngroup_by()와 arrange()를 결합하는 경우, .by_group = TRUE를 하면 그룹별로 행을 배열할 수 있다(그렇지 않으면 그룹 설정을 무시한 채 행을 배열한다.)\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  arrange(desc(gdpPercap), .by_group = TRUE)\n\n# A tibble: 1,704 × 6\n# Groups:   year, continent [60]\n   country      continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 South Africa Africa     1952    45.0 14264935     4725.\n 2 Gabon        Africa     1952    37.0   420702     4293.\n 3 Angola       Africa     1952    30.0  4232095     3521.\n 4 Reunion      Africa     1952    52.7   257700     2719.\n 5 Djibouti     Africa     1952    34.8    63149     2670.\n 6 Algeria      Africa     1952    43.1  9279525     2449.\n 7 Namibia      Africa     1952    41.7   485831     2424.\n 8 Libya        Africa     1952    42.7  1019729     2388.\n 9 Congo, Rep.  Africa     1952    42.1   854885     2126.\n10 Mauritius    Africa     1952    51.0   516556     1968.\n# ℹ 1,694 more rows\n\n\n아래는 연도별/대륙별로 일인당 GDP가 가장 높은 국가를 추출한 것이다. 코드를 생각해 보라.\n\n\n# A tibble: 60 × 6\n# Groups:   year, continent [60]\n   country       continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 South Africa  Africa     1952    45.0  14264935     4725.\n 2 United States Americas   1952    68.4 157553000    13990.\n 3 Kuwait        Asia       1952    55.6    160000   108382.\n 4 Switzerland   Europe     1952    69.6   4815000    14734.\n 5 New Zealand   Oceania    1952    69.4   1994794    10557.\n 6 South Africa  Africa     1957    48.0  16151549     5487.\n 7 United States Americas   1957    69.5 171984000    14847.\n 8 Kuwait        Asia       1957    58.0    212846   113523.\n 9 Switzerland   Europe     1957    70.6   5126000    17909.\n10 New Zealand   Oceania    1957    70.3   2229407    12247.\n# ℹ 50 more rows\n\n\ngroup_by() 함수가 한 번 적용되면, 그 뒤의 모든 오퍼레이션에 그룹 분할이 적용되기 때문에 예기치 못한 일이 발생할 수 있다. 이것을 회피하기 위해 두 가지 옵션이 있다. 첫번째 방법은 마지막에 upgroup() 함수를 첨가하는 것이다. 아래에 위 질문에 대한 정답이 나타나 있다.\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  slice_max(gdpPercap) |&gt; \n  ungroup()\n\n# A tibble: 60 × 6\n   country       continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 South Africa  Africa     1952    45.0  14264935     4725.\n 2 United States Americas   1952    68.4 157553000    13990.\n 3 Kuwait        Asia       1952    55.6    160000   108382.\n 4 Switzerland   Europe     1952    69.6   4815000    14734.\n 5 New Zealand   Oceania    1952    69.4   1994794    10557.\n 6 South Africa  Africa     1957    48.0  16151549     5487.\n 7 United States Americas   1957    69.5 171984000    14847.\n 8 Kuwait        Asia       1957    58.0    212846   113523.\n 9 Switzerland   Europe     1957    70.6   5126000    17909.\n10 New Zealand   Oceania    1957    70.3   2229407    12247.\n# ℹ 50 more rows\n\n\n두 번째 방법은 group_by() 함수 대신 by 아규먼트를 사용하는 것이다. 결과가 달라보이겠지만 정렬의 차이일 뿐 동일하다.\n\ngapminder |&gt; \n  slice_max(\n    gdpPercap, \n    by = c(year, continent)\n  )\n\n# A tibble: 60 × 6\n   country      continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Kuwait       Asia       1952    55.6   160000   108382.\n 2 Kuwait       Asia       1957    58.0   212846   113523.\n 3 Kuwait       Asia       1962    60.5   358266    95458.\n 4 Kuwait       Asia       1967    64.6   575003    80895.\n 5 Kuwait       Asia       1972    67.7   841934   109348.\n 6 Kuwait       Asia       1977    69.3  1140357    59265.\n 7 Saudi Arabia Asia       1982    63.0 11254672    33693.\n 8 Kuwait       Asia       1987    74.2  1891487    28118.\n 9 Kuwait       Asia       1992    75.2  1418095    34933.\n10 Kuwait       Asia       1997    76.2  1765345    40301.\n# ℹ 50 more rows\n\n\n\n1.3.3 count() 함수\n특정 범주 열(변수)에 의거한 빈도를 빠르게 계산해 준다. 빈도는 자동적으로 n이라는 이럼의 컬럼에 저장된다.\n\ngapminder |&gt; \n  count(year, continent)\n\n# A tibble: 60 × 3\n    year continent     n\n   &lt;int&gt; &lt;fct&gt;     &lt;int&gt;\n 1  1952 Africa       52\n 2  1952 Americas     25\n 3  1952 Asia         33\n 4  1952 Europe       30\n 5  1952 Oceania       2\n 6  1957 Africa       52\n 7  1957 Americas     25\n 8  1957 Asia         33\n 9  1957 Europe       30\n10  1957 Oceania       2\n# ℹ 50 more rows\n\n\nwt 아규먼트를 사용하면 빈도가 아니라 범주별 특정 변수의 합산값을 구할 수 있다.\n\ngapminder |&gt; \n  count(year, continent, wt = pop)\n\n# A tibble: 60 × 3\n    year continent          n\n   &lt;int&gt; &lt;fct&gt;          &lt;dbl&gt;\n 1  1952 Africa     237640501\n 2  1952 Americas   345152446\n 3  1952 Asia      1395357351\n 4  1952 Europe     418120846\n 5  1952 Oceania     10686006\n 6  1957 Africa     264837738\n 7  1957 Americas   386953916\n 8  1957 Asia      1562780599\n 9  1957 Europe     437890351\n10  1957 Oceania     11941976\n# ℹ 50 more rows\n\n\n위의 두 개는 사실 아래와 동일하다.\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  summarize(\n    n = n(),\n    sum_pop = sum(pop)\n  )\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent     n    sum_pop\n   &lt;int&gt; &lt;fct&gt;     &lt;int&gt;      &lt;dbl&gt;\n 1  1952 Africa       52  237640501\n 2  1952 Americas     25  345152446\n 3  1952 Asia         33 1395357351\n 4  1952 Europe       30  418120846\n 5  1952 Oceania       2   10686006\n 6  1957 Africa       52  264837738\n 7  1957 Americas     25  386953916\n 8  1957 Asia         33 1562780599\n 9  1957 Europe       30  437890351\n10  1957 Oceania       2   11941976\n# ℹ 50 more rows\n\n\n\n1.3.4 across() 함수\n다수의 열(변수)에 동일한 함수를 적용할 수 있다.\n\ngapminder |&gt; \n  mutate(\n    across(c(lifeExp, gdpPercap), round)\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952      29  8425333       779\n 2 Afghanistan Asia       1957      30  9240934       821\n 3 Afghanistan Asia       1962      32 10267083       853\n 4 Afghanistan Asia       1967      34 11537966       836\n 5 Afghanistan Asia       1972      36 13079460       740\n 6 Afghanistan Asia       1977      38 14880372       786\n 7 Afghanistan Asia       1982      40 12881816       978\n 8 Afghanistan Asia       1987      41 13867957       852\n 9 Afghanistan Asia       1992      42 16317921       649\n10 Afghanistan Asia       1997      42 22227415       635\n# ℹ 1,694 more rows\n\n\n이것은 다음과 동일하다.\n\ngapminder |&gt; \n  mutate(\n    lifeExp = round(lifeExp),\n    gdpPercap = round(gdpPercap)\n  )\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952      29  8425333       779\n 2 Afghanistan Asia       1957      30  9240934       821\n 3 Afghanistan Asia       1962      32 10267083       853\n 4 Afghanistan Asia       1967      34 11537966       836\n 5 Afghanistan Asia       1972      36 13079460       740\n 6 Afghanistan Asia       1977      38 14880372       786\n 7 Afghanistan Asia       1982      40 12881816       978\n 8 Afghanistan Asia       1987      41 13867957       852\n 9 Afghanistan Asia       1992      42 16317921       649\n10 Afghanistan Asia       1997      42 22227415       635\n# ℹ 1,694 more rows\n\n\nsummarize() 함수와 결합하여 선택된 변수에 특정 함수를 적용하고 그 결과의 이름을 변수명과 함수명을 사용하여 부여할 수 있다.\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  summarize(\n    across(\n      c(lifeExp, gdpPercap), \n      mean, \n      .names = \"mean_{.col}\"\n    )\n  )\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent mean_lifeExp mean_gdpPercap\n   &lt;int&gt; &lt;fct&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n 1  1952 Africa            39.1          1253.\n 2  1952 Americas          53.3          4079.\n 3  1952 Asia              46.3          5195.\n 4  1952 Europe            64.4          5661.\n 5  1952 Oceania           69.3         10298.\n 6  1957 Africa            41.3          1385.\n 7  1957 Americas          56.0          4616.\n 8  1957 Asia              49.3          5788.\n 9  1957 Europe            66.7          6963.\n10  1957 Oceania           70.3         11599.\n# ℹ 50 more rows\n\n\nacross() 함수에서 중요한 것은 함수 아규먼트에 함수명 그 자체만 쓸 수 있을 뿐(즉, mean), 함수명 뒤에 ()가 붙을 수 없다. 예를 들어 mean() 함수의 매우 중요한 아규먼트인 na.rm을 사용할 수 없다. 위의 예에서 두 변수 중 어느 변수에라도 결측값이 포함되어 있었다면 에러가 발생했을 것이다. 이 문제는 다음과 같은 방식으로 해결할 수 있다.\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  summarize(\n    across(\n      c(lifeExp, gdpPercap), \n      function(x) median(x, na.rm = TRUE)\n    )\n  )\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent lifeExp gdpPercap\n   &lt;int&gt; &lt;fct&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n 1  1952 Africa       38.8      987.\n 2  1952 Americas     54.7     3048.\n 3  1952 Asia         44.9     1207.\n 4  1952 Europe       65.9     5142.\n 5  1952 Oceania      69.3    10298.\n 6  1957 Africa       40.6     1024.\n 7  1957 Americas     56.1     3781.\n 8  1957 Asia         48.3     1548.\n 9  1957 Europe       67.6     6067.\n10  1957 Oceania      70.3    11599.\n# ℹ 50 more rows\n\n\n혹은 보다 간단하게 function()을 \\()로 대체할 수도 있다.\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  summarize(\n    across(\n      c(lifeExp, gdpPercap), \n      \\(x) median(x, na.rm = TRUE)\n    )\n  )\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent lifeExp gdpPercap\n   &lt;int&gt; &lt;fct&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n 1  1952 Africa       38.8      987.\n 2  1952 Americas     54.7     3048.\n 3  1952 Asia         44.9     1207.\n 4  1952 Europe       65.9     5142.\n 5  1952 Oceania      69.3    10298.\n 6  1957 Africa       40.6     1024.\n 7  1957 Americas     56.1     3781.\n 8  1957 Asia         48.3     1548.\n 9  1957 Europe       67.6     6067.\n10  1957 Oceania      70.3    11599.\n# ℹ 50 more rows\n\n\n만일 across() 함수 속에서 두 개 이상의 함수를 적용한다면 list()를 활용해야 한다. 결과에 새로 생성된 변수명이 원변수명_함수명({.col}_{.fn})의 형태를 띠고 있음에 주목하라. 사실 이것은 across() 함수 속에 .names = \"{.col}_{.fn}\"라고 지정한 것과 동일한 것으로, 만일 .names = \"{.fn}_{.col}\" 이라고 지정하면 다른 결과가 나타날 것이다.\n\ngapminder |&gt; \n  group_by(year, continent) |&gt; \n  summarize(\n    across(\n      c(lifeExp, gdpPercap), \n      list(\n        mean = \\(x) mean(x, na.rm = TRUE),\n        median = \\(x) median(x, na.rm = TRUE)\n      )\n    )\n  )\n\n# A tibble: 60 × 6\n# Groups:   year [12]\n    year continent lifeExp_mean lifeExp_median gdpPercap_mean gdpPercap_median\n   &lt;int&gt; &lt;fct&gt;            &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;            &lt;dbl&gt;\n 1  1952 Africa            39.1           38.8          1253.             987.\n 2  1952 Americas          53.3           54.7          4079.            3048.\n 3  1952 Asia              46.3           44.9          5195.            1207.\n 4  1952 Europe            64.4           65.9          5661.            5142.\n 5  1952 Oceania           69.3           69.3         10298.           10298.\n 6  1957 Africa            41.3           40.6          1385.            1024.\n 7  1957 Americas          56.0           56.1          4616.            3781.\n 8  1957 Asia              49.3           48.3          5788.            1548.\n 9  1957 Europe            66.7           67.6          6963.            6067.\n10  1957 Oceania           70.3           70.3         11599.           11599.\n# ℹ 50 more rows\n\n\nacross() 함수의 파생 함수로 if_any()와 if_all()이 있다. 두 함수 모두 매우 유용하지만 여기서는 다루지 않는다.\n\n1.3.5 c_across() 함수\ngroup_by() 함수와 across() 함수가 결합하는 것과 정반대로, rowwise() 함수와 c_across() 함수를 결합하며, 행별 통계값을 산출할 수 있다. 물론 여기서 each_sd 값은 아무런 의미가 없다. 행별로 수치형 변수(year, lifeExp, pop, gdpPercap)의 표준편차를 구한 것이다.\n\ngapminder |&gt; \n  rowwise() |&gt; \n  mutate(\n    each_sd = sd(c_across(where(is.numeric)))\n  )\n\n# A tibble: 1,704 × 7\n# Rowwise: \n   country     continent  year lifeExp      pop gdpPercap   each_sd\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  4212207.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  4619999.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  5133067.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  5768510.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  6539272.\n 6 Afghanistan Asia       1977    38.4 14880372      786.  7439719.\n 7 Afghanistan Asia       1982    39.9 12881816      978.  6440408.\n 8 Afghanistan Asia       1987    40.8 13867957      852.  6933499.\n 9 Afghanistan Asia       1992    41.7 16317921      649.  8158513.\n10 Afghanistan Asia       1997    41.8 22227415      635. 11113262.\n# ℹ 1,694 more rows",
    "crumbs": [
      "R과 데이터사이언스",
      "변형하기"
    ]
  },
  {
    "objectID": "exec_05.html#다중-테이블-결합",
    "href": "exec_05.html#다중-테이블-결합",
    "title": "변형하기",
    "section": "\n2 다중 테이블 결합",
    "text": "2 다중 테이블 결합\n\n2.1 테이블 조인\n테이블 조인(join)은 두 개 데이터 프레임을 공통키(common key)를 이용해 결합함으로써 하나의 데이터 프레임을 생성하는 것을 의미한다. 서로 상이한 방식의 조인이 가능하면, dplyr 패키지는 다양한 종류의 조인 함수를 제공한다.\n\nleft_join(): 첫 번째 테이블은 그대로 둔 상태에서 두 번째 테이블을 결합함으로써 두 번째 변수의 열을 가져옴\nright_join(): 두 번째 테이블은 그대로 둔 상태에서 첫 번째 테이블을 결합함으로써 첫 번째 테이블의 열을 가져옴\ninner_join(): 두 테이블 모두에 존재하는 열을 취함\nfull_join(): 최소한 한 테이블에 존재하는 열을 모두 취함\nsemi_join(): 첫 번째 테이블의 행 중 두 번째 테이블에 대응하는 행이 있는 것만 취함\nanti_join(): 첫 번째 테이블의 행 중 두 번째 테이블에 대응하는 행이 없는 것만 취함\n\n이들 중 left_join()이 가장 많이 사용되기 때문에 그것에 집중한다.\n\n2.1.1 left_join() 함수\n실습을 위해 nycflights13 패키지의 데이터를 사용한다. 이 패키지에는 다섯 개의 데이터 프레임이 포함되어 있다. 지난 번에는 첫 번째 데이터만 사용했다.\n\nflights: 2013년 NYC를 출발한 모든 항공기\nweather: 공항별 시간별 기상 상황\nplanes: 항공기별 건조 정보\nairports: 공항명과 위치\nairlines: 항공사\n\n그리고 이 6개의 데이터 프레임은 그림 2 처럼 공통키(common key)를 통해 서로 연결되어 있다.\n\n\n\n\n\n그림 2: nycflights13 데이터(https://github.com/tidyverse/nycflights13)\n\n\nflights 데이터의 변수가 너무 많기 때문에 조인을 위한 공통키를 중심으로 변수를 줄인다.\n\nlibrary(nycflights13)\n\n\nflights2 &lt;- flights |&gt; \n  select(year, time_hour, origin, dest, tailnum, carrier)\nflights2\n\n# A tibble: 336,776 × 6\n    year time_hour           origin dest  tailnum carrier\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  \n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     \n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     \n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     \n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     \n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     \n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6     \n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV     \n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6     \n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA     \n# ℹ 336,766 more rows\n\n\nflights2 데이터를 중심으로 나머지 4개의 데이터와 조인한다.\n\nairlines\n\n# A tibble: 16 × 2\n   carrier name                       \n   &lt;chr&gt;   &lt;chr&gt;                      \n 1 9E      Endeavor Air Inc.          \n 2 AA      American Airlines Inc.     \n 3 AS      Alaska Airlines Inc.       \n 4 B6      JetBlue Airways            \n 5 DL      Delta Air Lines Inc.       \n 6 EV      ExpressJet Airlines Inc.   \n 7 F9      Frontier Airlines Inc.     \n 8 FL      AirTran Airways Corporation\n 9 HA      Hawaiian Airlines Inc.     \n10 MQ      Envoy Air                  \n11 OO      SkyWest Airlines Inc.      \n12 UA      United Air Lines Inc.      \n13 US      US Airways Inc.            \n14 VX      Virgin America             \n15 WN      Southwest Airlines Co.     \n16 YV      Mesa Airlines Inc.         \n\nflights2 |&gt;\n  left_join(airlines)\n\n# A tibble: 336,776 × 7\n    year time_hour           origin dest  tailnum carrier name                  \n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;                 \n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines Inc. \n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines Inc. \n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines Inc.\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways       \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.  \n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines Inc. \n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      JetBlue Airways       \n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      ExpressJet Airlines I…\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      JetBlue Airways       \n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      American Airlines Inc.\n# ℹ 336,766 more rows\n\n\n\nweather\n\n# A tibble: 26,115 × 15\n   origin  year month   day  hour  temp  dewp humid wind_dir wind_speed\n   &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;\n 1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4 \n 2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06\n 3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5 \n 4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7 \n 5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7 \n 6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5 \n 7 EWR     2013     1     1     7  39.0  28.0  64.4      240      15.0 \n 8 EWR     2013     1     1     8  39.9  28.0  62.2      250      10.4 \n 9 EWR     2013     1     1     9  39.9  28.0  62.2      260      15.0 \n10 EWR     2013     1     1    10  41    28.0  59.6      260      13.8 \n# ℹ 26,105 more rows\n# ℹ 5 more variables: wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;,\n#   visib &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\nflights2 |&gt; \n  left_join(weather |&gt; select(origin, time_hour, temp, wind_speed))\n\n# A tibble: 336,776 × 8\n    year time_hour           origin dest  tailnum carrier  temp wind_speed\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;      &lt;dbl&gt;\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA       39.0       12.7\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA       39.9       15.0\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA       39.0       15.0\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6       39.0       15.0\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL       39.9       16.1\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA       39.0       12.7\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6       37.9       11.5\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV       39.9       16.1\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6       37.9       13.8\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA       39.9       16.1\n# ℹ 336,766 more rows\n\n\n\nplanes\n\n# A tibble: 3,322 × 9\n   tailnum  year type              manufacturer model engines seats speed engine\n   &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; \n 1 N10156   2004 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 2 N102UW   1998 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 3 N103US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 4 N104UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 5 N10575   2002 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…\n 6 N105UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 7 N107US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 8 N108UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n 9 N109UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n10 N110UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…\n# ℹ 3,312 more rows\n\nflights2 |&gt; \n  left_join(planes |&gt; select(tailnum, type, engines, seats))\n\n# A tibble: 336,776 × 9\n    year time_hour           origin dest  tailnum carrier type     engines seats\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;int&gt; &lt;int&gt;\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Fixed w…       2   149\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      Fixed w…       2   149\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Fixed w…       2   178\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      Fixed w…       2   200\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Fixed w…       2   178\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Fixed w…       2   191\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Fixed w…       2   200\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      Fixed w…       2    55\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      Fixed w…       2   200\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;          NA    NA\n# ℹ 336,766 more rows\n\n\n\nairports\n\n# A tibble: 1,458 × 8\n   faa   name                             lat    lon   alt    tz dst   tzone    \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n 1 04G   Lansdowne Airport               41.1  -80.6  1044    -5 A     America/…\n 2 06A   Moton Field Municipal Airport   32.5  -85.7   264    -6 A     America/…\n 3 06C   Schaumburg Regional             42.0  -88.1   801    -6 A     America/…\n 4 06N   Randall Airport                 41.4  -74.4   523    -5 A     America/…\n 5 09J   Jekyll Island Airport           31.1  -81.4    11    -5 A     America/…\n 6 0A9   Elizabethton Municipal Airport  36.4  -82.2  1593    -5 A     America/…\n 7 0G6   Williams County Airport         41.5  -84.5   730    -5 A     America/…\n 8 0G7   Finger Lakes Regional Airport   42.9  -76.8   492    -5 A     America/…\n 9 0P2   Shoestring Aviation Airfield    39.8  -76.6  1000    -5 U     America/…\n10 0S9   Jefferson County Intl           48.1 -123.    108    -8 A     America/…\n# ℹ 1,448 more rows\n\nflights2 |&gt; \n  left_join(airports, join_by(origin == faa))\n\n# A tibble: 336,776 × 13\n    year time_hour           origin dest  tailnum carrier name         lat   lon\n   &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Newark Li…  40.7 -74.2\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      La Guardia  40.8 -73.9\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      John F Ke…  40.6 -73.8\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      John F Ke…  40.6 -73.8\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      La Guardia  40.8 -73.9\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Newark Li…  40.7 -74.2\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Newark Li…  40.7 -74.2\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      La Guardia  40.8 -73.9\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      John F Ke…  40.6 -73.8\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      La Guardia  40.8 -73.9\n# ℹ 336,766 more rows\n# ℹ 4 more variables: alt &lt;dbl&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, tzone &lt;chr&gt;\n\n\nairports의 경우만 왜 join_by()라는 아규먼트가 사용되었는데, 이 경우에는 공통키의 이름이 동일하지 않기 때문이다. 즉, flights2 데이터의 origin 컬럼과 airports 데이터의 faa가 공통키임을 지정해 주어야 하는 것이다.\n\n2.2 테이블 병합\n테이블 병합(merge)은 두 데이터 프레임을 결합해 새로운 단일한 데이터 프레임을 생성한다는 의미에서는 테이블 조인과 동일하지만, 공통키가 없으며, 행과 열 중 하나는 만드시 동일해야 한다. 가장 널리 사용되는 함수에 bind_row() 함수와 bind_col() 함수가 있다. 전자는 컬럼이 동일한 두 테이블을 상하로 연결하는 것이고, 후자는 행이 동일한 두 테이블을 좌우로 연결하는 것이다.\n\n2.2.1 bind_row() 와 bind_col() 함수\ngapminder 데이터를 25년 간격으로 세 개의 연도(1957, 1982, 2007년)로 분할한다.\n\ngap_1957 &lt;- gapminder |&gt; filter(year == 1957)\ngap_1982 &lt;- gapminder |&gt; filter(year == 1982)\ngap_2007 &lt;- gapminder |&gt; filter(year == 2007)\n\n이 세개의 데이터 프레임은 동일한 열 구조(동일한 변수)를 가지고 있지만, 행이 다르다. 이런 경우 bind_row() 함수를 사용하여 하나의 데이터 프레임으로 결합할 수 있다.\n\ngapminder_merge_row &lt;- bind_rows(\n  gap_1957, gap_1982, gap_2007\n)\ngapminder_merge_row\n\n# A tibble: 426 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1957    30.3  9240934      821.\n 2 Albania     Europe     1957    59.3  1476505     1942.\n 3 Algeria     Africa     1957    45.7 10270856     3014.\n 4 Angola      Africa     1957    32.0  4561361     3828.\n 5 Argentina   Americas   1957    64.4 19610538     6857.\n 6 Australia   Oceania    1957    70.3  9712569    10950.\n 7 Austria     Europe     1957    67.5  6965860     8843.\n 8 Bahrain     Asia       1957    53.8   138655    11636.\n 9 Bangladesh  Asia       1957    39.3 51365468      662.\n10 Belgium     Europe     1957    69.2  8989111     9715.\n# ℹ 416 more rows\n\n\n이제 gapminder 데이터 프레임을 변수 세 개씩 묶어 두 개의 데이터 프레임으로 분할한다.\n\ngap_var1 &lt;- gapminder |&gt; select(country, continent, year)\ngap_var2 &lt;- gapminder |&gt; select(lifeExp, pop, gdpPercap)\n\n이 두개의 데이터 프레임은 동일한 행 구조(동일한 관측 개체)를 가지고 있지만, 열이 다르다. 이런 경우 bind_col() 함수를 사용하여 하나의 데이터 프레임으로 결합할 수 있다.\n\ngapminder_merge_col &lt;- bind_cols(gap_var1, gap_var2)\ngapminder_merge_col\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n2.2.2 기타 집합 연산 함수\n집합 연산(set operation) 함수란 두 데이터 프레임을 수학적 집합 연산(합집합, 교집합, 차집합, 동등성 검사)을 적용하여 새로운 데이터 프레임을 산출하는 함수를 말한다. 두 데이터 프레임은 동일한 열 구조를 가져야 하며, 행 전체를 하나의 원소로 취급한다. 여기에 해당하는 함수로, intersect(), union(), setdiff() 함수 등이 있다.",
    "crumbs": [
      "R과 데이터사이언스",
      "변형하기"
    ]
  },
  {
    "objectID": "exec_05.html#기타-벡터-함수",
    "href": "exec_05.html#기타-벡터-함수",
    "title": "변형하기",
    "section": "\n3 기타 벡터 함수",
    "text": "3 기타 벡터 함수\n타이디버스 함수의 기본 작동 방식은 데이터 프레임을 입력으로 받아 데이터 프레임을 출력하는 것이다. 이에 반해 Base R은 기본적으로 벡터에 대한 연산에 기반하고 있다. 타이디버스의 이러한 측면은 주로 장점으로 작용한다고 볼 수 있지만, 단점으로 작용하는 경우도 적지 않다. 이를 극복하기 위해 dplyr 패키지는 몇 가지 유용한 벡터 함수를 제공하고 있다. 이러한 함수는 주로 단일 테이블 조작 함수의 내부에서 작동한다.\n\n\n\n\n\n\n\n범주\n함수\n설명\n\n\n\n값 추출\nfirst()\n첫 번째 값\n\n\n\nlast()\n마지막 값\n\n\n\nnth()\nn-번째 값\n\n\n값 변경\nif_else()\n단일 벡터에 대해, 이진 조건식을 통해 재코드화\n\n\n\ncase_match()\n단일 벡터에 대해, 조건식을 통해 재코드화\n\n\n\ncase_when()\n다중 벡터에 대해, 조건식을 통해 재코드화\n\n\n순위 부여\nrow_number()\n일련번호 부여\n\n\n\nmin_rank()\n동일값에 동순위를 부여하고, 그 다음 값에는 동순위 갯수를 감안한 그 다음 순위를 부여\n\n\n\ndense_rank()\n동일값에 동순위를 부여하고, 그 다음 값에는 동순위 갯수에 상관없이 바로 그 다음 순위를 부여\n\n\n\npercent_rank()\n백분위수(percentile)을 계산해 주는데, 해당 값보다 작은 값의 개수를 전체 개수에서 1을 뺀 값으로 나눈값을 산출\n\n\n\ncume_dist()\n백분위수(percentile)을 계산해 주는데, 해당 값보다 작거나 같은 값의 개수를 전체 개수로 나눈값을 산출\n\n\n\nntile()\n값의 크기에 따라 몇 개의 그룹으로 나누고, 그룹 순위를 부여\n\n\n\nconsecutive_id()\n동일한 값에는 동일한 일련번호를, 새로운 값이 나타날 때에는 그 다음 일련번호를 부여\n\n\n값 순서 변경\ndesc()\n내림차순으로 정렬\n\n\n\nlag()\n뒤로 밀어 이전 값을 가져옴. 첫번째 값이 NA\n\n\n\nlead()\n앞으로 당겨서 이후 값을 가져옴. 마지막 값이 NA\n\n\n결측치 처리\ncoalesce()\nNA에 특정한 값을 부여\n\n\n\nna_if()\n특정한 값에 NA를 부여\n\n\n논리형 벡터 생성\nbetween()\n특정한 값이 두 값 사이에 존재하는 지의 여부 검토\n\n\n\nnear()\n두 값이 충분히 가까운지의 여부 검토\n\n\n\n\n3.1 값 추출 함수\nfirst() 함수는 해당 벡터의 첫 번째 셀 값을 반환한다. last() 함수는 해당 벡터의 마지막 셀 값을 반환한다. nth() 함수는 해당 벡터의 n-번째 셀 값을 반환한다. 주로 summarize() 함수와 함께 사용된다. 아래의 사례는 대륙별로 1인당 GDP가 가장 큰 국가와 가장 작은 국가를 추출한 것이다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  group_by(continent) |&gt; \n  arrange(desc(gdpPercap)) |&gt; \n  summarize(\n    country_first = first(country),\n    country_last = last(country)\n  ) |&gt; \n  ungroup()\n\n# A tibble: 5 × 3\n  continent country_first country_last    \n  &lt;fct&gt;     &lt;fct&gt;         &lt;fct&gt;           \n1 Africa    Gabon         Congo, Dem. Rep.\n2 Americas  United States Haiti           \n3 Asia      Kuwait        Myanmar         \n4 Europe    Norway        Albania         \n5 Oceania   Australia     New Zealand     \n\n\n유사한 기능을 하는 데이터 프레임 함수로 slice_head(), slice_tail(), slice() 함수가 있다. 궁극적인 차이점은 이 함수들은 특정한 행(들)으로 구성된 데이터 프레임을 반환한다는 것이다.\n\n3.2 값 변경 함수\nif_else() 함수는 값 변경 함수 중 가장 빈번하게 사용되는 것으로, 주로 단일 벡터에 대해, 이진 조건식을 통해 해당 변수의 값을 변경하는 것이다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  mutate(\n    gdp_status = if_else(gdpPercap &gt;= 20000, \"high\", \"low\")\n  ) |&gt; \n  count(gdp_status)\n\n# A tibble: 2 × 2\n  gdp_status     n\n  &lt;chr&gt;      &lt;int&gt;\n1 high          33\n2 low          109\n\n\n위의 사례는 수치형 변수를 범주형 변수로 바꾸는 것으로 보통 재코드화(recode)라고 불리는 연산이다. 두 개 이상의 범주로 분할하는 경우에도 if_else() 함수를 사용할 수 있지만, 이 경우는 case_when() 함수가 더 유용하다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  mutate(\n    gdp_status = case_when(\n      gdpPercap &lt; 3000 ~ \"Low\", \n      gdpPercap &gt;= 3000 & gdpPercap &lt; 20000 ~ \"Medium\",\n      gdpPercap &gt;= 20000 ~ \"High\"\n    )\n  ) |&gt; \n  count(gdp_status)\n\n# A tibble: 3 × 2\n  gdp_status     n\n  &lt;chr&gt;      &lt;int&gt;\n1 High          33\n2 Low           49\n3 Medium        60\n\n\ncase_when() 함수는 조건식에 두 개 이상의 변수를 포함할 수 있다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  mutate(\n    overall_status = case_when(\n      gdpPercap &lt; 3000 & lifeExp &lt; 50 ~ \"Really Bad\",\n      gdpPercap &gt;= 20000 & lifeExp &gt; 80  ~ \"Really Good\",\n      .default = \"Medium\"\n    )\n  ) |&gt; \n  count(overall_status)\n\n# A tibble: 3 × 2\n  overall_status     n\n  &lt;chr&gt;          &lt;int&gt;\n1 Medium           113\n2 Really Bad        16\n3 Really Good       13\n\n\ncase_match() 함수는 범주의 개수를 줄이는데 유용하게 사용될 수 있다. .default 인수를 통해 부여된 조건식에 해당하지 않는 나머지 모든 케이스에 대해 어떤 값을 부여할지를 결정할 수 있다. 이와 동일한 것을 case_when() 함수로도 가능하기 때문에 모든 경우에 대해 case_when() 함수를 활용하면 된다.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  mutate(\n    gdp_status = case_when(\n      gdpPercap &lt; 3000 ~ \"Low\", \n      gdpPercap &gt;= 3000 & gdpPercap &lt; 20000 ~ \"Medium\",\n      gdpPercap &gt;= 20000 ~ \"High\"\n    )\n  ) |&gt; \n  mutate(\n    gdp_status = case_match(\n      gdp_status, \n      c(\"Low\", \"Medium\") ~ 1,\n      \"High\" ~ 2\n    )\n  ) |&gt; \n  count(gdp_status)\n\n# A tibble: 2 × 2\n  gdp_status     n\n       &lt;dbl&gt; &lt;int&gt;\n1          1   109\n2          2    33\n\n\n\n3.3 순위 부여 함수\n특정 벡터의 값을 기준으로 순위를 부여하고, 그 순위값으로 구성된 새로운 벡터를 생성하는 함수에 기본적으로 다음의 세 가지 방식이 있다.\n\nrow_number() 함수는 동일값이라 하더라도 값의 등장 순서에 따라 서로 다른 순위를 부여한다. 예를 들어, 다섯개의 숫자가 있고 두 번째 순위 값이 두 개라고 했을 때, 1~5의 모든 순위가 존재한다.\nmin_rank() 함수는 동일값에 동순위를 부여하고, 그 다음 값에는 동순위 갯수를 감안한 그 다음 순위를 부여한다. 예를 들어, 다섯개의 숫자가 있고 두 번째 순위 값이 두 개라고 했을 때, 3은 없다.\ndense_rank() 함수는 동일값에 동순위를 부여하고, 그 다음 값에는 동순위 갯수에 상관없이 바로 그 다음 순위를 부여한다 예를 들어, 다섯개의 숫자가 있고 두 번째 순위 값이 두 개라고 했을 때, 5는 없다.\n\n\ntbl_rank &lt;- tibble(x = c(10, 20, 20, 30, 40))\ntbl_rank |&gt; \n  mutate(\n    row_number = row_number(x),\n    min_rank = min_rank(x),\n    dense_rank = dense_rank(x)\n  )\n\n# A tibble: 5 × 4\n      x row_number min_rank dense_rank\n  &lt;dbl&gt;      &lt;int&gt;    &lt;int&gt;      &lt;int&gt;\n1    10          1        1          1\n2    20          2        2          2\n3    20          3        2          2\n4    30          4        4          3\n5    40          5        5          4\n\n\n이 외에 두 개의 부가적인 함수가 존재하는데, 백분위수(percentile)를 계산한다는 의미에서는 동일하지만 계산 방식이 조금 다르다.\n\npercent_rank() 함수: 백분위수을 계산해 주는데, 해당 값보다 작은 값의 개수를 전체 개수에서 1을 뺀 값으로 나눈값을 산출한다.\ncume_dist() 함수: 백분위수를 계산해 주는데, 해당 값보다 작거나 같은 값의 개수를 전체 개수로 나눈값을 산출한다.\n\n\ntbl_rank &lt;- tibble(x = c(10, 20, 20, 30, 40))\ntbl_rank |&gt; \n  mutate(\n    percent_rank = percent_rank(x),\n    cume_dist = cume_dist(x)\n  )\n\n# A tibble: 5 × 3\n      x percent_rank cume_dist\n  &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;\n1    10         0          0.2\n2    20         0.25       0.6\n3    20         0.25       0.6\n4    30         0.75       0.8\n5    40         1          1  \n\n\n\n3.4 값 순서 변경 함수\n값 순서 변경 함수 중 가장 빈번하게 사용되는 것이 desc() 함수이다. 데이터 프레임 함수인 arrange()가 기본적으로 오름차순으로 정렬하는데, desc() 함수를 쓰면 내림차순으로 정렬할 수 있다.\n\ntbl_rank &lt;- tibble(x = c(10, 20, 20, 30, 40))\ntbl_rank |&gt; \n  arrange(desc(x))\n\n# A tibble: 5 × 1\n      x\n  &lt;dbl&gt;\n1    40\n2    30\n3    20\n4    20\n5    10\n\n\nlag()과 lead() 함수는 주어진 벡터를 행방향으로 한칸 이동한 새로운 벡터를 생성하는데 사용된다. lag() 함수는 뒤로 한칸 밀어 이전 값을 가져와서 새로운 벡터를 생성하는데, 새로 만들어진 벡터의 첫 번째 셀 값은 NA가 된다. 이에 반해 lead() 함수는 앞으로 한칸 당겨 이후 값을 가져와서 새로운 벡터를 생성하는데, 새로 만들어진 벡터의 마지막 셀 값은 NA가 된다.\n\ntbl_rank &lt;- tibble(x = c(10, 20, 20, 30, 40))\ntbl_rank |&gt;\n  mutate(\n    x_lag = lag(x), \n    x_lead = lead(x) \n  )\n\n# A tibble: 5 × 3\n      x x_lag x_lead\n  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1    10    NA     20\n2    20    10     20\n3    20    20     30\n4    30    20     40\n5    40    30     NA\n\n\ndefault 인자를 활용하면 NA의 생성을 막을 수 있다.\n\ntbl_rank &lt;- tibble(x = c(10, 20, 20, 30, 40))\ntbl_rank |&gt;\n  mutate(\n    x_lag = lag(x, default = first(x)), \n    x_lead = lead(x, default = last(x)) \n  )\n\n# A tibble: 5 × 3\n      x x_lag x_lead\n  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1    10    10     20\n2    20    10     20\n3    20    20     30\n4    30    20     40\n5    40    30     40\n\n\n\n3.5 결측치 처리 함수\n결측치 처리 함수는 벡터의 NA값과 관련된 함수이다. coalesce() 함수는 NA에 특정한 값을 부여하는데 반해, na_if() 함수는 특정한 값에 NA를 부여하는 함수이다.\n\ntbl_na &lt;- tibble(x = c(1, 2, NA, 4, NA, 7))\ntbl_na |&gt; \n  mutate(\n    x_coalesce = coalesce(x, 0), \n    x_na_if = na_if(x, 7)\n  )\n\n# A tibble: 6 × 3\n      x x_coalesce x_na_if\n  &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n1     1          1       1\n2     2          2       2\n3    NA          0      NA\n4     4          4       4\n5    NA          0      NA\n6     7          7      NA\n\n\n\n3.6 논리형 벡터 생성 함수\n논리형 벡터 생성 함수는 조건의 부합 여부에 따라 TRUE와 FALSU로 구성된 새로운 벡터를 생성하는 함수를 의미한다. Base R에는 다음과 같은 논리형 벡터 생성 함수가 빈번하게 사용된다.\n\nis.na(): 결측치 여부\nis.numeric(): 수치형 여부\nis.integer(): 정수형 여부\nis.character(): 문자형 여부\nis.logical(): 논리형 여부\nis.factor(): 팩터 여부\n\n여기에 덧붙여 dplyr은 흥미로운 논리형 벡터 생성 함수를 제공한다.\n\nbetween(): 특정한 값이 주어진 두 값 사이에 위치하는 지의 여부 검토\nnear(): 특정한 값이 기준이 되는 값과 충분이 유사한지의 여부 검토\n\n\ngapminder |&gt; \n  filter(\n    year == 2007, \n    between(gdpPercap, 20000, 30000)\n  )\n\n# A tibble: 13 × 6\n   country        continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;          &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Bahrain        Asia       2007    75.6   708573    29796.\n 2 Czech Republic Europe     2007    76.5 10228744    22833.\n 3 Greece         Europe     2007    79.5 10706290    27538.\n 4 Israel         Asia       2007    80.7  6426679    25523.\n 5 Italy          Europe     2007    80.5 58147733    28570.\n 6 Korea, Rep.    Asia       2007    78.6 49044790    23348.\n 7 New Zealand    Oceania    2007    80.2  4115771    25185.\n 8 Oman           Asia       2007    75.6  3204897    22316.\n 9 Portugal       Europe     2007    78.1 10642836    20510.\n10 Saudi Arabia   Asia       2007    72.8 27601038    21655.\n11 Slovenia       Europe     2007    77.9  2009245    25768.\n12 Spain          Europe     2007    80.9 40448191    28821.\n13 Taiwan         Asia       2007    78.4 23174294    28718.\n\n\nnear() 함수는 많이 사용되지는 않지만, 부등소수점 수(floating point number)의 정확도로 인해 발생하는 상동성 평가의 문제점을 극복하기 위한 함수이다. 아래의 예시를 보자. 두 값은 명백히 1과 2이다.\n\nx &lt;- c(1 / 49 * 49, sqrt(2) ^ 2)\nx\n\n[1] 1 2\n\n\n그러나 다음의 상동성 평가 문제가 발생한다.\n\nx == c(1, 2)\n\n[1] FALSE FALSE\n\n\n이것은 부등소수점 수의 정확도로 발생하는 문제이다.\n\nprint(x, digits = 16)\n\n[1] 0.9999999999999999 2.0000000000000004\n\n\nnear() 함수는 이러한 미세한 차이를 무시할 수 있게 해주어 상동성 평가 문제를 해결한다.\n\nnear(x, c(1, 2))\n\n[1] TRUE TRUE",
    "crumbs": [
      "R과 데이터사이언스",
      "변형하기"
    ]
  },
  {
    "objectID": "exec_11.html#bslib-패키지를-활용한-현대적-ui-설계-컨테이너와-컴포넌트",
    "href": "exec_11.html#bslib-패키지를-활용한-현대적-ui-설계-컨테이너와-컴포넌트",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "\n4 bslib 패키지를 활용한 현대적 UI 설계: 컨테이너와 컴포넌트",
    "text": "4 bslib 패키지를 활용한 현대적 UI 설계: 컨테이너와 컴포넌트\n\n4.1 개요\n위에서 Shiny의 전체 레이아웃은 위계적으로 구성된 레이아웃 함수들에 의해 결정된다고 했다. fluidPage(), titlePanel(), sidebarLayout(), sidebarPanel(), mainPanel() 과 같은 레이아웃를 통해 그림 3 에 나타나 있는 것과 같은 외향의 레이아웃이 완성된 것이다.\n이러한 전통적인 레이아웃 디자인을 보다 현대적인 레이아웃으로 탈바꿈하기 위해 등장한 것이 bslib 패키지이다. bslib 패키지는 Bootstrap을 기반으로 Shiny와 R Markdown을 위한 현대적인 UI 도구 모음을 제공한다. 카드, 밸류 박스, 사이드바 등 재사용 가능한 UI 구성 요소를 통해 Shiny 웹 앱과 문서를 효율적으로 구성할 수 있으며, 테마 시스템을 활용해 웹 앱과 문서의 외관을 유연하게 사용자 정의하고 실시간으로 조정할 수 있다. 또한 최신 Bootstrap 및 Bootswatch를 지원하여, 기본적으로 Bootstrap 3에 의존하는 기존 Shiny 및 R Markdown 환경보다 현대적인 웹 UI 구현을 가능하게 한다.\nbslib 패키지는 shiny 패키지의 기본 레이아웃 함수와는 다른 종류의 함수를 제공한다. 그러므로 조금 더 현대적인 감각의 웹 앱을 생성하기 위해서는 bslib 패키지에서 제공되는 레이아웃 함수에 익숙해져야 한다. 여기서는 bslib 패키지를 통해 그림 3 웹 앱이 어떻게 달라지는지를 살펴본다.\nShiny 패키지는 기본적으로 11개의 예제 웹 앱을 제공한다. 다음과 같이 실행해 본다.\n\nlibrary(shiny)\nrunExample()\n\n이 들 중 첫 번째 예제인 “01_hello”가 그림 3 에 나타나 있는 웹 앱이다. 해당 예제를 실행하려면 다음과 같이 하면 된다.\n\nrunExample(\"01_hello\")\n\n아래의 그림 5 와 같은 웹 앱이 생성된다. 이것을 그림 3 과 비교해 보라. 조금 다르다는 것을 쉽게 알아 챌 수 있는데(왼편 슬라이더바에서 &lt; 를 눌러보라.), 이것이 bslib 패키지를 활용하여 제작된 웹 앱이다.\n\n\n\n\n\n그림 5: bslib 패키지를 활용한 웹 앱의 예제\n\n\n웹 앱 뿐만 아니라 코드도 살펴보려면 다음과 같이 실행하면 된다.\n\nrunExample(\"01_hello\", display = \"showcase\")\n\n삽입되어 있는 설명 부분을 제거하고 코드만 남기면 다음과 같다. 이것을 그림 3 의 코드와 비교해 보라. 오로지 UI 부분의 코드만 다르고, 그것도 레이아웃 함수명만 달라져 있다는 것을 알 수 있다(입출력 함수는 그대로이다). 결국 bslib 패키지는 UI 부분의 레이아웃만 바꾼다.\n\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_sidebar(\n  title = \"Hello Shiny!\",\n  sidebar = sidebar(\n    sliderInput(\n      inputId = \"bins\",\n      label = \"Number of bins:\",\n      min = 1,\n      max = 50,\n      value = 30\n    )\n  ),\n  plotOutput(outputId = \"distPlot\")\n)\n\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    x &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n    hist(\n      x,\n      breaks = bins,\n      col = \"#75AADB\",\n      border = \"white\",\n      xlab = \"Waiting time to next eruption (in mins)\",\n      main = \"Histogram of waiting times\"\n    )\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n첫째, page_sidebar()가 최상위 레이아웃 함수이다. page_sidebar()는 bslib에서 가장 널리 사용되는 페이지 레이아웃 함수로, 전체 너비를 차지하는 헤더(제목)와 사용자 입력을 위한 사이드바를 갖춘 대시보드형 레이아웃을 손쉽게 구성할 수 있도록 설계되었다. page_sidebar()함수는 전통적인 shiny 레이아웃 함수 중 fluidPage(), titlePanel(), sidebarLayout() 함수의 역할을 동시에 수행한다고 생각할 수 있다.\n둘째, page_sidebar() 의 여러 인수가 전통적인 titlePanel() 함수와 sidebarLayout()의 하위 함수인 sidebarPanel() 함수를 대신한다.\n\ntitle: 대시보드의 제목을 설정할 수 있으며, titlePanel() 함수와 동일한 기능을 한다.\nsidebar = sidebar(): sidebarPanel() 함수와 동일한 기능을 한다. sidebarPanel() 함수 속에 입력 함수인 siderInput() 함수가 들어 있었던과 동일하게 sidebar() 속에 siderInput() 함수가 들어 있다.\n\n셋째, 전통적인 Shiny의 mainPanel() 함수 없이 출력 표출 함수(plotOutput())가 막바로 사용된다. 그러나 이것은 가장 단순한 방식으로, card() 함수를 사용하면 보다 풍성한 옵션을 사용할 수 있다. card() 함수 내부에서 card_header()와 card_body()라는 컴포넌트 함수를 활용한다. 아래는 위의 코드에 대해 두 가자 부가적인 조치를 한 것이다. 첫째, card() 함수를 통해 출력 표출 부분을 보완한다. 둘째, 기본 플롯 함수 대신 ggplot2 패키지를 통해 히스토그램을 작성하고 그것을 plotly 패키지의 ggplotly() 함수를 통해 인터랙티브 플롯을 생성한다. plotly 패키지의 출력 생성 및 출력 표출을 위해 renderPlotly({})와 plotlyOutput() 함수가 활용되는 점에 주목한다.\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(plotly)\n\nui &lt;- page_sidebar(\n  title = \"Hello Shiny!\",\n  sidebar = sidebar(\n    sliderInput(\n      inputId = \"bins\",\n      label = \"Number of bins:\",\n      min = 1,\n      max = 50,\n      value = 30\n    )\n  ),\n  card(\n    card_header(\"ggplot2: Histogram\"),\n    card_body(\n      plotlyOutput(outputId = \"distPlot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlotly({\n    x    &lt;- faithful[, 2]\n    gg &lt;- ggplot() +\n      geom_histogram(\n        aes(x = x), bins = input$bins, fill = 'darkgray', color = 'white'\n      ) +\n      labs(\n        x = 'Waiting time to next eruption (in mins)',\n        y = \"Frequencies\",\n        title = 'Histogram of waiting times'\n      )\n    ggplotly(gg)\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\n4.2 컨테이너 함수\n컨테이너 함수란 다른 UI 요소를 담되, 그 자체가 시각적 콘텐츠의 주제가 되지 않고 공간, 전환, 계층 구조를 정의하는 함수이다. 컨테이너 함수는 크게 세 가지로 나뉜다.\n\n페이지 컨테이너: 페이지 전체의 폭, 높ㅇ디, 스크롤 방식 등 최상위 UI 구조를 정의하는 컨테이너로, page_*() 형태를 띤다.\n레이아웃 컨테이너: 페이지 내부에서 여러 UI 요소를 동시에 어떻게 배치할지를 결정하는 컨테이너로, layout_*() 형태를 띤다.\n내비게이션 컨테이너: 여러 UI 패널을 묶어 사용자 상호작용에 따라 표시되는 콘텐츠를 전환하는 컨테이너로, navset_*()의 형태를 띤다.\n\n분류별 컨테이너 함수를 정리하면 표 3 과 같다. 자세한 사항은 bslib 패키지 홈페이지의 Get Started나 Layouts를 참고할 수 있다.\n\n\n표 3: bslib 컨테이너 함수\n\n\n\n\n\n\n\n\n분류\n함수\n특징\n\n\n\n페이지 컨테이너(기본)\n\npage_fixed()\npage_fluid()\npage_fillable()\n\n\n고정형(고정폭: 940픽셀)\n유동형(웹페이지의 전체 폭)\n대시보드형(웹페이지의 전체 폭/높이)\n\n\n\n페이지 컨테이너(확장)\n\npage_sidebar()\npage_navbar()\n\n\n표준형(전역적 사이드바 포함)\n다중 페이지, nav_panel()의 집합\n\n\n\n레이아웃 컨테이너\n\nlayout_siderbar()\nlayout_columns()\nlayout_column_wrap()\n\n\npage_*(), card(), nav_panel() 내부\npage_sidebar() 내부\nnav_panel() 내부\n\n\n\n\n내비게이션 컨테이너\n(페이지/레이아웃 레벨)\n\n\nnavset_tab()\nnavset_pill()\nnavset_underline()\n\n\nnav_panel()의 집합\n\n\n\n내비게이션 컨테이너\n(카드 레벨)\n\n\nnavset_card_tab()\nnavset_card_pill()\nnavset_card_underline()\n\n\nnav_panel()의 집합\n\n\n\n\n\n\n우선 단일 페이지의 구조를 결정하는 페이지 컨테이너를 살펴보면 다음과 같다. page_fixed(), page_fluid(), page_fillable() 는 가장 중요한 세 가지 함수이다. page_fixed()는 중앙 정렬된 고정 폭 페이지 컨테이너이고, page_fluid()는 브라우저 폭에 따라 콘텐츠 영역이 유동적으로 변화는 페이지 컨테이너이고, page_fillable()는 브라우저의 가시 영역을 높이까지 포함해 채우도록 설계된 페이지 컨테이너이다. 그림 6 는 이 세가지 페이지 컨테이너를 비교하고 있다.\n\n\n\n\n\n그림 6: 페이지 컨테이너의 종류(https://shiny.posit.co/r/articles/build/layout-guide/)\n\n\n그러나 가장 중요한 페이지 컨테이너는 page_sidebar()로 bslib 패키지의 표준이다. 이것은 페이지 전체를 채우는 구조 위에 사이드바-메인 영역 분할을 기본으로 제공하는 고수준 페이지 컨테이너이다. 단순히 예기하면 page_sidebar()는 page_fillable()과 레이아웃 컨테이너인 layout_siderbar()를 결합한 것으로 이해할 수 있다. page_navbar()는 상단 내비게이션 바를 페이지의 기본 구조로 표함하여, 여러 화면을 전환하는 앱을 구성하는 고수준 페이지 컨테이너이다. page_navbar()는 개념적으로 페이지 컨테이너와 내비게이션 컨테이너(navbar)을 통합한다.\n레이아웃 컨테이너는 페이지 전체가 아니라 페이지 내부 배치를 담당하는데, 페이지 컨테이너와 달리 중첩 사용이 가능하지만 콘텐츠 자체를 표현하지는 않는다. layout_siderbar()는 사이드바와 메인 콘텐츠 영역으로 화면을 이분하는 레이아웃 컨테이너를 생성하는데 주로 page_*(), card(), nav_panel() 내부 어디에도 존재할 수 있다. layout_columns()는 여러 UI 요소를 동일 행 내의 다중 컬럼으로 배치하는 레이아웃 컨테이너를 생성한다. 컬럼의 수와 폭을 명시적으로 제어할 수 있으며 정돈된 레이아웃 구형에 용이하다. layout_column_wrap()은 컬럼을 행 단위로 자동 줄바꿈하여 반응형 배치를 제공하는 레이아웃 컨테이너이다. 컬럼 폭 기준으로 자동 배치하며 화면 크기에 따라 행 수가 동적으로 변한다.\n내비게이션 컨테이너는 여러 UI 패널을 묶어 사용자 상호작요에 따라 표시되는 콘텐츠를 전환하는 컨테이너로, 페이지 컨테이너나 레이아웃 컨테이너의 내부에서 사용된다. 한 번에 하나의 패널만 활성화되며, 공간 배치가 아니라 상태 전환을 담당한다. navset_tab(), navset_pill(), navset_underline()는 모두 nav_panel()들의 집합으로 구성되며, 콘텐츠 전환의 방식이 다를 뿐이다. navset_tab()는 전통적인 탭 모양을, navset_pill()는 둥근 필(pill) 모양의 버튼을, navset_underline()는 밑줄을 그은 형태를 제공한다. navset_card_tab(), navset_card_pill(), navset_card_underline()은 동일한 기능을 하지만 card 스타일을 기본으로 내장한 컨테이너이다. navset_*() 함수가 페이지 또는 레이아웃의 주요 내비게이션과 같은 비교적 상위 UI 계층에서 사용되는데 반해 navset_card_*() 함수는 주로 콘텐츠 블록 내부에 위치하여 카드 수준의 국소적 전환에 사용된다.\n\n4.3 콘텐츠 컴포넌트: UI 구성 요소\n가장 중요한 컴포넌트에 카드(card), 사이드바(sidebar), 밸류 박스(value box), 툴팁(tooltip)과 팝오버(popover)가 있다. 자세한 사항은 bslib 패키지 홈페이지의 Components를 참고할 수 있다.\n\n4.3.1 카드\n카드(card)는 현대적인 UI에서 가장 널리 사용되는 정보 구성 단위 중 하나이다. 기본적으로 카드는 테두리와 여백을 갖는 직사각형 컨테이너에 불과하지만, 관련된 정보를 의미 있게 묶어 제시할 경우 사용자가 내용을 보다 쉽게 이해하고, 집중하며, 탐색할 수 있도록 돕는다. 이러한 특성 때문에 카드는 대시보드와 UI 설계에서 핵심적인 역할을 하며, 대부분의 성공적인 대시보드 및 UI 프레임워크는 카드를 주요 컴포넌트로 채택하고 있다. card() 함수는 다음과 같은 컴포넌트 함수를 갖는다.\n\ncard_header(): 제목\ncard_body(): 주 콘텐츠(생략 가능: 바로 출력 표출 함수 표시 가능)\ncard_footer(): 부가 설명\n\n4.3.2 사이드바\n사이드바(sidebar)는 필터, 설정, 기타 입력 요소를 사용자가 쉽게 접근할 수 있도록 제공하는 핵심 UI 컴포넌트로, 이들이 제어하는 대화형 기능과 나란히 배치된다는 점이 특징이다. 사이드바를 활용하면 사용자 입력과 결과 출력 간의 관계를 명확히 할 수 있어, 대시보드의 사용성과 탐색성이 크게 향상된다. bslib에서는 page_sidebar()와 page_navbar() 함수를 통해 페이지 수준(page-level)의 사이드바 레이아웃을 기본적으로 제공하며, 이 외에도 다양한 형태의 사이드바 레이아웃을 지원하여 인터페이스의 목적과 복잡도에 따라 유연한 UI 설계를 가능하게 한다.\n\n\n\n\n\n\n노트사이드바 컴포넌트와 사이드바 레이아웃\n\n\n\n\n\n사이드바 컴포넌트와 사이드바 레이아웃은 다르다. 사이드바 레이아웃은 공간을 나누는 구 조를 의미한다면, 사이드바 컴포넌트는 콘텐츠를 담는 UI 블록이다. 입력 위젯, 텍스트, 메뉴 등이 포함되며 독립적인 UI가 의미가 있다. 사이드바 레이아웃의 중요 함수에는 앞에서 살펴본 것과 같은 page_sidebar(), layout_sidebar() 등이 있고, 사이드바 컴포넌트의 대표적인 함수에 sidebar()가 있다.\nbslib에서 제공하는 사이드바 레이아웃은 크게 부유형(floating), 채움형(filling), 다중 페이지/탭형(multi-page/tab)의 세 가지로 구분할 수 있다.\n부유형 레이아웃은 layout_sidebar()를 사용하는데, 페이지의 어느 위치에나 배치할 수 있는 사이드바 레이아웃을 구성할 수 있다. 이 방식은 의미적으로 관련된 입력 요소와 출력 요소를 시각적으로 함께 묶어 제시하는 데 적합하다. 또한 card()와 함께 사용하면 전체 화면 확장(full-screen), 헤더·푸터 추가 등 카드가 제공하는 다양한 기능을 활용할 수 있다.\n채움형 레이아웃은 page_sidebar()를 사용하는데 페이지 전체를 채우는 사이드바 레이아웃을 생성한다. 내부적으로 page_sidebar()는 page_fillable()과 layout_sidebar()를 단순히 감싼(wrapper) 함수에 불과하다. 이 구조를 이해하면, 하나의 채움형 레이아웃 안에 여러 개의 사이드바 레이아웃을 유연하게 배치할 수 있는 가능성이 열린다.\n다중 페이지/탭 레이아웃은 page_navbar()나 navset_card_tab() 내부에서 sidebar 인수를 사용해 사이드바를 구성할 수 있다. 이 경우 사이드바는 페이지 전체를 채우는 동시에, 모든 페이지나 탭에서 동일하게 유지되어 표시된다. 이후에는 페이지별로 서로 다른 레이아웃을 구성하는 방법도 다루겠지만, 모든 페이지에서 동일한 사이드바를 사용하는 것이 바람직한 경우도 많다. 이러한 경우에는 conditionalPanel()을 활용하여 특정 페이지에서만 사이드바의 일부 내용을 표시하거나 숨길 수 있다.\n\n\n\n\n4.3.3 밸류 박스\n밸류 박스(value box)는 대시보드에서 핵심적인 수치나 지표를 한눈에 전달하기 위해 사용되는 UI 컴포넌트이다. 값(value), 설명(label), 아이콘(icon) 등을 함께 제시하여 사용자가 현재 상태나 주요 변화를 빠르게 파악할 수 있도록 돕는다. bslib의 value_box() 함수는 카드(card) 기반 설계를 따르므로 다른 UI 요소들과 시각적으로 일관되게 어우러지며, Shiny의 반응성과 결합해 값이 동적으로 갱신되는 대시보드를 구성하는 데 특히 유용하다.\nvalue_box() 함수는 네 가지 주요 구성 요소로 이루어진다.\n\nvalue는 표시하고자 하는 핵심 수치나 텍스트 값으로, 대시보드에서 가장 중요한 정보를 전달한다. 출력 표출 함수를 사용할 수도 있다.\ntitle은 value 위에 선택적으로 표시되는 설명 텍스트로, 해당 값의 의미나 지표명을 명확히 한다.\nshowcase는 아이콘이나 기타 UI 요소와 같이 value 옆에 함께 배치되는 시각적 요소로, 정보를 보다 직관적으로 인식하도록 돕는다. bs_icon() 컴포넌트 함수를 주로 사용한다.\ntheme은 값 상자의 색상이나 스타일을 조정하는 선택적 설정으로, 대시보드의 전체 디자인과 시각적 일관성을 유지하거나 강조 효과를 줄 수 있다.\n\n4.3.4 툴팁과 팝오버\n툴팁(tooltip)과 팝오버(popover)는 화면을 방해하지 않으면서 추가 정보를 제공하거나 상호작용을 가능하게 하는 유용한 UI 요소이다. 툴팁은 주로 간단한 설명을 표시하는 데 사용되며, 팝오버는 보다 풍부한 정보 제공이나 사용자 입력을 포함한 상호작용을 지원한다. 예를 들어, card_header()에 “도움말” 아이콘과 함께 tooltip()을 부착하면 사용자가 시각화된 데이터에 대한 추가 설명을 손쉽게 확인할 수 있다. 또한 동일한 헤더 영역에 “설정” 아이콘과 popover()를 연결하면 시각화의 매개변수를 직접 제어할 수 있는 인터페이스를 제공할 수 있다. 더 나아가 card_footer()의 링크에 popover()를 적용하면 추가 정보의 표시뿐 아니라 하이퍼링크와 같은 상호작용 요소를 함께 제공할 수 있어, 정보 탐색과 사용자 경험을 동시에 향상시킨다.\n구현 방식 측면에서 보면, 툴팁과 팝오버는 매우 유사하다. 두 컴포넌트 모두 사용자의 상호작용을 통해 표시 여부가 전환되는 트리거(trigger) UI 요소와, 화면에 표시될 메시지 내용을 필요로 한다. tooltip()과 popover()는 공통적으로 첫 번째 인수를 트리거로 취급하며, 이름이 지정되지 않은 나머지 인수들은 메시지 내용으로 사용된다. 또한 popover()의 경우에는 선택적으로 제목(title)을 함께 지정할 수 있다.\n반면, 사용자 경험(UX)과 활용 목적 측면에서는 두 컴포넌트의 성격이 뚜렷이 다르다. 툴팁은 포커스나 마우스 오버(hover)에 의해 표시되는 반면, 팝오버는 클릭을 통해 열리고 닫힌다. 이로 인해 팝오버는 툴팁보다 화면에 더 오래 유지되는, 즉 상대적으로 지속성이 높은 인터페이스이며, 추가적인 사용자 상호작용이 필요한 경우에 적합하다. 따라서 간단한 설명과 같은 읽기 전용(read-only) 정보에는 툴팁을 사용하는 것이 바람직하고, 메시지 자체와의 상호작용이 필요한 경우에는 팝오버를 사용하는 것이 적절하다.\n\n4.4 사용자 정의 테마\nbslib 패키지의 또 다른 중요한 기능은 다양한 사용자 정의 테마(custom theming)의 적용을 용이하게 한다는 점이다. bslib는 Bootstrap 5를 기반으로 한 테마 시스템을 추상화하여, 사용자가 색상, 타이포그래피, 여백, 컴포넌트 스타일 등 핵심 디자인 요소를 일관된 방식으로 제어할 수 있도록 지원한다. 특히 bs_theme()를 중심으로 한 테마 정의 방식은 개별 UI 요소를 일일이 스타일링하는 접근에서 벗어나, 디자인 전반을 하나의 체계적인 설정으로 관리할 수 있게 해준다. 이를 통해 인터랙티브 대시보드나 웹 애플리케이션의 시각적 일관성을 유지하면서도, 목적과 사용자 맥락에 맞는 다양한 테마를 손쉽게 적용할 수 있다. 이러한 사용자 정의 테마 기능은 bslib를 단순한 UI 구성 도구를 넘어, 재현 가능하고 확장 가능한 시각적 설계 도구로 자리매김하게 하는 핵심 요소라 할 수 있다.\n\n4.4.1 bs_theme() 함수\nbs_theme() 함수는 bslib 패키지에서 사용자 정의 테마를 정의하는 핵심 함수로, Bootstrap 기반 UI의 시각적 전반을 하나의 설정 객체로 통합 관리한다. 즉, bs_theme() 함수는 색상, 글꼴, 여백, 컴포넌트 스타일 등 UI 전반의 디자인 규칙을 한 번에 정의하고 이를 Shiny 앱 전체에 일관되게 적요하도록 해주는 테마 객체 생성 함수이다.\nbs_theme() 함수의 주요 인수는 다음과 같다.\n\nversion = 5: 사용할 Bootstrap 버전으로 5가 기본값\nbg = \"#ffffff\", fg = \"#212529\": 기본 배경색 및 기본 텍스트 색상\nprimary = \"#0d6efd\", secondary = \"\", success = \"\", info = \"\", warning = \"\", danger = \"\": Bootstrap의 의미 기반 색상 체계\nbase_font = font_google(\"Noto Sans KR\"), heading_font = font_google(\"Noto Serif KR\"), code_font = font_google(\"JetBrains Mono\"): 본문 텍스트, 제목, 코드 블록의 타이포그래피 일관성 확보\nbase_font_size = \"1rem\": 기본 글자 크기로 rem 단위 사용이 권장 된다.\nspacer = \"1rem\": 여백의 기준 단위\nborder_radius = \"0.5rem\": 카드, 버튼 등의 모서리 둥글기\nbootswatch = \"flatly\": 미리 정의된 Bootswatch 테마\n\n4.4.2 테마 미리보기 및 검증\nbslib 패키지의 bs_theme_preview() 함수는 사용자 정의 테마를 실제 UI 구성 요소에 적용해 보며 시각적 효과를 즉시 확인할 수 있는 테마 미리보기 및 검증 도구이다.\n콘솔에서 함수를 실행하면, 버튼, 카드, 입력 위젯 등 대표 UI 컴포넌트에 테마를 적용해볼 수 있고, 색상 대비, 타이포그래피, 여백 등을 한눈에 점검할 수 있을 뿐만 아니라, 테마 수정의 결과를 즉시 확인해 볼 수 있다. 그림 7 에서 볼 수 있는 것처럼 오른편의 Theme customizer를 조작하여 이러한 기능을 활용해 볼 수 있다.\n\n\n\n\n\n그림 7: be_theme_update() 함수를 활용한 테마 미리보기 및 검증",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "exec_11.html#bslib-패키지를-활용한-현대적-ui-구조-디자인",
    "href": "exec_11.html#bslib-패키지를-활용한-현대적-ui-구조-디자인",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "\n4 bslib 패키지를 활용한 현대적 UI 구조 디자인",
    "text": "4 bslib 패키지를 활용한 현대적 UI 구조 디자인\n\n4.1 개요\n위에서 Shiny의 전체 레이아웃은 위계적으로 구성된 UI 구조 함수, 즉 컨테이너 함수들에 의해 결정된다고 했다. fluidPage(), titlePanel(), sidebarLayout(), sidebarPanel(), mainPanel() 과 같은 컨테이너 함수를 통해 그림 3 에 나타나 있는 것과 같은 외향의 UI 구조가 완성된 것이다.\n보다 현대적인 UI 구조 디자인을 위해 등장한 것이 bslib 패키지이다. bslib 패키지는 Bootstrap을 기반으로 Shiny와 R Markdown을 위한 현대적인 UI 도구 모음을 제공한다. bslib패키지는 다양하고 유연한 컨테이너 함수를 제공할 뿐만 아니라, 카드(card), 밸류 박스(value box), 사이드바(sidebar) 등 재사용 가능한 UI 컴포넌트(콘텐츠 구성요소)를 통해 Shiny 웹 앱과 문서를 효율적으로 구성할 수 있게 한다(전통적인 Shiny에 부족한 부분). 또한 테마 시스템을 활용하여 웹 앱과 문서의 외관을 유연하게 사용자 정의하고, 이를 실시간으로 조정할 수 있다. 나아가 최신 Bootstrap 및 Bootswatch를 지원함으로써, 기본적으로 Bootstrap 3에 의존하는 기존 Shiny 및 R Markdown 환경에 비해 보다 현대적이고 일관된 웹 UI 구현을 가능하게 한다.\nbslib 패키지를 이용해 좀 더 현대적인 감각의 웹 앱을 생성하기 위해서는 bslib 패키지에서 제공되는 다양한 UI 컨테이너 함수와 UI 컴포넌트 함수를 익혀야 하며, 뒤에서 자세히 다룬다. 여기서는 bslib 패키지를 통해 그림 3 웹 앱이 어떻게 달라지는지에 대해서만 살펴본다.\nShiny 패키지는 기본적으로 11개의 예제 웹 앱을 제공한다. 다음과 같이 실행해 본다.\n\nlibrary(shiny)\nrunExample()\n\n이 들 중 첫 번째 예제인 “01_hello”가 그림 3 에 나타나 있는 웹 앱이다. 해당 예제를 실행하려면 다음과 같이 하면 된다.\n\nrunExample(\"01_hello\")\n\n아래의 그림 6 와 같은 웹 앱이 생성된다. 이것을 그림 3 과 비교해 보라. 조금 다르다는 것을 쉽게 알아 챌 수 있는데(왼편 슬라이더바에서 &lt; 를 눌러보라.), 이것이 bslib 패키지를 활용하여 제작된 웹 앱이다.\n\n\n\n\n\n그림 6: bslib 패키지를 활용한 웹 앱의 예제\n\n\n웹 앱 뿐만 아니라 코드도 살펴보려면 다음과 같이 실행하면 된다.\n\nrunExample(\"01_hello\", display = \"showcase\")\n\n삽입되어 있는 설명 부분을 제거하고 코드만 남기면 다음과 같다. 이것을 그림 3 의 코드와 비교해 보라. 오로지 UI 부분의 코드만 다르고, 그것도 UI 함수명만 달라져 있다는 것을 알 수 있다(입력 함수, 출력 함수, 렌더링 함수는 그대로이다). 결국 bslib 패키지는 UI 구조만 바꾼다.\n\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_sidebar(\n  title = \"Hello Shiny!\",\n  sidebar = sidebar(\n    sliderInput(\n      inputId = \"bins\",\n      label = \"Number of bins:\",\n      min = 1,\n      max = 50,\n      value = 30\n    )\n  ),\n  plotOutput(outputId = \"distPlot\")\n)\n\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    x &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n    hist(\n      x,\n      breaks = bins,\n      col = \"#75AADB\",\n      border = \"white\",\n      xlab = \"Waiting time to next eruption (in mins)\",\n      main = \"Histogram of waiting times\"\n    )\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n첫째, page_sidebar()가 최상위 컨테이너 함수이다. page_sidebar()는 bslib에서 가장 널리 사용되는 페이지 컨테이너 함수로, 전체 너비를 차지하는 헤더(제목)와 사용자 입력을 위한 사이드바를 갖춘 대시보드형 UI 구조를 손쉽게 구성할 수 있도록 설계되었다. page_sidebar()함수는 전통적인 Shiny 컨테이너 함수 중 fluidPage(), titlePanel(), sidebarLayout() 함수의 역할을 동시에 수행한다고 생각할 수 있다.\n둘째, page_sidebar() 의 여러 인수가 전통적인 titlePanel() 함수와 sidebarLayout()의 하위 함수인 sidebarPanel() 함수를 대신한다.\n\ntitle: 대시보드의 제목을 설정할 수 있으며, titlePanel() 함수와 동일한 기능을 한다.\nsidebar = sidebar(): sidebarPanel() 함수와 동일한 기능을 한다. sidebarPanel() 함수 속에 입력 함수인 siderInput() 함수가 들어 있었던과 동일하게 sidebar() 속에 siderInput() 함수가 들어 있다.\n\n셋째, 전통적인 Shiny의 mainPanel() 함수 없이 출력 함수(plotOutput())가 막바로 사용된다. 그러나 이것은 가장 단순한 방식으로, 대표적인 컴포넌트 함수인 card() 함수를 사용하면 보다 풍성한 옵션을 사용할 수 있다. card() 함수 내부에서 card_header()와 card_body()라는 컴포넌트 함수를 활용한다. 아래는 위의 코드에 대해 두 가지 부가적인 조치를 한 것이다. 첫째, card() 함수를 통해 출력 표출 부분을 보완한다. 둘째, 기본 플롯 함수 대신 ggplot2 패키지를 통해 히스토그램을 작성하고 그것을 plotly 패키지의 ggplotly() 함수를 통해 인터랙티브 플롯을 생성한다. plotly 패키지의 출력 생성 및 출력 표출을 위해 renderPlotly({})와 plotlyOutput() 함수가 활용되는 점에 주목한다.\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(plotly)\n\nui &lt;- page_sidebar(\n  title = \"Hello Shiny!\",\n  sidebar = sidebar(\n    sliderInput(\n      inputId = \"bins\",\n      label = \"Number of bins:\",\n      min = 1,\n      max = 50,\n      value = 30\n    )\n  ),\n  card(\n    card_header(\"ggplot2: Histogram\"),\n    card_body(\n      plotlyOutput(outputId = \"distPlot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlotly({\n    x    &lt;- faithful[, 2]\n    gg &lt;- ggplot() +\n      geom_histogram(\n        aes(x = x), bins = input$bins, fill = 'darkgray', color = 'white'\n      ) +\n      labs(\n        x = 'Waiting time to next eruption (in mins)',\n        y = \"Frequencies\",\n        title = 'Histogram of waiting times'\n      )\n    ggplotly(gg)\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\n4.2 컨테이너 함수\n컨테이너 함수란 다른 UI 요소를 담되, 그 자체가 시각적 콘텐츠의 주제가 되지 않고 공간, 전환, 계층 구조를 정의하는 함수이다. 컨테이너 함수는 크게 세 가지로 나뉜다.\n\n페이지 컨테이너: 페이지 전체의 폭, 높이, 스크롤 방식 등 최상위 UI 구조를 정의하는 컨테이너로, page_*() 형태를 띤다.\n레이아웃 컨테이너: 페이지 내부에서 여러 UI 요소를 동시에 어떻게 배치할지를 결정하는 컨테이너로, layout_*() 형태를 띤다.\n내비게이션 컨테이너: 여러 UI 패널을 묶어 사용자 상호작용에 따라 표시되는 콘텐츠를 전환하는 컨테이너로, navset_*()의 형태를 띤다.\n\n분류별 컨테이너 함수를 정리하면 표 3 과 같다. 자세한 사항은 bslib 패키지 홈페이지의 Get Started나 Layouts를 참고할 수 있다.\n\n\n표 3: bslib 컨테이너 함수\n\n\n\n\n\n\n\n\n분류\n함수\n특징\n\n\n\n페이지 컨테이너(기본)\n\npage_fixed()\npage_fluid()\npage_fillable()\n\n\n고정형(고정폭: 940픽셀)\n유동형(웹페이지의 전체 폭)\n대시보드형(웹페이지의 전체 폭/높이)\n\n\n\n페이지 컨테이너(확장)\n\npage_sidebar()\npage_navbar()\n\n\n표준형(전역적 사이드바 포함)\n다중 페이지, nav_panel()의 집합\n\n\n\n레이아웃 컨테이너\n\nlayout_siderbar()\nlayout_columns()\nlayout_column_wrap()\n\n\npage_*(), card(), nav_panel() 내부\npage_sidebar() 내부\nnav_panel() 내부\n\n\n\n\n내비게이션 컨테이너\n(페이지/레이아웃 레벨)\n\n\nnavset_tab()\nnavset_pill()\nnavset_underline()\n\n\nnav_panel()의 집합\n\n\n\n내비게이션 컨테이너\n(카드 레벨)\n\n\nnavset_card_tab()\nnavset_card_pill()\nnavset_card_underline()\n\n\nnav_panel()의 집합\n\n\n\n\n\n\n우선 단일 페이지의 구조를 결정하는 가장 기본적인 페이지 컨테이너 함수에 page_fixed(), page_fluid(), page_fillable() 가 있다. page_fixed()는 중앙 정렬된 고정 폭 페이지 컨테이너이고, page_fluid()는 브라우저 폭에 따라 콘텐츠 영역이 유동적으로 변화는 페이지 컨테이너이고, page_fillable()는 브라우저의 가시 영역을 높이까지 포함해 채우도록 설계된 페이지 컨테이너이다. 그림 7 는 이 세가지 페이지 컨테이너를 개념적으로 비교하고 있다.\n\n\n\n\n\n그림 7: 페이지 컨테이너의 종류(https://shiny.posit.co/r/articles/build/layout-guide/)\n\n\n그러나 가장 중요한 페이지 컨테이너 함수는 page_sidebar()로 bslib 패키지의 표준이다. 이것은 페이지 전체를 채우는 구조 위에 사이드바-메인 영역 분할을 기본으로 제공하는 고수준 페이지 컨테이너이다. 단순히 예기하면 page_sidebar()는 page_fillable()과 레이아웃 컨테이너인 layout_siderbar()를 결합한 것으로 이해할 수 있다. page_navbar()는 상단 내비게이션 바를 페이지의 기본 구조로 표함하여, 여러 화면을 전환하는 앱을 구성하는 고수준 페이지 컨테이너이다. page_navbar()는 개념적으로 페이지 컨테이너와 내비게이션 컨테이너(navbar)을 통합한다.\n레이아웃 컨테이너는 페이지 전체가 아니라 페이지 내부 배치를 담당하는데, 페이지 컨테이너와 달리 중첩 사용이 가능하지만 콘텐츠 자체를 표현하지는 않는다. layout_siderbar()는 사이드바와 메인 콘텐츠 영역으로 화면을 이분하는 레이아웃 컨테이너를 생성하는데 page_*(), card(), nav_panel() 내부 어디에도 존재할 수 있다. layout_columns()는 여러 UI 요소를 동일 행 내의 다중 컬럼으로 배치하는 레이아웃 컨테이너를 생성한다. 컬럼의 수와 폭을 명시적으로 제어할 수 있으며 정돈된 레이아웃 구현에 용이하다. layout_column_wrap()은 컬럼을 행 단위로 자동 줄바꿈하여 반응형 배치를 제공하는 레이아웃 컨테이너이다. 컬럼 폭 기준으로 자동 배치하며 화면 크기에 따라 행 수가 동적으로 변한다.\n내비게이션 컨테이너는 여러 UI 패널을 묶어 사용자 상호작요에 따라 표시되는 콘텐츠를 전환하는 컨테이너로, 페이지 컨테이너나 레이아웃 컨테이너의 내부에서 사용된다. 한 번에 하나의 패널만 활성화되며, 공간 배치가 아니라 상태 전환을 담당한다. navset_tab(), navset_pill(), navset_underline()는 모두 nav_panel()들의 집합으로 구성되며, 콘텐츠 전환의 방식이 다를 뿐이다. navset_tab()는 전통적인 탭 모양을, navset_pill()는 둥근 필(pill) 모양의 버튼을, navset_underline()는 밑줄을 그은 형태를 제공한다. navset_card_tab(), navset_card_pill(), navset_card_underline()은 동일한 기능을 하지만 card 스타일을 기본으로 내장한 컨테이너이다. navset_*() 함수가 페이지 또는 레이아웃의 주요 내비게이션과 같은 비교적 상위 UI 계층에서 사용되는데 반해 navset_card_*() 함수는 주로 콘텐츠 블록 내부에 위치하여 카드 수준의 국소적 전환에 사용된다.\n\n4.3 UI 컴포넌트: 콘텐츠 구성 요소\nUI 컴포넌트는 UI 구조를 정의하지 않고, 컨테이너 내부에서 정보와 기능을 하나의 의미 있는 시각적 단위로 표현하는 재사용 가능한 UI 구성 요소이다. 컨테이너가 아니므로 구조에 관여하지 않으며, 사용자가 하나의 UI 플록으로 인식하는 부분이다. 컨테이너가 아니므로 페이지나 레이아웃 구조에 직접 관여하지 않으며, 사용자가 하나의 UI 블록으로 인식하는 부분을 이룬다. 이러한 컴포넌트는 여러 위치에서 반복 사용될 수 있고, 시각적 스타일과 의미를 함께 지닌다는 특징이 있다. bslib에서 제공하는 대표적인 콘텐츠 컴포넌트로는 카드(card), 사이드바(sidebar), 밸류 박스(value box), 툴팁(tooltip), 팝오버(popover) 등이 있다. 보다 자세한 내용은 bslib 패키지 공식 홈페이지의 Components 섹션을 참고할 수 있다.\n\n4.3.1 카드\n카드(card)는 현대적인 UI에서 가장 널리 사용되는 정보 구성 단위 중 하나이다. 기본적으로 카드는 테두리와 여백을 갖는 직사각형 컨테이너에 불과하지만, 관련된 정보를 의미 있게 묶어 제시할 경우 사용자가 내용을 보다 쉽게 이해하고, 집중하며, 탐색할 수 있도록 돕는다. 이러한 특성 때문에 카드는 대시보드와 UI 설계에서 핵심적인 역할을 하며, 대부분의 성공적인 대시보드 및 UI 프레임워크는 카드를 주요 컴포넌트로 채택하고 있다. card() 함수는 다음과 같은 컴포넌트 함수를 갖는다.\n\ncard_header(): 제목\ncard_body(): 주 콘텐츠(생략 가능: 바로 출력 표출 함수 표시 가능)\ncard_footer(): 부가 설명\n\n4.3.2 사이드바\n사이드바(sidebar)는 필터, 설정, 기타 입력 요소를 사용자가 쉽게 접근할 수 있도록 제공하는 핵심 UI 컴포넌트로, 이들이 제어하는 대화형 기능과 나란히 배치된다는 점이 특징이다. 사이드바를 활용하면 사용자 입력과 결과 출력 간의 관계를 명확히 할 수 있어, 대시보드의 사용성과 탐색성이 크게 향상된다. bslib에서는 page_sidebar()와 page_navbar() 함수를 통해 페이지 수준(page-level)의 사이드바 레이아웃을 기본적으로 제공하며, 이 외에도 다양한 형태의 사이드바 레이아웃을 지원하여 인터페이스의 목적과 복잡도에 따라 유연한 UI 설계를 가능하게 한다.\n\n\n\n\n\n\n노트사이드바 컴포넌트와 사이드바 레이아웃\n\n\n\n\n\n사이드바 컴포넌트와 사이드바 레이아웃은 다르다. 사이드바 레이아웃은 공간을 나누는 구 조를 의미한다면, 사이드바 컴포넌트는 콘텐츠를 담는 UI 블록이다. 입력 위젯, 텍스트, 메뉴 등이 포함되며 독립적인 UI가 의미가 있다. 사이드바 레이아웃의 중요 함수에는 앞에서 살펴본 것과 같은 page_sidebar(), layout_sidebar() 등이 있고, 사이드바 컴포넌트의 대표적인 함수에 sidebar()가 있다.\nbslib에서 제공하는 사이드바 레이아웃은 크게 부유형(floating), 채움형(filling), 다중 페이지/탭형(multi-page/tab)의 세 가지로 구분할 수 있다.\n부유형 레이아웃은 layout_sidebar()를 사용하는데, 페이지의 어느 위치에나 배치할 수 있는 사이드바 레이아웃을 구성할 수 있다. 이 방식은 의미적으로 관련된 입력 요소와 출력 요소를 시각적으로 함께 묶어 제시하는 데 적합하다. 또한 card()와 함께 사용하면 전체 화면 확장(full-screen), 헤더·푸터 추가 등 카드가 제공하는 다양한 기능을 활용할 수 있다.\n채움형 레이아웃은 page_sidebar()를 사용하는데 페이지 전체를 채우는 사이드바 레이아웃을 생성한다. 내부적으로 page_sidebar()는 page_fillable()과 layout_sidebar()를 단순히 감싼(wrapper) 함수에 불과하다. 이 구조를 이해하면, 하나의 채움형 레이아웃 안에 여러 개의 사이드바 레이아웃을 유연하게 배치할 수 있는 가능성이 열린다.\n다중 페이지/탭 레이아웃은 page_navbar()나 navset_card_tab() 내부에서 sidebar 인수를 사용해 사이드바를 구성할 수 있다. 이 경우 사이드바는 페이지 전체를 채우는 동시에, 모든 페이지나 탭에서 동일하게 유지되어 표시된다. 이후에는 페이지별로 서로 다른 레이아웃을 구성하는 방법도 다루겠지만, 모든 페이지에서 동일한 사이드바를 사용하는 것이 바람직한 경우도 많다. 이러한 경우에는 conditionalPanel()을 활용하여 특정 페이지에서만 사이드바의 일부 내용을 표시하거나 숨길 수 있다.\n\n\n\n\n4.3.3 밸류 박스\n밸류 박스(value box)는 대시보드에서 핵심적인 수치나 지표를 한눈에 전달하기 위해 사용되는 UI 컴포넌트이다. 값(value), 설명(label), 아이콘(icon) 등을 함께 제시하여 사용자가 현재 상태나 주요 변화를 빠르게 파악할 수 있도록 돕는다. bslib의 value_box() 함수는 카드(card) 기반 설계를 따르므로 다른 UI 요소들과 시각적으로 일관되게 어우러지며, Shiny의 반응성과 결합해 값이 동적으로 갱신되는 대시보드를 구성하는 데 특히 유용하다.\nvalue_box() 함수는 네 가지 주요 구성 요소로 이루어진다.\n\nvalue는 표시하고자 하는 핵심 수치나 텍스트 값으로, 대시보드에서 가장 중요한 정보를 전달한다. 출력 표출 함수를 사용할 수도 있다.\ntitle은 value 위에 선택적으로 표시되는 설명 텍스트로, 해당 값의 의미나 지표명을 명확히 한다.\nshowcase는 아이콘이나 기타 UI 요소와 같이 value 옆에 함께 배치되는 시각적 요소로, 정보를 보다 직관적으로 인식하도록 돕는다. bs_icon() 컴포넌트 함수를 주로 사용한다.\ntheme은 값 상자의 색상이나 스타일을 조정하는 선택적 설정으로, 대시보드의 전체 디자인과 시각적 일관성을 유지하거나 강조 효과를 줄 수 있다.\n\n4.3.4 툴팁과 팝오버\n툴팁(tooltip)과 팝오버(popover)는 화면을 방해하지 않으면서 추가 정보를 제공하거나 상호작용을 가능하게 하는 유용한 UI 요소이다. 툴팁은 주로 간단한 설명을 표시하는 데 사용되며, 팝오버는 보다 풍부한 정보 제공이나 사용자 입력을 포함한 상호작용을 지원한다. 예를 들어, card_header()에 “도움말” 아이콘과 함께 tooltip()을 부착하면 사용자가 시각화된 데이터에 대한 추가 설명을 손쉽게 확인할 수 있다. 또한 동일한 헤더 영역에 “설정” 아이콘과 popover()를 연결하면 시각화의 매개변수를 직접 제어할 수 있는 인터페이스를 제공할 수 있다. 더 나아가 card_footer()의 링크에 popover()를 적용하면 추가 정보의 표시뿐 아니라 하이퍼링크와 같은 상호작용 요소를 함께 제공할 수 있어, 정보 탐색과 사용자 경험을 동시에 향상시킨다.\n구현 방식 측면에서 보면, 툴팁과 팝오버는 매우 유사하다. 두 컴포넌트 모두 사용자의 상호작용을 통해 표시 여부가 전환되는 트리거(trigger) UI 요소와, 화면에 표시될 메시지 내용을 필요로 한다. tooltip()과 popover()는 공통적으로 첫 번째 인수를 트리거로 취급하며, 이름이 지정되지 않은 나머지 인수들은 메시지 내용으로 사용된다. 또한 popover()의 경우에는 선택적으로 제목(title)을 함께 지정할 수 있다.\n반면, 사용자 경험(UX)과 활용 목적 측면에서는 두 컴포넌트의 성격이 뚜렷이 다르다. 툴팁은 포커스나 마우스 오버(hover)에 의해 표시되는 반면, 팝오버는 클릭을 통해 열리고 닫힌다. 이로 인해 팝오버는 툴팁보다 화면에 더 오래 유지되는, 즉 상대적으로 지속성이 높은 인터페이스이며, 추가적인 사용자 상호작용이 필요한 경우에 적합하다. 따라서 간단한 설명과 같은 읽기 전용(read-only) 정보에는 툴팁을 사용하는 것이 바람직하고, 메시지 자체와의 상호작용이 필요한 경우에는 팝오버를 사용하는 것이 적절하다.\n\n4.4 사용자 정의 테마\nbslib 패키지의 또 다른 중요한 기능은 다양한 사용자 정의 테마(custom themeing)의 적용을 용이하게 한다는 점이다. bslib는 Bootstrap 5를 기반으로 한 테마 시스템을 추상화하여, 사용자가 색상, 타이포그래피, 여백, 컴포넌트 스타일 등 핵심 디자인 요소를 일관된 방식으로 제어할 수 있도록 지원한다. 특히 bs_theme()를 중심으로 한 테마 정의 방식은 개별 UI 요소를 일일이 스타일링하는 접근에서 벗어나, 디자인 전반을 하나의 체계적인 설정으로 관리할 수 있게 해준다. 이를 통해 인터랙티브 대시보드나 웹 애플리케이션의 시각적 일관성을 유지하면서도, 목적과 사용자 맥락에 맞는 다양한 테마를 손쉽게 적용할 수 있다. 이러한 사용자 정의 테마 기능은 bslib를 단순한 UI 구성 도구를 넘어, 재현 가능하고 확장 가능한 시각적 설계 도구로 자리매김하게 하는 핵심 요소라 할 수 있다.\n\n4.4.1 bs_theme() 함수\nbs_theme() 함수는 bslib 패키지에서 사용자 정의 테마를 정의하는 핵심 함수로, Bootstrap 기반 UI의 시각적 전반을 하나의 설정 객체로 통합 관리한다. 즉, bs_theme() 함수는 색상, 글꼴, 여백, 컴포넌트 스타일 등 UI 전반의 디자인 규칙을 한 번에 정의하고 이를 Shiny 앱 전체에 일관되게 적요하도록 해주는 테마 객체 생성 함수이다.\nbs_theme() 함수의 주요 인수는 다음과 같다.\n\nversion = 5: 사용할 Bootstrap 버전으로 5가 기본값\nbg = \"#ffffff\", fg = \"#212529\": 기본 배경색 및 기본 텍스트 색상\nprimary = \"#0d6efd\", secondary = \"\", success = \"\", info = \"\", warning = \"\", danger = \"\": Bootstrap의 의미 기반 색상 체계\nbase_font = font_google(\"Noto Sans KR\"), heading_font = font_google(\"Noto Serif KR\"), code_font = font_google(\"JetBrains Mono\"): 본문 텍스트, 제목, 코드 블록의 타이포그래피 일관성 확보\nbase_font_size = \"1rem\": 기본 글자 크기로 rem 단위 사용이 권장 된다.\nspacer = \"1rem\": 여백의 기준 단위\nborder_radius = \"0.5rem\": 카드, 버튼 등의 모서리 둥글기\nbootswatch = \"flatly\": 미리 정의된 Bootswatch 테마\n\n4.4.2 테마 미리보기 및 검증\nbslib 패키지의 bs_theme_preview() 함수는 사용자 정의 테마를 실제 UI 구성 요소에 적용해 보며 시각적 효과를 즉시 확인할 수 있는 테마 미리보기 및 검증 도구이다.\n콘솔에서 함수를 실행하면, 버튼, 카드, 입력 위젯 등 대표 UI 컴포넌트에 테마를 적용해볼 수 있고, 색상 대비, 타이포그래피, 여백 등을 한눈에 점검할 수 있을 뿐만 아니라, 테마 수정의 결과를 즉시 확인해 볼 수 있다. 그림 8 에서 볼 수 있는 것처럼 오른편의 Theme customizer를 조작하여 이러한 기능을 활용해 볼 수 있다.\n\n\n\n\n\n그림 8: be_theme_update() 함수를 활용한 테마 미리보기 및 검증",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "lab_01_2025.html",
    "href": "lab_01_2025.html",
    "title": "R and RStudio",
    "section": "",
    "text": "여기서는 R과 RStudio의 기본기를 다진다. 다음과 같은 사항이 다루어진다.\n1. R과 RStudio 설치\n2. RStudio 둘러보기\n3. 프로젝트와 스크립트 개념 이해하기\n\n\n\n\n\n\n경고\n\n\n\nR은 실행과정에서 폴더 경로에 한글이 포함된 경우 오류가 자주 발생한다. 따라서 사용자 계정 이름이 한국어로 설정되어 있지 않은지 반드시 확인해야 하며, 앞으로 만들 프로젝트 폴더 등도 이름을 모두 영어로 설정하는 것이 좋다.\nWindows: [설정] -&gt; [계정] -&gt; [사용자 정보]로 들어가 볼드체로 된 사용자 계정 이름이 영어인지 확인하기. 사용자 계정이 한국어로 설정되어 있다면 영어로 된 새로운 윈도우 사용자 계정을 만들어야 한다.\nMac: 프로젝트 폴더 이름 설정만 잘 신경쓰면 된다.",
    "crumbs": [
      "R 실습: 2025/2",
      "R and RStudio"
    ]
  },
  {
    "objectID": "lab_01_2025.html#개요",
    "href": "lab_01_2025.html#개요",
    "title": "R and RStudio",
    "section": "",
    "text": "여기서는 R과 RStudio의 기본기를 다진다. 다음과 같은 사항이 다루어진다.\n1. R과 RStudio 설치\n2. RStudio 둘러보기\n3. 프로젝트와 스크립트 개념 이해하기\n\n\n\n\n\n\n경고\n\n\n\nR은 실행과정에서 폴더 경로에 한글이 포함된 경우 오류가 자주 발생한다. 따라서 사용자 계정 이름이 한국어로 설정되어 있지 않은지 반드시 확인해야 하며, 앞으로 만들 프로젝트 폴더 등도 이름을 모두 영어로 설정하는 것이 좋다.\nWindows: [설정] -&gt; [계정] -&gt; [사용자 정보]로 들어가 볼드체로 된 사용자 계정 이름이 영어인지 확인하기. 사용자 계정이 한국어로 설정되어 있다면 영어로 된 새로운 윈도우 사용자 계정을 만들어야 한다.\nMac: 프로젝트 폴더 이름 설정만 잘 신경쓰면 된다.",
    "crumbs": [
      "R 실습: 2025/2",
      "R and RStudio"
    ]
  },
  {
    "objectID": "lab_01_2025.html#r과-rstudio-설치",
    "href": "lab_01_2025.html#r과-rstudio-설치",
    "title": "R and RStudio",
    "section": "\n1 R과 RStudio 설치",
    "text": "1 R과 RStudio 설치\n프로그램을 다운로드하기 위해 다음의 웹사이트로 이동한다. 여기는 RStudio를 만든 posit(과거에는 회사명 자체도 RStudio였음)이라는 회사가 관리하는 RStudio Desktop 다운로드 페이지이다.\n그러면 그림 1 과 같이 R과 RStudio를 설치할 수 있는 화면이 나타날 것이다.\n\n\n\n\n\n그림 1: 다운로드 화면\n\n\n\n1.1 R의 설치\n왼쪽의 다운로드 바를 클릭하면 CRAN(The Comprehensive R Archive Network)으로 이동한다. 자신의 운영체계에 맞는 R의 최신 버전을 다운로드하고 자신의 디바이스에 설치한다. 이 다큐먼트 작성 시점 기준으로 R의 최신 버전은 4.5.1이다.\n\n\n\n\n\n\n노트\n\n\n\nCRAN은 R의 핵심 소프트웨어 저장소(software repository)이다. R 프로그램 자체의 과거와 현재의 버전들 뿐만 아니라 수많은 R 패키지(package)(현재 대략 20,000개)가 모여 있는 곳이다. 1997년 Kurt Hornik와 Friedrich Leisch에 의해 처음 만들어졌으며, 현재에도 Hornik와 많은 자원봉사자들에 의해 운영되고 있다. 자세한 사항은 Wikipedia를 참조할 수 있다.\n\n\n\n1.2 RStudio의 설치\nR의 지배적인 IDE(Integrated Development Environment, 통합개발환경)인 RStudio를 설치한다. 다시 원래의 다운로드 페이지로 돌아와, 오른편의 다운로드 바를 클릭하면 윈도우즈용 RStudio의 파일을 다운로드할 수 있다. 스크롤 다운하면 다른 운영체계를 위한 RStudio를 다운로드할 수 있다. 다운받은 RStudio를 자신의 디바이스에 설치한다. 이 다큐먼트 작성 시점 기준으로 RStudio의 최신 버전은 2025년 5월 1일에 발표된 2025.05.1+513이다.\nRStudio는 R만을 위한 IDE인데, posit은 최근 R과 Python 모두를 사용할 수 있는 범용 IDE인 Positron을 개발하였다. 2025년 7월 3일에 베타 버전을 끝내고 정식 출시했으며, 현재는 2025년 8월 14일에 출시된 2025.08.0-130이 최신 버전이다. Positron은 RStudio와 Python에서 많이 사용되는 VS Code를 결합한 것으로, 향상된 기능과 외견이 기대된다. 2026년부터는 RStudio에서 Positron으로의 이동이 본격화될 것이다. Positron을 살펴보는데 아래의 동영상이 도움이 될 것이다.",
    "crumbs": [
      "R 실습: 2025/2",
      "R and RStudio"
    ]
  },
  {
    "objectID": "lab_01_2025.html#rstudio-둘러보기",
    "href": "lab_01_2025.html#rstudio-둘러보기",
    "title": "R and RStudio",
    "section": "\n2 RStudio 둘러보기",
    "text": "2 RStudio 둘러보기\n\n2.1 창(pane, 패인)\nRStudio를 실행하면 아마도 대부분의 경우 그림 2 와 같은 화면을 보게 될 것이다. 크게 세 개의 창으로 구성되어 있음을 알 수 있다.\n\n\n\n\n\n그림 2: 세 개의 창\n\n\n왼편에 가장 크게 나타나 있는 것을 Console 창(pane)이라고 부르고, 우하의 창은 Output 창 혹은 File 창이라고 부른다. 우상에도 또 다른 창이 하나 보이는데 보통 Environment 창이라고 부른다.\n\n\n\n\n\n\n노트\n\n\n\n개별 창은 여러 개의 탭(tab)으로 구성되어 있는데, 탭의 기능이 매우 다양하기 때문에 소속 탭의 모든 기능을 포괄하는 일관성 있는 창 이름을 붙이는 것이 매우 어렵다. 예를 들어 Output 창의 경우 Plots와 Viewer 탭은 결과물을 보여주는 것이라 할 수 있지만 나머지 탭은 꼭 그렇지도 않다.\n\n\n\n2.2 Console 창에서 놀아보기\n여기서는 Console 창을 통해 R의 가장 기본적인 다음의 개념들에 대해 알아보고자 한다. Console 창은 R에서 CLI(command-line interface, 명령줄(어) 인터페이스) 역할을 하는 가장 핵심적인 부분이다. 사용자가 프로그램을 통해 컴퓨터와 상호작용하는 인터페이스이다.\n\n프롬프트(prompt): 명령 프롬프트(command prompt)라고도 불리는 것으로, CLI에서 명령어 대기 상태를 나타내는 일종의 부호이다. R에서는 &gt;를 사용한다.\n할당(assignment): 값을 식별자(identifier)를 가진 객체로 전환하는 과정을 의미한다. 프로그래밍 언어는 할당을 위한 고유한 연산자(operator)를 가지고 있는데, R은 &lt;-을 사용한다. =도 동일한 기능을 하는데, 권장하지는 않는다.\n객체(object): 값을 품고 있는, 식별자를 가진, 메모리 상의 기본 단위\n함수(function): 특정 동작을 수행하는 코드 블록을 의미한다. 인풋을 함수에 적용하면 함수의 고유한 동작을 통해 아웃풋이 산출된다.\n벡터(vector): 숫자의 일차원적 집합으로 보통 개별 행(row) 혹은 개별 열(column)을 의미한다.\n데이터 프레임(data frame): 하나 이상의 벡터를 모아 둔 숫자의 2차원적 집합으로, 다수의 행과 다수의 열로 이루어진 테이블을 의미한다. 이것이 보통 우리가 데이터셋이라고 부르는 것이다.\n\n\n2.2.1 프롬프트, 할당, 객체\n콘솔 창에 R 프롬프트인 &gt;가 나타나 있을 것이다. 아래와 같이 숫자 1을 타이핑하고 실행을 위해 [enter] 키를 누른다.\n\n1\n\n[1] 1\n\n\n간단한 연산을 해본다. 사실 R은 기본적으로 계산기이다.\n\n1 + 2\n\n[1] 3\n\n\n이제 할당 연산자(&lt;-)를 활용하여 할당을 해보자.\n\na &lt;- 1\n\n우상의 Environment 창을 보면 뭔가 생성된 것을 확인할 수 있을 것이다. a라는 객체가 생성되었으며 그것은 1이라는 값을 품고 있다는 의미이다. 이제 a는 알파벳 소문자가 아니라 1이라는 숫자와 필연적으로 결합해 있는 객체이다. 다음을 실행하면 이러한 사실을 보다 명확히 확인할 수 있다.\n\n\n\n\n\n\n노트\n\n\n\n할당 연산자의 단축키는 Alt + _ 이다. 가장 많이 사용하게 될 단축키 중의 하나이다. 이 단축키를 사용하면 좋은 점 중의 하나는 전후에 빈 공간이 자동적으로 생성된다는 점이다. 따라서 객체 이름 다음에 할당 연산자를 사용하기 위해 스페이스바를 사용할 필요가 없다.\n\n\n\na\n\n[1] 1\n\n\n아래와 같이 하면 객체끼리의 연산이 가능하다.\n\nb &lt;- 2\nc &lt;- a + b\nc\n\n[1] 3\n\n\nBase R에는 할당 연사자 외에도 여러 연산자가 존재한다. 이를 정리하면 다음과 같다.\n\n\n\n\n\n\n\n\n범주\n연산자\n설명\n예시\n\n\n\n할당(assignment) 연산자\n\n&lt;- 혹은 -&gt;\n\n데이터를 객체에 할당\na &lt;- 5\n\n\n수리(arithmetic) 연산자\n+\n더하기(addition)\n5 + 5 = 10\n\n\n\n-\n빼기(subtraction)\n5 - 5 = 0\n\n\n\n*\n곱하기(multiplication)\n2 * 8 = 16\n\n\n\n/\n나누기(division)\n100 / 10 = 10\n\n\n\n\n^ 혹은 **\n\n제곱(exponent/power)\n5^2 = 25\n\n\n\n%%\n나머지(modulo)\n100 %% 15 = 10\n\n\n\n%/%\n몫(integer division)\n100 %/% 15 = 6\n\n\n관계(relational) 연산자\nx &lt; y\nx가 y보다 작은 경우\n3 &lt; 4 TRUE\n\n\n\n\nx &gt; y\nx가 y보다 큰 경우\n3 &gt; 4 FALSE\n\n\n\n\nx &lt;= y\nx가 y보다 작거나 같은 경우\n3 &lt;= 4 TRUE\n\n\n\n\nx &gt;= y\nx가 y보다 크거나 같은 경우\n3 &gt;= 4 FALSE\n\n\n\n\nx == y\nx와 y가 같은 경우\n3 == 4 FALSE\n\n\n\n\nx != y\nx와 y가 다른 경우\n3 != 4 TRUE\n\n\n\n논리(logical) 연산자\n!\n논리 부정(negation)\n\n\n\n\n&\n논리곱(logical “and”)\n\n\n\n\n|\n논리합(logical “or”)\n\n\n\n\nxor\n배타적 논리합(logical “exclusive or”)\n\n\n\n기타 연산자\nx %in% y\n원소 포함\n벡터 x의 각 원소가 y 안에 존재하는지 확인\n\n\n\n!(x %in% y)\n원소 비포함\n벡터 x의 각 원소가 y 안에 존재하지 않는지 확인\n\n\n\n2.2.2 함수\nsum() 함수를 사용하여 동일한 연산을 할 수 있다. sum()은 R에 기본적으로 내장되어 있는 Base R 함수 중 하나이다.\n\nsum(a, b)\n\n[1] 3\n\n\n\n\n\n\n\n\n중요\n\n\n\n지금부터 모든 함수명에는 항상 ()를 연결하여 나타낼 것이다. 다른 객체명과의 혼동을 방지하기 위한 것도 있지만, 모든 함수는 () 속에 인풋(이것을 인자(argument)라고 부른다)을 받아들이기 때문이다.\n\n\nR에는 수많은 내장 함수가 있다. 그 중 몇가지만 실행하면 다음과 같다. sqrt()는 제곱근을, abs()는 절대값을, log10()는 밑을 10으로 하는 로그값을 산출해준다.\n\nsqrt(2)\n\n[1] 1.414214\n\nabs(-3)\n\n[1] 3\n\nlog10(100)\n\n[1] 2\n\n\nBase R에서 사용되는 주요 내장 함수를 정리하면 다음과 같다.\n\n\n\n\n\n\n\n범주\n구분\n함수\n\n\n\n논리형 판별 함수\n결측치 여부\n\nis.na(), is.nan(), is.infinite(), is.finite()\n\n\n\n\n유형 확인\n\nis.numeric(), is.integer(), is.character(), is.logical(), is.factor()\n\n\n\n\n구조 확인\n\nis.data.frame(), is.matrix(), is.list(), is.vector()\n\n\n\n\n기타\n\nis.null(), is.atomic(), is.element()\n\n\n\n위치 기반 추출 함수\n첫 번째 원소\nx[1]\n\n\n\n마지막 원소\nx[length(x)]\n\n\n\nn번째 원소\nx[n]\n\n\n\n앞의 몇 개의 원소\nhead()\n\n\n\n뒤의 몇 개의 원소\ntail()\n\n\n수학 함수\n절댓값/부호\n\nabs(), sign()\n\n\n\n\n제곱근/지수\n\nsqrt(), exp()\n\n\n\n\n로그\n\nlog(), log10(), log2()\n\n\n\n\n삼각함수\n\nsin(), cos(), tan(), asin()\n\n\n\n\n반올림\n\nround(), floor(), ceiling(), trunc()\n\n\n\n\n요약\n\nsum(), mean(), median(), var(), sd(), min(), max(), range(), summary()\n\n\n\n벡터 생성 함수\n수열/반복\n\nseq(), rep()\n\n\n\n\n특정 유형\n\nnumeric(), integer(), logical(), character()\n\n\n\n\n난수/표본 생성\n\nsample(), rnorm(), runif(), rbinom()\n\n\n\n집합 연산 함수\n합집합\nunion()\n\n\n\n교집합\nintersect()\n\n\n\n차집합\nsetdiff()\n\n\n\n동일 여부\nsetequal()\n\n\n\n원소 포함 여부\nis.element()\n\n\n변환 함수\n유형 변환\n\nas.numeric(), as.character(), as.factor(), as.data.frame()\n\n\n\n\n재코딩/재배열\n\ncut(), relevel(), reorder()\n\n\n\n\n표준화\nscale()\n\n\n기타 함수\n길이\nlength()\n\n\n\n정렬\n\nsort(), order()\n\n\n\n\n중복 처리\n\nunique(), duplicated()\n\n\n\n\n결측치 처리\nna.omit()\n\n\n\n\n\n\n\n\n\n노트\n\n\n\n최근 tidyverse 패키지의 사용이 활발해 지면서 이러한 Base R 함수의 활용에 약간의 변동이 발생하고 있다. tidyverse 패키지는 타이디버스 디자인 원리에 의거해 새로운 함수를 디자인하여 제공하고 있다. 이러한 타이디버스 함수가 Base R 함수나 기존의 패키지의 함수를 대체해 나가고 있는 실정이다. 여전히 많은 사람이 여기에 열거되어 있는 Base R의 기본 함수를 사용하고, 그러한 문법에 따라 코드를 작성하고 있다. 나는 타이디버스가 R의 미래라고 확신하며 가능한 코드를 타이디버스 함수를 이용해 작성하도록 노력할 것이다. 여기서 Base R의 함수는 기본적으로 벡터에 적용되는 함수이고, 타이디버스 함수는 데이터 프레임에 적용되는 함수라는 점을 명확히 할 필요가 있다. 따라서 타이디버스에서 벡터 연산을 할 때는 위에서 열거한 많은 함수를 그대로 사용한다. 특히, 논리형 판별 함수와 수학 함수는 그대로 사용하고 있다. 집합 연산 함수는 이름은 동일하지만 사실 새롭게 디자인한 함수이다. 타이디버스는 새로운 데이터 프레임 기반 함수를 통해 기존의 벡터 기반 함수가 하는 일을 대체하고자 한다. 그렇지만 모든 코드를 데이터 프레임 함수로만 작성할 수 없고, Base R의 여러 벡터 함수는 여전히 유용하게 사용되고 있다. 타이디버스가 부가적으로 제공하는 벡터 함수에 대해서는 다른 장에서 다루도록 한다.\n\n\n\n2.2.3 벡터와 데이터 프레임\n위에서 살펴본 숫자 하나하나는 큰 의미가 없다. 우리는 보통 숫자의 집합(array), 즉 벡터를 다룬다.\n\na &lt;- c(29, 27, 23)\nb &lt;- c(29L, 27L, 23L)\nc &lt;- c(TRUE, TRUE, FALSE)\nd &lt;- c(\"이하은\", \"김우형\", \"박서우\")\n\na, b, c, d는 모두 벡터이다. 우상의 Environment 창에서도 이러한 사실을 확인할 수 있다. 그런데, 이 세가지 벡터는 데이터의 유형(type)이라는 측면에서 서로 다르다. a는 숫자형(numeric), b는 정수형(integer), c는 논리형(logical), d는 문자형(character)이다. Environment 창을 보면, a에 대해서는 num, b에 대해서는 int, c에 대해서는 logi, d에 대해서는 chr이라는 축약어가 붙어 있음을 알 수 있는데, 이것이 바로 벡터의 유형을 나타내고 있는 것이다. 사실 R에서 다루는 벡터의 유형은 10가지가 넘는다.\n\n\n\n\n\n\n노트\n\n\n\ntidyverse 패키지의 핵심 패키지 중의 하나인 tibble 패키지에서 규정된 데이터 유형에 대해서는 다음의 웹사이트를 참고할 수 있다. https://tibble.tidyverse.org/articles/types.html\n\n\n벡터를 data.frame()이라는 함수를 통해 결합하면 데이터 프레임을 만들 수 있다.\n\ndf &lt;- data.frame(a, b, c, d)\ndf\n\n   a  b     c      d\n1 29 29  TRUE 이하은\n2 27 27  TRUE 김우형\n3 23 23 FALSE 박서우\n\n\n우상의 Environment 창을 보면 뭔가 변화가 있음을 확인할 수 있을 것이다. Data가 생겼고 그 아래에 df가 생성되어 있을 것이다. “3 obs. of 4 variables”라는 말이 굉장히 중요하다. 이것은 df라는 데이터 프레임 객체가 3개의 관측 개체(observations)와 4개의 변수(variables)로 구성되어 있다는 것을 의미한다. 데이터 프레임, 관측 개체, 변수에 대해서는 강의에서 상세하게 다룬다.\nEnvironment 창에서 df를 클릭해보라. 그러면 왼편에 또 하나의 창이 생기면서 마치 엑셀과 같은 형식으로 데이터가 나타날 것이다. View() 함수를 실행해도 동일한 결과를 얻을 수 있다.\n\nView(df)\n\n여기서 중요한 것은 새로 생긴 창이다. 이것을 보통 Editor 창이라고 부른다. 이제부터 Console은 부차적인 목적으로만 사용할 것이고 Editor 창이 주인공이 된다.",
    "crumbs": [
      "R 실습: 2025/2",
      "R and RStudio"
    ]
  },
  {
    "objectID": "lab_01_2025.html#프로젝트project와-스크립트script",
    "href": "lab_01_2025.html#프로젝트project와-스크립트script",
    "title": "R and RStudio",
    "section": "\n3 프로젝트(project)와 스크립트(script)",
    "text": "3 프로젝트(project)와 스크립트(script)\n\n3.1 프로젝트 만들기\n\n3.1.1 R 프로젝트의 개념\nRStudio에서 프로젝트란 한 단위의 R 과업을 의미한다. 매우 단순한 과업도 있겠지만, 보통 데이터를 읽고, 정돈하고, 변형하고, 시각화하고, 모델링하는 등의 다양한 활동이 개입된다. 하나의 일관된 목적을 위해 이러한 다양한 일을 한다면, 이것들을 한데 모아 함께 관리하는 것이 좋을 것이다. 프로젝트는 하나의 과업을 위해 당신이 행한 모든 것이 체계적으로 정돈되어 있는 가상의 방이다. 좀 이질적인 과업을 하게 된다면 기존의 프로젝트 속에서 하기 보다는 또 다른 프로젝트를 만들어 그 속에서 하는 것이 효과적일 것이다.\nRStudio의 프로젝트는 실질적으로 하나의 폴더를 의미한다. 하나의 폴더 속에 모든 활동과 그것의 인풋 및 아웃풋이 모두 저장되고, RStudio는 그것을 체계적으로 관리할 수 있게 해주는 툴을 제공한다.\n다음과 같은 관행을 추천한다.\n\n디바이스에 모든 R 프로젝트를 포괄하는 최상위 폴더를 만든다. 걸맞는 폴더명(예: R_Projects)을 부여한다. 이것은 R 외부에서 미리 해둔다. 물론 Output 창의 Files 탭을 이용하면 R 내부에서도 할 수 있다.\n최상위 폴더 아래에 개별 R 프로젝트를 위한 폴더를 만든다. 과업에 걸맞는 폴더명(예: AI_Class_2025)을 부여한다. 이것을 R 외부에서 미리 해둘 수도 있고, R 내부에서 프로젝트를 생성할 때 할 수도 있다. 후자를 추천한다.\n\n3.1.2 R 프로젝트 만들기\n두 가지 방법이 있다.\n\n최상단 메뉴를 이용: File &gt; New Project\n상단 메뉴바 오른쪽 맨끝에 있는 작은 화살표 아이콘: New Project\n\n그림 3 에 나타나 있는 절차를 통해 프로젝트를 생성한다. 각각 다음의 단계를 거친다.\n\n1단계: 과제 폴더(디렉토리)를 미리 만들어 두지 않았다면, New Directory를 선택한다(추천). 그렇지 않았다면 Existing Directory를 선택한다.\n2단계: New Project를 선택한다.\n3단계: ’Directory name:’에 과제를 위한 폴더명을 타이핑한다(예: AI_Class_2025). ’Create project as subdirectory of:’에 최상위 폴더(예: R_Projects)를 선택한다.\n\n\n\n\n\n\n그림 3: R 프로젝트의 생성 절차\n\n\nOutput 창의 Files 탭을 누르면, 다양한 기본 파일들이 해당 폴드에 생성되었음을 확인할 수 있다. 가장 중요한 파일은 .RProj라는 확장자를 가진 파일이다. 나중에 R 외부에서 이 파일을 더블클릭하면 R 프로젝트를 열 수 있다.\n\n\n\n\n\n\n힌트\n\n\n\n\n\nR 외부의 파일 관리 시스템(윈도우즈의 경우 파일 탐색기)를 사용하지 말고, Output 창의 Files 탭을 사용하는 것이 훨씬 유용하다. 파일 탐색기에서 제공하는 거의 대부분의 기능을 제공한다.\n\n\n\n\n3.1.3 옵션의 변경\nRStudio의 기본 세팅값을 바꿀 수 있는 다양한 옵션이 존재한다. Tools &gt; Global Options를 선택하면 그림 4 과 같은 화면을 볼 수 있을 것이다. 다음의 두 가지를 해보라.\n\n자신이 좀 숙달된 R 사용자가 되었다고 판단되는 즈음에, 가운데 Workspace 부분을 그림과 동일하게 변경해보라. 디폴트는 체크가 되어 있는 것인데, 프로젝트를 다시 열었을 때 그 전에 만들어 둔 데이터나 객체가 모두 그대로 남아있게 한다. 초보자에게는 이것이 좋을 것이다. 그러나 새로운 세션을 시작할 때 마다 그 전의 흔적을 밀어버리고, 다시 모든 코드를 실행하여 결과를 새로이 얻는 것이, 프로그래밍 측면에서는 ‘완전한’ 일이다.\n왼쪽에서 Apearance를 선택한 후, ’Editor font size:’나 ’Editor theme’을 변경하여 자신의 선호를 반영하라.\n\n\n\n\n\n\n그림 4: 옵션의 변경\n\n\n\n3.2 스크립트 만들기\n\n3.2.1 Console에서 Script Editor로\nConsole은 명령어를 입력하고 그 결과를 볼 수 있는 곳이다. 이것은 Base R의 기본 기능을 RStudio가 충실하게 구현한 것이다. 그런데 제법 복잡한 R 프로젝트를 수행하고자 할 때 Console을 이용하는 방식은 제한점이 많다.\n\n다양하고 복잡한 R 명령어를 실행하고 그 결과를 보기에는 공간이 협소하다.\nConsole에서 행한 것은 저장되지 않는다. 보다 정확하게 말하면, 산출물은 저장될 수 있지만, 그러한 산출물을 얻는데 동원된 일련의 코드는 저장되지 않는다. RStudio를 나갔다가 다시 들어오면 객체, 플롯 등의 산출물은 그대로 남아 있지만 어떤 과정을 거쳐 그러한 결과물을 산출했는지에 대한 것을 남아 있지 않다. 이런 점은 상당한 기간이 지난 후에는 더 큰 문제로 다가온다.\n\n이러한 의미에서 R을 가지고 행한 것을 모두 저장하는, 일종의 연구노트와 같은 것이 필요하다. 이것을 R 스크립트(script)라고 부르는데, 좌상의 Editor 창에서 스크립트를 다루고, .R이라는 확장자를 가진 파일로 저장한다.\n\n3.2.2 스크립트 파일 생성하고 저장하기\n스크립트 파일을 생성하는 세 가지 정도의 방법이 있다.\n\nFile &gt; New File &gt; R Script 선택\nFile 메뉴 바로 아래의 New File 아이콘을 누른 후 R Script 선택\n단축키(Ctrl + Shift + N) 실행\n\n이렇게 하면 그림 5 과 같이 좌상에 Editor 창이 생성된다. 그 안에서 그림에서 보는 바와 같이 코드를 작성하게 된다.\n\n\n\n\n\n그림 5: 네 개의 창(https://docs.posit.co/ide/user/ide/guide/ui/ui-panes.html)\n\n\n스크립트 파일에 이름을 부여하고 저장한다.\n\nFile &gt; Save 선택\nSave current document 아이콘 클릭\n단축키(Ctrl + S) 실행\n\n3.2.3 스크립트 파일에서의 실행\n앞에서 Console에서 했던 모든 일을 동일하게 할 수 있다. 단 실행 방식이 조금 다르다. 앞에서 생성한 df 데이터 프레임의 a 벡터(변수)의 평균값을 구하기 위해 이전과 동일하게 입력한다. 그런데 프롬프트가 없고, [enter]를 눌러도 실행되지 않는다.\n\nmean(df$a)\n\n우선 실행할 코드 라인 혹은 코드의 영역을 지정해야 한다. 두 가지 방법이 있다.\n\n실행할 코드 라인 혹은 코드 블록에 커서를 위치시킨다.\n왼쪽 마우스 버튼을 누른 상태에서 커서를 이동시켜 실행할 영역 전체를 선택한다.\n\n영역이 지정되면 실행하면 되는데, 여기에도 두 가지 방법이 있다.\n\n단축키(Ctrl + Enter) 실행\nEditor 창의 우상에 있는 ‘Run the current line or selection’ 아이콘을 클릭(그림 6 참조)\n\n\n\n\n\n\n그림 6: 스크립트 파일에서의 실행(https://docs.posit.co/ide/user/ide/guide/code/execution.html)\n\n\n이전의 실행을 반복하고자 할 때는 다음과 같이 하면 된다.\n\n단축키(Ctrl + Alt +P) 실행\nEditor 창의 우상에 있는 ‘Re-run the previous code region’ 아이콘을 클릭(그림 6 참조)\n\n스크립트 파일 내 모든 코드를 실행하고자 할 때는 다음과 같이 하면 된다.\n\n단축키(Crtl + Shift + S)\n\n3.2.4 코멘트\n코드에 대한 코멘트를 스크립트 파일 곳곳에 남겨두면 나중에 코드 작성의 의도를 보다 쉽게 파악할 수 있다. 이와 관련하여 두 가지 사항을 알아두면 유용하다.\n첫째, # 표시 뒤의 것은 R이 실행하지 않기 때문에 중간중간에 # 표시를 하고 그 뒤에 자신의 코멘트를 남겨두는 것을 권한다.\n\nmean(df$a) # 세 사람의 나이 평균을 구함. 첫 번째 사람 나이가 엄청나게 많음.\n\n둘째, 코드가 길어지면, 그것을 몇 개의 섹션으로 나누고 그것에 코멘트를 달아 줄 수 있다. 단축키(Crtl + Shift + R)를 실행하여 섹션 라벨(Section label)을 달 수 있고, Editor 창의 왼쪽 하단에 있는 작은 아이콘을 이용해 섹션을 빠르게 이동할 수 있다.\n\n\n\n\n\n그림 7: 섹션 코멘트 달기(https://r4ds.hadley.nz/workflow-style.html#sectioning-comments)",
    "crumbs": [
      "R 실습: 2025/2",
      "R and RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#major-events",
    "href": "R_lec_01.html#major-events",
    "title": "R & RStudio",
    "section": "Major Events",
    "text": "Major Events",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#bell-labs-in-1975",
    "href": "R_lec_01.html#bell-labs-in-1975",
    "title": "R & RStudio",
    "section": "Bell Labs in 1975",
    "text": "Bell Labs in 1975",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#s-plus-1997",
    "href": "R_lec_01.html#s-plus-1997",
    "title": "R & RStudio",
    "section": "S-Plus, 1997",
    "text": "S-Plus, 1997",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#fathers-of-r-1993",
    "href": "R_lec_01.html#fathers-of-r-1993",
    "title": "R & RStudio",
    "section": "Fathers of R, 1993",
    "text": "Fathers of R, 1993\n\n\n\n\n\n\nGeorge Ross Ihaka\n\n\n\n\n\n\n\nUniversity of Auckland\n\n\n\n\n\n\n\nRobert C. Gentleman",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#official-birth",
    "href": "R_lec_01.html#official-birth",
    "title": "R & RStudio",
    "section": "Official Birth",
    "text": "Official Birth",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#ggplot2-2007",
    "href": "R_lec_01.html#ggplot2-2007",
    "title": "R & RStudio",
    "section": "ggplot2, 2007",
    "text": "ggplot2, 2007\n\n\n\n\n\n\n \n\n\n\n\n\nHadley Wickham",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#rstudio-2011",
    "href": "R_lec_01.html#rstudio-2011",
    "title": "R & RStudio",
    "section": "RStudio, 2011",
    "text": "RStudio, 2011",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#shiny-2012",
    "href": "R_lec_01.html#shiny-2012",
    "title": "R & RStudio",
    "section": "shiny, 2012",
    "text": "shiny, 2012",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#tidyverse-2016",
    "href": "R_lec_01.html#tidyverse-2016",
    "title": "R & RStudio",
    "section": "tidyverse, 2016",
    "text": "tidyverse, 2016",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#posit-2022",
    "href": "R_lec_01.html#posit-2022",
    "title": "R & RStudio",
    "section": "posit, 2022",
    "text": "posit, 2022",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#quarto-2022",
    "href": "R_lec_01.html#quarto-2022",
    "title": "R & RStudio",
    "section": "quarto, 2022",
    "text": "quarto, 2022",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#what-is-rstudio-for-r",
    "href": "R_lec_01.html#what-is-rstudio-for-r",
    "title": "R & RStudio",
    "section": "What is RStudio for R?",
    "text": "What is RStudio for R?",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#what-is-rstudio-for-r-1",
    "href": "R_lec_01.html#what-is-rstudio-for-r-1",
    "title": "R & RStudio",
    "section": "What is RStudio for R?",
    "text": "What is RStudio for R?",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#ide",
    "href": "R_lec_01.html#ide",
    "title": "R & RStudio",
    "section": "IDE",
    "text": "IDE",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#four-panes-or-windows",
    "href": "R_lec_01.html#four-panes-or-windows",
    "title": "R & RStudio",
    "section": "Four panes or windows",
    "text": "Four panes or windows",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#r-project",
    "href": "R_lec_01.html#r-project",
    "title": "R & RStudio",
    "section": "R Project",
    "text": "R Project",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#r-project-1",
    "href": "R_lec_01.html#r-project-1",
    "title": "R & RStudio",
    "section": "R Project",
    "text": "R Project",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#rstudio-guide",
    "href": "R_lec_01.html#rstudio-guide",
    "title": "R & RStudio",
    "section": "RStudio Guide",
    "text": "RStudio Guide\n\nRStudio IDE User Guide\nPosit Cheatsheets",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#google-trend",
    "href": "R_lec_01.html#google-trend",
    "title": "R & RStudio",
    "section": "Google Trend",
    "text": "Google Trend",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#differences",
    "href": "R_lec_01.html#differences",
    "title": "R & RStudio",
    "section": "Differences",
    "text": "Differences",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#differences-1",
    "href": "R_lec_01.html#differences-1",
    "title": "R & RStudio",
    "section": "Differences",
    "text": "Differences",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#r-for-open-science",
    "href": "R_lec_01.html#r-for-open-science",
    "title": "R & RStudio",
    "section": "R for Open Science",
    "text": "R for Open Science",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#r-for-reproducible-research",
    "href": "R_lec_01.html#r-for-reproducible-research",
    "title": "R & RStudio",
    "section": "R for Reproducible Research",
    "text": "R for Reproducible Research",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#r-communities",
    "href": "R_lec_01.html#r-communities",
    "title": "R & RStudio",
    "section": "R Communities",
    "text": "R Communities",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#r-communities-1",
    "href": "R_lec_01.html#r-communities-1",
    "title": "R & RStudio",
    "section": "R Communities",
    "text": "R Communities",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "R_lec_01.html#r-and-python-in-harmony",
    "href": "R_lec_01.html#r-and-python-in-harmony",
    "title": "R & RStudio",
    "section": "R and Python in Harmony",
    "text": "R and Python in Harmony",
    "crumbs": [
      "R 프레젠테이션: 2024/1",
      "R & RStudio"
    ]
  },
  {
    "objectID": "exec_11.html#입력-함수와-출력-함수의-종류",
    "href": "exec_11.html#입력-함수와-출력-함수의-종류",
    "title": "웹 앱 개발: Shiny의 기초",
    "section": "\n3 입력 함수와 출력 함수의 종류",
    "text": "3 입력 함수와 출력 함수의 종류\n\n3.1 입력 함수\n앞에서 언급한 것처럼, 입력 함수 혹은 입력 위젯 생성 함수의 종류는 다양하다. R Shiny Components 웹페이지 기준으로 대략 25개 정도이다. 그림 5 는 그 중 일부를 보여주고 있다.\n\n\n\n\n\n그림 5: 입력 위젯의 종류(https://shiny.posit.co/r/getstarted/build-an-app/reactive-flow/ui-inputs.html)\n\n\n몇 가지 주목할 사항이 있다.\n첫째, 모든 함수의 이름이 *Input() 형식인 것은 아니다. 특히 버튼 형식의 경우 *Button() 혹은 *Buttons() 형식을 띤다. 이 외에 *Link(), *switch()로 끝나는 함수도 있다.\n둘째, 입력 함수의 인수가 중요하다. 입력값에 이름을 부여하는 inputID 인수와 입력 위젯에 나타날 설명 글귀를 지정하는 label 인수는 공통이다. 그러나 나머지 인수는 입력 함수에 따라 달라진다. 위의 예에서 sliderInput() 입력 함수는 min, max, value라는 추가적인 인수를 갖는데, min과 max는 슬라이더의 최대 및 최소값을, value는 기본값을 지정하는 인수이다. 입력 함수별 인수에 대한 자세한 사항은 R Shiny Components 웹페이지를 참조한다.\n\n3.2 출력 함수와 렌더링 함수\n출력 함수는 서버에서 생성된 출력을 UI에서 표출해주는 함수인데 반해, 렌더링 함수는 서버에서 실질적으로 출력을 생성하는 함수이다. 출력 함수와 렌더링 함수 모두는 출력의 형식(플롯, 테이블, 텍스트, 이미지 등)에 따라 다양하기 때문에, 기본적으로 두 함수는 쌍을 이룰 수 밖에 없다.\n다음은 다섯 가지 기본 쌍을 보여준다. 출력 함수는 *Output()의 형식을, 렌더링 함수는 render*({})의 형식을 취한다.\n\n\n표 1: 기본 출력 함수와 렌더링 함수 쌍\n\n\n\n\n\n\n\n\n형식\n출력 함수(UI)\n렌더링 함수(Server)\n\n\n\n플롯\nplotOutput(outputID = \"\")\nrenderPlot({})\n\n\n테이블\ntableOutput(outputID = \"\")\nrenderTable({})\n\n\n일반 텍스트\ntextOutput(outputID = \"\")\nrenderText({})\n\n\n사전 포맷된 텍스트\nverbatimeTextOutput(outputID = \"\")\nrenderPrint({})\n\n\n이미지\nimageOutput(outputID = \"\")\nrenderImage({})\n\n\n\n\n\n\n그런데 특히 주요 시각화 패키지들은 Shiny 웹 앱 구축을 염두에 두고 개별적인 출력 함수와 렌더링 함수를 제공하고 있다. 중요한 패키지에 대해 이를 정리하면 다음과 같다. 모두 패키지명Output()형식과 render패키지명({})의 형식을 띤다.\n\n\n표 2: 주요 패키지별 출력 함수와 렌더링 함수 쌍\n\n\n\n\n\n\n\n\n패키지\n출력 함수(UI)\n렌더링 함수(Server)\n\n\n\nDT\nDTOutput(outputID = \"\")\nrenderDT({})\n\n\nreactable\nreactableOutput(outputID = \"\")\nrenderReactable({})\n\n\nplotly\nplotlyOutput(outputID = \"\")\nrenderPlotyl({})\n\n\necharts4r\necharts4rOutput(outputID = \"\")\nrenderEcharts4r({})\n\n\nleaflet\nleafletOutput(outputID = \"\")\nrenderLeaflet({})\n\n\ntmap\ntmapOutput(outputID = \"\")\nrenderTmap({})\n\n\n\n\n\n\nShiny 웹 앱에서의 활용을 염두에 둔 패키지들은 모두 이러한 출력 함수의 쌍을 제공하고 있다. 따라서 출력 함수는 굉장히 많을 수 있다. R Shiny Components 웹페이지는 기본 5개의 함수쌍에 주요 패키지를 포함하는 12개 정도의 출력 함수쌍을 예시로 제시하고 있다.",
    "crumbs": [
      "R과 데이터사이언스",
      "웹 앱 개발: Shiny의 기초"
    ]
  },
  {
    "objectID": "R_lec_12_2025.html",
    "href": "R_lec_12_2025.html",
    "title": "R Lecture 12\n웹 앱 개발: Shiny 2",
    "section": "",
    "text": "https://www.shinyapps.io/\n계정 생성\n\n로그인 후 상단 오른쪽 끝 메뉴 “Tokens” 페이지로 이동\n페이지에서 Show를 통해 인증 토큰(Token)과 Secret 확보: Show secret를 클릭하여 secret까지 보이게 한 후 복사하기\n\nRStudio에 토큰 설정\n\nR 콘솔에 복사한 내용 붙여넣기 및 실행\n\nPublish 버튼 클릭\n\n스크립트 윈도우의 오른쪽 상단\n배포를 원하는 R 파일만 선택\n\nURL 생성: https://userid.shinyapps.io/project_name/\n\nhttps://sangillee.shinyapps.io/AIEDU2025_Example/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 12]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 2]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_12_2025.html#웹-배포deployment",
    "href": "R_lec_12_2025.html#웹-배포deployment",
    "title": "R Lecture 12\n웹 앱 개발: Shiny 2",
    "section": "",
    "text": "https://www.shinyapps.io/\n계정 생성\n\n로그인 후 상단 오른쪽 끝 메뉴 “Tokens” 페이지로 이동\n페이지에서 Show를 통해 인증 토큰(Token)과 Secret 확보: Show secret를 클릭하여 secret까지 보이게 한 후 복사하기\n\nRStudio에 토큰 설정\n\nR 콘솔에 복사한 내용 붙여넣기 및 실행\n\nPublish 버튼 클릭\n\n스크립트 윈도우의 오른쪽 상단\n배포를 원하는 R 파일만 선택\n\nURL 생성: https://userid.shinyapps.io/project_name/\n\nhttps://sangillee.shinyapps.io/AIEDU2025_Example/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 12]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 2]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_12_2025.html#quarto와-shiny의-결합",
    "href": "R_lec_12_2025.html#quarto와-shiny의-결합",
    "title": "R Lecture 12\n웹 앱 개발: Shiny 2",
    "section": "Quarto와 Shiny의 결합",
    "text": "Quarto와 Shiny의 결합\n\n상황: Quarto 대시보드의 일부 영역에서 Shiny 사용\n두 가지 접근\n\nShiny 중심 방식: Shiny 웹 앱의 생성\n\nQuarto 대시보드 내에서 Quarto 문법으로 Shiny 웹 앱 구축\nQuarto 대시보드 전체가 Shiny 웹 앱화: shinyapps.io를 통해 배포\n사례: https://sangillee.shinyapps.io/Dashboard_Example/\n\nQuarto 중심 방식: Quarto 대시보드의 유지\n\nQuarto 대시보드 속에 독립적으로 구축된 Shiny 웹 앱 임베딩\n여전히 Quarto 대시보드: Quarto Pub을 통해 배포\n사례: https://sangillee.snu.ac.kr/dashboard_examples/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 12]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 2]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_12_2025.html#quarto와-shiny의-결합-shiny-중심-방식",
    "href": "R_lec_12_2025.html#quarto와-shiny의-결합-shiny-중심-방식",
    "title": "R Lecture 12\n웹 앱 개발: Shiny 2",
    "section": "Quarto와 Shiny의 결합: Shiny 중심 방식",
    "text": "Quarto와 Shiny의 결합: Shiny 중심 방식\n\n옵션 1: Quarto를 Shiny 웹 앱의 레이아웃 설정 도구로 사용\n\nshiny 패키지: fluidPage()\n\ntitlePanel(), SidebarLayout(), sidebarPanel(), mainPanel()\n\nbslib 패키지: page_sidebar()\n\nsidebar = sidebar(), card()\n\n\n옵션 2: Quarto 대시보드 내에서 Shiny 웹 앱 구축",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 12]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 2]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_12_2025.html#quarto와-shiny의-결합-shiny-중심-방식-1",
    "href": "R_lec_12_2025.html#quarto와-shiny의-결합-shiny-중심-방식-1",
    "title": "R Lecture 12\n웹 앱 개발: Shiny 2",
    "section": "Quarto와 Shiny의 결합: Shiny 중심 방식",
    "text": "Quarto와 Shiny의 결합: Shiny 중심 방식\n\nhttps://quarto.org/docs/dashboards/interactivity/shiny-r.html\nYAML 헤더에 다음 첨가: server: shiny\nui 부분: 기본적으로는 r 코드 청크 속에 포함, 사이드바와 메인 병렬\n\n사이드바: 레이아웃 구성요소에 넣고 {.sidebar} CSS 클래스 지정 가능\n메인: 사이드바와 다른 레이아웃 구성요소에 넣기 가능\n\nserver 부분: r 코드 청크 속에 포함, 다음 지정\n\n#| context: server 지정\n\n기타(패키지, 데이터 등) 부분: r 코드 청크 속에 포함, 다음 지정\n\n#| context: setup\n#| include: false",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 12]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 2]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_12_2025.html#quarto와-shiny의-결합-quarto-중심-방식",
    "href": "R_lec_12_2025.html#quarto와-shiny의-결합-quarto-중심-방식",
    "title": "R Lecture 12\n웹 앱 개발: Shiny 2",
    "section": "Quarto와 Shiny의 결합: Quarto 중심 방식",
    "text": "Quarto와 Shiny의 결합: Quarto 중심 방식\n\n보통 하나의 row에 임베딩\nsrc=\"\" 부분만 교체\n\n&lt;iframe src=\"https://...\" loading=\"lazy\" style=\"width: 100%; height: 600px; border: 0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 12]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 2]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_12_2025.html#chatbot-웹-앱",
    "href": "R_lec_12_2025.html#chatbot-웹-앱",
    "title": "R Lecture 12\n웹 앱 개발: Shiny 2",
    "section": "Chatbot 웹 앱",
    "text": "Chatbot 웹 앱\n\n\n\n\n\n\nhttps://ellmer.tidyverse.org/\n\n\n\n\n\n\n\nhttps://posit-dev.github.io/shinychat/r/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 12]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 2]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_12_2025.html#chatbot-웹-앱-1",
    "href": "R_lec_12_2025.html#chatbot-웹-앱-1",
    "title": "R Lecture 12\n웹 앱 개발: Shiny 2",
    "section": "Chatbot 웹 앱",
    "text": "Chatbot 웹 앱\n\n코드웹 앱\n\n\n\nlibrary(shiny)\nlibrary(shinychat)\nlibrary(bslib)\nlibrary(ellmer)\n\nui &lt;- page_fillable(\n  chat_ui(\n    id = \"chat\",\n    messages = \"your messages here\"\n  ),\n  fillable_mobile = TRUE\n)\n\nserver &lt;- function(input, output, session) {\n  chat &lt;-\n    chat_openai(\n      base_url = \"https://api.openai.com/v1\",\n      model = \"gpt-5.1\",\n      api_key = your_api_key_here,\n      system_prompt = \"\"\n    )\n\n  observeEvent(input$chat_user_input, {\n    stream &lt;- chat$stream_async(input$chat_user_input)\n    chat_append(\"chat\", stream)\n  })\n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 12]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 2]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html",
    "href": "R_lec_10_2025.html",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "데이터 레이어\n\n국가 경계, 호수, 그래티큘: 벡터(vector) 데이터\n인구밀도, 수심: 래스터(raster) 데이터\n\n데이터 원천\n\nNatural Earth Data: 국가 경계, 호수, 그래티큘, 수심\nNASA’s Socioeconomic Data and Applications Center (SEDAC): 인구 밀도\n\n투영법: 로빈슨 도법(Robinson projection)\n\nCRS (coordinate reference system, 좌표참조계)\n\n지도화 기법: 컬러, 범례, 주기 표기 등\n\n\n\n\n\n\n\n\n\n\nhttps://r-spatial.github.io/sf/\n\n\n\n\n\n\n\nhttps://rspatial.github.io/terra/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhttps://ggplot2.tidyverse.org/\n\n\n\n\n \n\n\n\n\n\nhttps://r-tmap.github.io/tmap/\n\n\n\n\n\n\n\n\n\n벡터(vector) 데이터\n\n포인트, 라인, 폴리곤\n형상 데이터 + 속성 데이터\n\n래스터(raster) 데이터\n\n그리드 셀(grid cell)\n일체형\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n벡터 데이터: 형상 데이터 + 속성 데이터\n\n형상 데이터 (기하, 도형, 공간 데이터)\n\n지리공간적 객체 자체에 대한 데이터\n포인트(점), 라인(선), 폴리곤(면)으로 구분\n버텍스(vertex)의 좌표값\n\n속성 데이터\n\n지리공간적 객체가 보유한 속성\n기존 일반 데이터와 동일\n\n\n\n\n\n\n\n형상 데이터: 셰이프 파일(shape file) (ESRI사)\n\nsigungu.shp: 버텍스의 좌표값이 포함된 핵심 파일\nsigungu.shx: 공간적 인덱싱 파일\nsigungu.dbf: 기본 속성 파일\nsigungu.prj: 투영 정보 파일\n\n특수한 패키지 필요: sf 패키지\n\nst_read() 혹은 read_sf() 함수\n\n\n\n\n\n\n\n\nhttps://allisonhorst.com/r-packages-functions\n\n\n\n\n\n\n\n\n\n\n\n\n구분\n함수\n\n\n\n\n읽고 쓰기\nst_read(), st_write(), read_sf(), write_sf()\n\n\n투영 관련\nst_crs(), st_transform()\n\n\n기하 측정\nst_area(), st_length(), st_perimeter(), st_distance()\n\n\n기하 변형\nst_centroid(), st_buffer(), st_boundary(), st_simplify()\n\n\n기하 생성\nst_point(), st_voronoi() , st_convex_hull(), st_make_grid()\n\n\n기하 검토\nst_is_valid(), st_make_valid()\n\n\n기하 중첩\nst_filter(), st_intersection(), st_union(), st_crop()\n\n\n기타\nst_coordinates(), st_cast(), st_as_sf(), st_graticule(), st_join()\n\n\n\n\n\n\n\nCodeResult\n\n\n\nlibrary(tidyverse)\nlibrary(sf)\nsigungu_shp &lt;- st_read(\"sigungu.shp\", options = \"ENCODING=CP949\")\nggplot() + geom_sf(data = sigungu_shp)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n속성 데이터\n\ncsv 파일: readr 패키지의 read_csv() 함수\n엑셀 파일: readxl 패키지의 read_excel() 함수\nOpen API를 통해 수집: tibble 객체\n\n형상 데이터와 속성 데이터의 결합: dplyr 패키지의 left_join() 함수\n\n왼편: 형상 데이터\n오른편: 속성 데이터\n\n\n\n\n\n\n데이터 형식\n\nTIFF 혹은 GeoTIFF\n\n패키지: terra 패키지\n\n불러오기: rast()\n변환하기: project(), mosaic(), crop()\n계산하기: global(), focal(), zonal()\n수 많은 다른 함수들\n\n\n\n\n\n\n\n\nhttps://datacarpentry.github.io/organization-geospatial/03-crs.html\n\n\n\n\n\n\n좌표참조계 Coordinate Reference System\n모든 지리공간데이터는 특정한 좌표참조계에 의거해 제작되며 이러한 좌표참조계는 매우 다양함\n\n준거타원체\n투영법(map projection)\n투영 파라미터: 투영축, 투영격, 중앙경선, 가상원점 등\n\n지리공간데이터의 SRID(Spatial Reference System Identifiers, 공간참조계식별자)\nsf 패키지: st_crs() 함수\n\n\n\n\n\nPROJ 정형문자열\n\nhttps://proj.org/en/9.4/\n준거타원체, 투영법, 투영 파라미터를 + 기호로 연결해 작성한 문자열\nUTM-K\n\n+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 +x_0=1000000 +y_0=2000000 +ellps=GRS80 +units=m\n\n\nEPSG 숫자코드\n\nhttps://epsg.io/\n모든 CRS에 1024~32767 사이의 고유 숫자를 부여\nUTM-K\n\nEPSG: 5179\n\n\n\n\n\n\n\n세계지도를 위한 주요 투영법의 PROJ 별명(alias)\n\n\n\n\n\n\n\n\n\n투영법\nPROJ 파라미터\n\n\n\n\n정적원통 도법 Equal Area Cylindrical\n+proj=cea\n\n\n컴펙트 밀러 도법 Compact Miller\n+proj=comill\n\n\n에케르트 IV 도법 Eckert IV\n+proj=eck4\n\n\n정거원통 도법 Equidistant Cylindrical\n+proj=eqc\n\n\n구드 도법 Goode Homolosine\n+proj=goode\n\n\n단열형 구드 도법 Interrupted Goode Homolosine\n+proj=igh\n\n\n메르카토르 도법 Mercator\n+proj=merc\n\n\n몰바이데 도법 Mollweide\n+proj=moll\n\n\n로빈슨 도법 Robinson\n+proj=robin\n\n\n시뉴소이드 도법 Sinusoidal\n+proj=sinu\n\n\n빈켈트리펠 도법 Winkel Tripel\n+proj=wintri\n\n\n\n\n\n\n\n\n널리 사용되는 CRS의 EPSG\n\n\n\n\n\n\n\n\n\n\n적용 스케일\nEPSG 숫자코드\n설명\n\n\n\n\n전세계\nEPSG:4326\nWGS84, 측지좌표계, GPS에 사용\n\n\n\nEPSG:3857\n웹 메르카토르 도법, 구글 맵스, 오픈스트리트맵에서 사용\n\n\n\nEPSG:7789\nITRF2014\n\n\n미국\nEPSG:2163\n알베르스 정적원추 도법\n\n\n유럽\nEPSG:3035\n람베르트 정적방위 도법\n\n\n우리나라\nEPSG:5179\nUTM-K\n\n\n\nEPSG:5185\n서부원점\n\n\n\nEPSG:5186\n중부원점\n\n\n\nEPSG:5187\n동부원점\n\n\n\nEPSG:5188\n동해원점\n\n\n\n\n\n\n\n\n플라트카레컴펙트 밀러 도법로빈슨에케르트 IV\n\n\n\nggplot() +\n  geom_sf(data = world) +\n  geom_sf(data = ne_bbox, fill = NA) +\n  coord_sf(crs = \"+proj=eqc\") +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.9, seq(-60, 60, 30), 89.9)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nggplot() +\n  geom_sf(data = world) +\n  geom_sf(data = ne_bbox, fill = NA) +\n  coord_sf(crs = \"+proj=comill\") +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.9, seq(-60, 60, 30), 89.9)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nggplot() +\n  geom_sf(data = world) +\n  geom_sf(data = ne_bbox, fill = NA) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.9, seq(-60, 60, 30), 89.9)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nggplot() +\n  geom_sf(data = world) +\n  geom_sf(data = ne_bbox, fill = NA) +\n  coord_sf(crs = \"+proj=eck4\") +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.9, seq(-60, 60, 30), 89.9)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n정적(static) 지도\n\nggplot2 패키지, tmap 패키지\n\n동적(animated) 지도\n\ngganimate 패키지\ntmap 패키지\n\n인터랙티브(interactive) 지도\n\nplotly 패키지의 ggplotly() 함수\nggiraph 패키지\nleaflet 패키지: Leaflet JS 라이브러리의 래퍼 패키지\n\n\n\n\n\n\n\n\n\n\n“지도도 그래프다” 관점: 일반성\n\nggplot2 패키지\n\ngeom_sf(), coord_sf()\n\n\n“지도는 지도이다” 관점: 특수성\n\ntmap 패키지\n\n4.2.0\n\n\n\n\n\n\n\n데이터 정리ggplot2: Codeggplot2: Resulttmap: Codetmap: Result\n\n\n\nlibrary(tidyverse)\nlibrary(spData)\nlibrary(sf)\ndata(world)\nworld &lt;- st_as_sf(world)\nwpp_2024 &lt;- read_rds(\"wpp_2024.rds\")\nmy_wpp &lt;- wpp_2024 |&gt; \n  filter(year == 2025)\nworld_data &lt;- world |&gt;\n  left_join(my_wpp, join_by(iso_a2 == ISO2))\n\n\n\n\nworld_map &lt;- ggplot() +\n  geom_sf(data = world_data, aes(fill = TFR, text = name_long)) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_fill_viridis_c() +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.5, seq(-60, 60, 30), 89.5)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\nworld_map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(tmap)\ntm_world_map &lt;- tm_shape(world_data, crs = \"+proj=robin\") +\n  tm_graticules(\n    labels.show = FALSE,\n    x = seq(-180, 180, 30), \n    y = c(-89.5, seq(-60, 60, 30), 89.5)\n  ) + \n  tm_polygons(\n    fill = \"TFR\", \n    fill.scale = tm_scale_continuous(values = \"viridis\")\n  ) +\n  tm_layout(frame = FALSE)\ntm_world_map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n데이터 정리ggplot2: Codeggplot2: Resulttmap: Codetmap: Result\n\n\n\nlibrary(tidyverse)\nlibrary(sf)\nsido_shp &lt;- st_read(\"sido.shp\", options = \"ENCODING=CP949\")\nsigungu_shp &lt;- st_read(\"sigungu.shp\", options = \"ENCODING=CP949\")\ndata_sigungu &lt;- read_rds(\"data_sigungu.rds\")\nsigungu_data &lt;- sigungu_shp |&gt; \n  left_join(data_sigungu, join_by(SGG1_CD == C1))\n\n\n\n\nlibrary(ggspatial)\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index_class = case_when(\n      index &lt; 0.2 ~ \"1\",\n      index &gt;= 0.2 & index &lt; 0.5 ~ \"2\",\n      index &gt;= 0.5 & index &lt; 1.0 ~ \"3\",\n      index &gt;= 1.0 & index &lt; 1.5 ~ \"4\",\n      index &gt;= 1.5 ~ \"5\"\n    ),\n    index_class = fct(index_class, levels = as.character(1:5))\n  )\nclass_color &lt;- c(\"1\" = \"#d7191c\", \"2\" = \"#fdae61\",\n                 \"3\" = \"#ffffbf\", \"4\" = \"#a6d96a\", \n                 \"5\" = \"#1a9641\")\nggplot_map &lt;- ggplot() +\n  geom_sf(\n    data = sigungu_data, \n    aes(fill = index_class, text = SGG1_FNM), \n    show.legend = TRUE\n  ) +\n  geom_sf(\n    data = sido_shp, \n    fill = NA, \n    lwd = 0.5\n  ) +\n  scale_fill_manual(\n    name = \"Classes\", \n    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \n               \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n    values = class_color, drop = FALSE\n  ) +\n  annotation_scale(\n    location = \"br\", \n    bar_cols = c(\"gray40\", \"white\"), \n    width_hint = 0.4\n  )\nggplot_map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\ntmap_map &lt;- tm_graticules(labels.cardinal = TRUE) +\n  tm_shape(sigungu_data) + \n  tm_polygons(\n    fill = \"index\", id = \"SGG1_FNM\", \n    fill.scale = tm_scale_intervals(\n      values = class_color, \n      breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n      labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \n               \"1.0 ~ 1.5\", \"&gt;= 1.5\")\n    ),\n    fill.legend = tm_legend(title = \"Classes\")\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 1.5) +\n  tm_scalebar(breaks = seq(0, 200, 50)) \ntmap_map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCodeResult\n\n\n\nlibrary(plotly)\nggplotly(world_map)\n\n\n\n\nlibrary(plotly)\nggplotly(world_map)\n\n\n\n\n\n\n\n\n\n\n\n\nCodeResult\n\n\n\nlibrary(ggiraph)\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = format(index, digits = 4, nsmall = 4),\n    my_tooltip = str_c(\"Name: \", SGG1_FNM, \"\\n Index: \", index)\n  )\ngg &lt;- ggplot() +\n  geom_sf_interactive(\n    data = sigungu_data, \n    aes(fill = index_class, tooltip = my_tooltip, data_id = SGG1_FNM), \n    show.legend = TRUE\n  ) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(\n    name = \"Classes\", \n    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n    values = class_color, drop = FALSE\n  ) \ngirafe(ggobj = gg) |&gt; \n  girafe_options(opts_hover(css = \"fill: gray\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR 래퍼 패키지: leaflet\n\n\n\n\nhttps://leafletjs.com/\n\n\n\n\n\n\nCodeResult\n\n\n\nlibrary(leaflet)\nleaflet() |&gt; \n  addTiles() |&gt; \n  addPopups(126.955184, 37.460422, \"Sang-Il's Office\",\n            options = popupOptions(closeButton = FALSE))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n세계: Code세계: Result우리나라: Code우리나라: Result\n\n\n\nlibrary(leaflet)\nworld_data &lt;- world_data |&gt; filter(!is.na(TFR))\n\nbins &lt;- c(0, 1.5, 2.1, 3, 4, 5, Inf)\npal &lt;- colorBin(\"YlOrRd\", domain = world_data$TFR, bins = bins)\nlabels &lt;- sprintf(\"&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g\",\n  world_data$name_long, world_data$TFR) |&gt; lapply(htmltools::HTML)\n\nleaflet(world_data) |&gt; \n  addProviderTiles(providers$Esri.WorldTopoMap) |&gt; \n  addPolygons(\n    fillColor = ~pal(TFR), weight =  2, opacity = 1, color = \"white\", \n    dashArray = \"3\", fillOpacity = 0.6,\n    highlightOptions = highlightOptions(\n      weight = 5, color = \"#666\", dashArray = \"\", \n      fillOpacity = 0.6, bringToFront = TRUE\n    ),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"), \n      textsize = \"15px\", direction = \"auto\"\n    )\n  ) |&gt; \n  addLegend(\n    pal = pal, values = ~TFR, opacity = 0.6, title = NULL, position = \"bottomright\"\n  )\n\n\n\n\nlibrary(leaflet)\n\nworld_data &lt;- world_data |&gt; filter(!is.na(TFR))\n\nbins &lt;- c(0, 1.5, 2.1, 3, 4, 5, Inf)\npal &lt;- colorBin(\"YlOrRd\", domain = world_data$TFR, bins = bins)\nlabels &lt;- sprintf(\"&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g\",\n  world_data$name_long, world_data$TFR) |&gt; lapply(htmltools::HTML)\n\nleaflet(world_data) |&gt; \n  addProviderTiles(providers$Esri.WorldTopoMap) |&gt; \n  addPolygons(\n    fillColor = ~pal(TFR), weight =  2, opacity = 1, color = \"white\", \n    dashArray = \"3\", fillOpacity = 0.6,\n    highlightOptions = highlightOptions(\n      weight = 5, color = \"#666\", dashArray = \"\", \n      fillOpacity = 0.6, bringToFront = TRUE\n    ),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"), \n      textsize = \"15px\", direction = \"auto\"\n    )\n  ) |&gt; \n  addLegend(\n    pal = pal, values = ~TFR, opacity = 0.6, title = NULL, position = \"bottomright\"\n  )\n\n\n\n\n\n\n\n\nlibrary(tmap)\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\nsigungu_data &lt;- sigungu_data |&gt; mutate(index = as.numeric(index))\ntmap_mode(mode = \"view\")\nmy_tmap &lt;- tm_shape(sigungu_data) + \n  tm_polygons(\n    fill = \"index\", fill_alpha = 0.6, col_alpha = 0.5,\n    popup.vars = c(\"지역소멸위험지수: \" = \"index\"), \n    popup.format = list(index = list(digits = 3)), \n    id = \"SGG1_FNM\", \n    fill.scale = tm_scale_intervals(\n      values = class_color, breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n      labels = c(\"&lt; 0.2\", \"0.2~0.5\", \"0.5~1.0\", \"1.0~1.5\", \"&gt;= 1.5\")\n    ),\n    fill.legend = tm_legend(title = \"Classes\")\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 2)\nmy_tmap\n\n\n\n\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\nsigungu_data &lt;- sigungu_data |&gt; mutate(index = as.numeric(index))\ntmap_mode(mode = \"view\")\nmy_tmap &lt;- tm_shape(sigungu_data) + \n  tm_polygons(\n    fill = \"index\", fill_alpha = 0.6, col_alpha = 0.5,\n    popup.vars = c(\"지역소멸위험지수: \" = \"index\"), \n    popup.format = list(index = list(digits = 3)), \n    id = \"SGG1_FNM\", \n    fill.scale = tm_scale_intervals(\n      values = class_color, breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n      labels = c(\"&lt; 0.2\", \"0.2~0.5\", \"0.5~1.0\", \"1.0~1.5\", \"&gt;= 1.5\")\n    ),\n    fill.legend = tm_legend(title = \"Classes\")\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 2)\nmy_tmap",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#사례-전-세계-인구-분포-지도-1",
    "href": "R_lec_10_2025.html#사례-전-세계-인구-분포-지도-1",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "데이터 레이어\n\n국가 경계, 호수, 그래티큘: 벡터(vector) 데이터\n인구밀도, 수심: 래스터(raster) 데이터\n\n데이터 원천\n\nNatural Earth Data: 국가 경계, 호수, 그래티큘, 수심\nNASA’s Socioeconomic Data and Applications Center (SEDAC): 인구 밀도\n\n투영법: 로빈슨 도법(Robinson projection)\n\nCRS (coordinate reference system, 좌표참조계)\n\n지도화 기법: 컬러, 범례, 주기 표기 등",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#사례-전-세계-인구-분포-지도-2",
    "href": "R_lec_10_2025.html#사례-전-세계-인구-분포-지도-2",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "https://r-spatial.github.io/sf/\n\n\n\n\n\n\n\nhttps://rspatial.github.io/terra/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#사례-전-세계-인구-분포-지도-3",
    "href": "R_lec_10_2025.html#사례-전-세계-인구-분포-지도-3",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "https://ggplot2.tidyverse.org/\n\n\n\n\n \n\n\n\n\n\nhttps://r-tmap.github.io/tmap/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#지리공간적-데이터의-종류",
    "href": "R_lec_10_2025.html#지리공간적-데이터의-종류",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "벡터(vector) 데이터\n\n포인트, 라인, 폴리곤\n형상 데이터 + 속성 데이터\n\n래스터(raster) 데이터\n\n그리드 셀(grid cell)\n일체형",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#벡터-데이터",
    "href": "R_lec_10_2025.html#벡터-데이터",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "벡터 데이터: 형상 데이터 + 속성 데이터\n\n형상 데이터 (기하, 도형, 공간 데이터)\n\n지리공간적 객체 자체에 대한 데이터\n포인트(점), 라인(선), 폴리곤(면)으로 구분\n버텍스(vertex)의 좌표값\n\n속성 데이터\n\n지리공간적 객체가 보유한 속성\n기존 일반 데이터와 동일",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#벡터-데이터-1",
    "href": "R_lec_10_2025.html#벡터-데이터-1",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "형상 데이터: 셰이프 파일(shape file) (ESRI사)\n\nsigungu.shp: 버텍스의 좌표값이 포함된 핵심 파일\nsigungu.shx: 공간적 인덱싱 파일\nsigungu.dbf: 기본 속성 파일\nsigungu.prj: 투영 정보 파일\n\n특수한 패키지 필요: sf 패키지\n\nst_read() 혹은 read_sf() 함수",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#벡터-데이터-sf-패키지",
    "href": "R_lec_10_2025.html#벡터-데이터-sf-패키지",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "https://allisonhorst.com/r-packages-functions",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#벡터-데이터-sf-패키지-1",
    "href": "R_lec_10_2025.html#벡터-데이터-sf-패키지-1",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "구분\n함수\n\n\n\n\n읽고 쓰기\nst_read(), st_write(), read_sf(), write_sf()\n\n\n투영 관련\nst_crs(), st_transform()\n\n\n기하 측정\nst_area(), st_length(), st_perimeter(), st_distance()\n\n\n기하 변형\nst_centroid(), st_buffer(), st_boundary(), st_simplify()\n\n\n기하 생성\nst_point(), st_voronoi() , st_convex_hull(), st_make_grid()\n\n\n기하 검토\nst_is_valid(), st_make_valid()\n\n\n기하 중첩\nst_filter(), st_intersection(), st_union(), st_crop()\n\n\n기타\nst_coordinates(), st_cast(), st_as_sf(), st_graticule(), st_join()",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#벡터-데이터-sf-패키지-2",
    "href": "R_lec_10_2025.html#벡터-데이터-sf-패키지-2",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "CodeResult\n\n\n\nlibrary(tidyverse)\nlibrary(sf)\nsigungu_shp &lt;- st_read(\"sigungu.shp\", options = \"ENCODING=CP949\")\nggplot() + geom_sf(data = sigungu_shp)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#벡터-데이터-2",
    "href": "R_lec_10_2025.html#벡터-데이터-2",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "속성 데이터\n\ncsv 파일: readr 패키지의 read_csv() 함수\n엑셀 파일: readxl 패키지의 read_excel() 함수\nOpen API를 통해 수집: tibble 객체\n\n형상 데이터와 속성 데이터의 결합: dplyr 패키지의 left_join() 함수\n\n왼편: 형상 데이터\n오른편: 속성 데이터",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#래스터-데이터",
    "href": "R_lec_10_2025.html#래스터-데이터",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "데이터 형식\n\nTIFF 혹은 GeoTIFF\n\n패키지: terra 패키지\n\n불러오기: rast()\n변환하기: project(), mosaic(), crop()\n계산하기: global(), focal(), zonal()\n수 많은 다른 함수들",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#crs",
    "href": "R_lec_10_2025.html#crs",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "https://datacarpentry.github.io/organization-geospatial/03-crs.html",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#crs-정의",
    "href": "R_lec_10_2025.html#crs-정의",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "좌표참조계 Coordinate Reference System\n모든 지리공간데이터는 특정한 좌표참조계에 의거해 제작되며 이러한 좌표참조계는 매우 다양함\n\n준거타원체\n투영법(map projection)\n투영 파라미터: 투영축, 투영격, 중앙경선, 가상원점 등\n\n지리공간데이터의 SRID(Spatial Reference System Identifiers, 공간참조계식별자)\nsf 패키지: st_crs() 함수",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#crs-방식",
    "href": "R_lec_10_2025.html#crs-방식",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "PROJ 정형문자열\n\nhttps://proj.org/en/9.4/\n준거타원체, 투영법, 투영 파라미터를 + 기호로 연결해 작성한 문자열\nUTM-K\n\n+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 +x_0=1000000 +y_0=2000000 +ellps=GRS80 +units=m\n\n\nEPSG 숫자코드\n\nhttps://epsg.io/\n모든 CRS에 1024~32767 사이의 고유 숫자를 부여\nUTM-K\n\nEPSG: 5179",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#crs-proj-정형문자열",
    "href": "R_lec_10_2025.html#crs-proj-정형문자열",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "세계지도를 위한 주요 투영법의 PROJ 별명(alias)\n\n\n\n\n\n\n\n\n\n투영법\nPROJ 파라미터\n\n\n\n\n정적원통 도법 Equal Area Cylindrical\n+proj=cea\n\n\n컴펙트 밀러 도법 Compact Miller\n+proj=comill\n\n\n에케르트 IV 도법 Eckert IV\n+proj=eck4\n\n\n정거원통 도법 Equidistant Cylindrical\n+proj=eqc\n\n\n구드 도법 Goode Homolosine\n+proj=goode\n\n\n단열형 구드 도법 Interrupted Goode Homolosine\n+proj=igh\n\n\n메르카토르 도법 Mercator\n+proj=merc\n\n\n몰바이데 도법 Mollweide\n+proj=moll\n\n\n로빈슨 도법 Robinson\n+proj=robin\n\n\n시뉴소이드 도법 Sinusoidal\n+proj=sinu\n\n\n빈켈트리펠 도법 Winkel Tripel\n+proj=wintri",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#crs-epsg-숫자코드",
    "href": "R_lec_10_2025.html#crs-epsg-숫자코드",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "널리 사용되는 CRS의 EPSG\n\n\n\n\n\n\n\n\n\n\n적용 스케일\nEPSG 숫자코드\n설명\n\n\n\n\n전세계\nEPSG:4326\nWGS84, 측지좌표계, GPS에 사용\n\n\n\nEPSG:3857\n웹 메르카토르 도법, 구글 맵스, 오픈스트리트맵에서 사용\n\n\n\nEPSG:7789\nITRF2014\n\n\n미국\nEPSG:2163\n알베르스 정적원추 도법\n\n\n유럽\nEPSG:3035\n람베르트 정적방위 도법\n\n\n우리나라\nEPSG:5179\nUTM-K\n\n\n\nEPSG:5185\n서부원점\n\n\n\nEPSG:5186\n중부원점\n\n\n\nEPSG:5187\n동부원점\n\n\n\nEPSG:5188\n동해원점",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#crs-세계지도에-적용",
    "href": "R_lec_10_2025.html#crs-세계지도에-적용",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "플라트카레컴펙트 밀러 도법로빈슨에케르트 IV\n\n\n\nggplot() +\n  geom_sf(data = world) +\n  geom_sf(data = ne_bbox, fill = NA) +\n  coord_sf(crs = \"+proj=eqc\") +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.9, seq(-60, 60, 30), 89.9)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nggplot() +\n  geom_sf(data = world) +\n  geom_sf(data = ne_bbox, fill = NA) +\n  coord_sf(crs = \"+proj=comill\") +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.9, seq(-60, 60, 30), 89.9)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nggplot() +\n  geom_sf(data = world) +\n  geom_sf(data = ne_bbox, fill = NA) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.9, seq(-60, 60, 30), 89.9)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nggplot() +\n  geom_sf(data = world) +\n  geom_sf(data = ne_bbox, fill = NA) +\n  coord_sf(crs = \"+proj=eck4\") +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.9, seq(-60, 60, 30), 89.9)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#지리공간적-시각화-정적-vs.-동적",
    "href": "R_lec_10_2025.html#지리공간적-시각화-정적-vs.-동적",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "정적(static) 지도\n\nggplot2 패키지, tmap 패키지\n\n동적(animated) 지도\n\ngganimate 패키지\ntmap 패키지\n\n인터랙티브(interactive) 지도\n\nplotly 패키지의 ggplotly() 함수\nggiraph 패키지\nleaflet 패키지: Leaflet JS 라이브러리의 래퍼 패키지",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#정적-지도-두-가지-관점",
    "href": "R_lec_10_2025.html#정적-지도-두-가지-관점",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "“지도도 그래프다” 관점: 일반성\n\nggplot2 패키지\n\ngeom_sf(), coord_sf()\n\n\n“지도는 지도이다” 관점: 특수성\n\ntmap 패키지\n\n4.2.0",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#ggplot2-vs-tmap-세계지도",
    "href": "R_lec_10_2025.html#ggplot2-vs-tmap-세계지도",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "데이터 정리ggplot2: Codeggplot2: Resulttmap: Codetmap: Result\n\n\n\nlibrary(tidyverse)\nlibrary(spData)\nlibrary(sf)\ndata(world)\nworld &lt;- st_as_sf(world)\nwpp_2024 &lt;- read_rds(\"wpp_2024.rds\")\nmy_wpp &lt;- wpp_2024 |&gt; \n  filter(year == 2025)\nworld_data &lt;- world |&gt;\n  left_join(my_wpp, join_by(iso_a2 == ISO2))\n\n\n\n\nworld_map &lt;- ggplot() +\n  geom_sf(data = world_data, aes(fill = TFR, text = name_long)) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_fill_viridis_c() +\n  scale_x_continuous(breaks = seq(-180, 180, 30)) +\n  scale_y_continuous(breaks = c(-89.5, seq(-60, 60, 30), 89.5)) +\n  theme(\n    panel.background = element_rect(\"white\"),\n    panel.grid = element_line(color = \"gray80\")\n  )\nworld_map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(tmap)\ntm_world_map &lt;- tm_shape(world_data, crs = \"+proj=robin\") +\n  tm_graticules(\n    labels.show = FALSE,\n    x = seq(-180, 180, 30), \n    y = c(-89.5, seq(-60, 60, 30), 89.5)\n  ) + \n  tm_polygons(\n    fill = \"TFR\", \n    fill.scale = tm_scale_continuous(values = \"viridis\")\n  ) +\n  tm_layout(frame = FALSE)\ntm_world_map",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#ggplot2-vs-tmap-우리나라-지도",
    "href": "R_lec_10_2025.html#ggplot2-vs-tmap-우리나라-지도",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "데이터 정리ggplot2: Codeggplot2: Resulttmap: Codetmap: Result\n\n\n\nlibrary(tidyverse)\nlibrary(sf)\nsido_shp &lt;- st_read(\"sido.shp\", options = \"ENCODING=CP949\")\nsigungu_shp &lt;- st_read(\"sigungu.shp\", options = \"ENCODING=CP949\")\ndata_sigungu &lt;- read_rds(\"data_sigungu.rds\")\nsigungu_data &lt;- sigungu_shp |&gt; \n  left_join(data_sigungu, join_by(SGG1_CD == C1))\n\n\n\n\nlibrary(ggspatial)\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index_class = case_when(\n      index &lt; 0.2 ~ \"1\",\n      index &gt;= 0.2 & index &lt; 0.5 ~ \"2\",\n      index &gt;= 0.5 & index &lt; 1.0 ~ \"3\",\n      index &gt;= 1.0 & index &lt; 1.5 ~ \"4\",\n      index &gt;= 1.5 ~ \"5\"\n    ),\n    index_class = fct(index_class, levels = as.character(1:5))\n  )\nclass_color &lt;- c(\"1\" = \"#d7191c\", \"2\" = \"#fdae61\",\n                 \"3\" = \"#ffffbf\", \"4\" = \"#a6d96a\", \n                 \"5\" = \"#1a9641\")\nggplot_map &lt;- ggplot() +\n  geom_sf(\n    data = sigungu_data, \n    aes(fill = index_class, text = SGG1_FNM), \n    show.legend = TRUE\n  ) +\n  geom_sf(\n    data = sido_shp, \n    fill = NA, \n    lwd = 0.5\n  ) +\n  scale_fill_manual(\n    name = \"Classes\", \n    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \n               \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n    values = class_color, drop = FALSE\n  ) +\n  annotation_scale(\n    location = \"br\", \n    bar_cols = c(\"gray40\", \"white\"), \n    width_hint = 0.4\n  )\nggplot_map\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\ntmap_map &lt;- tm_graticules(labels.cardinal = TRUE) +\n  tm_shape(sigungu_data) + \n  tm_polygons(\n    fill = \"index\", id = \"SGG1_FNM\", \n    fill.scale = tm_scale_intervals(\n      values = class_color, \n      breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n      labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \n               \"1.0 ~ 1.5\", \"&gt;= 1.5\")\n    ),\n    fill.legend = tm_legend(title = \"Classes\")\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 1.5) +\n  tm_scalebar(breaks = seq(0, 200, 50)) \ntmap_map",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#인터랙티브-지도-ggplotly-함수",
    "href": "R_lec_10_2025.html#인터랙티브-지도-ggplotly-함수",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "CodeResult\n\n\n\nlibrary(plotly)\nggplotly(world_map)\n\n\n\n\nlibrary(plotly)\nggplotly(world_map)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#인터렉티브-지도-ggiraph-패키지",
    "href": "R_lec_10_2025.html#인터렉티브-지도-ggiraph-패키지",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "CodeResult\n\n\n\nlibrary(ggiraph)\nsigungu_data &lt;- sigungu_data |&gt; \n  mutate(\n    index = format(index, digits = 4, nsmall = 4),\n    my_tooltip = str_c(\"Name: \", SGG1_FNM, \"\\n Index: \", index)\n  )\ngg &lt;- ggplot() +\n  geom_sf_interactive(\n    data = sigungu_data, \n    aes(fill = index_class, tooltip = my_tooltip, data_id = SGG1_FNM), \n    show.legend = TRUE\n  ) +\n  geom_sf(data = sido_shp, fill = NA, lwd = 0.5) +\n  scale_fill_manual(\n    name = \"Classes\", \n    labels = c(\"&lt; 0.2\", \"0.2 ~ 0.5\", \"0.5 ~ 1.0\", \"1.0 ~ 1.5\", \"&gt;= 1.5\"), \n    values = class_color, drop = FALSE\n  ) \ngirafe(ggobj = gg) |&gt; \n  girafe_options(opts_hover(css = \"fill: gray\"))",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#leaflet-자바스크립트-라이브러리",
    "href": "R_lec_10_2025.html#leaflet-자바스크립트-라이브러리",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "R 래퍼 패키지: leaflet\n\n\n\n\nhttps://leafletjs.com/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#leaflet-단순-일반도",
    "href": "R_lec_10_2025.html#leaflet-단순-일반도",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "CodeResult\n\n\n\nlibrary(leaflet)\nleaflet() |&gt; \n  addTiles() |&gt; \n  addPopups(126.955184, 37.460422, \"Sang-Il's Office\",\n            options = popupOptions(closeButton = FALSE))",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#leaflet-매시업mashup-주제도",
    "href": "R_lec_10_2025.html#leaflet-매시업mashup-주제도",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "",
    "text": "세계: Code세계: Result우리나라: Code우리나라: Result\n\n\n\nlibrary(leaflet)\nworld_data &lt;- world_data |&gt; filter(!is.na(TFR))\n\nbins &lt;- c(0, 1.5, 2.1, 3, 4, 5, Inf)\npal &lt;- colorBin(\"YlOrRd\", domain = world_data$TFR, bins = bins)\nlabels &lt;- sprintf(\"&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g\",\n  world_data$name_long, world_data$TFR) |&gt; lapply(htmltools::HTML)\n\nleaflet(world_data) |&gt; \n  addProviderTiles(providers$Esri.WorldTopoMap) |&gt; \n  addPolygons(\n    fillColor = ~pal(TFR), weight =  2, opacity = 1, color = \"white\", \n    dashArray = \"3\", fillOpacity = 0.6,\n    highlightOptions = highlightOptions(\n      weight = 5, color = \"#666\", dashArray = \"\", \n      fillOpacity = 0.6, bringToFront = TRUE\n    ),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"), \n      textsize = \"15px\", direction = \"auto\"\n    )\n  ) |&gt; \n  addLegend(\n    pal = pal, values = ~TFR, opacity = 0.6, title = NULL, position = \"bottomright\"\n  )\n\n\n\n\nlibrary(leaflet)\n\nworld_data &lt;- world_data |&gt; filter(!is.na(TFR))\n\nbins &lt;- c(0, 1.5, 2.1, 3, 4, 5, Inf)\npal &lt;- colorBin(\"YlOrRd\", domain = world_data$TFR, bins = bins)\nlabels &lt;- sprintf(\"&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%g\",\n  world_data$name_long, world_data$TFR) |&gt; lapply(htmltools::HTML)\n\nleaflet(world_data) |&gt; \n  addProviderTiles(providers$Esri.WorldTopoMap) |&gt; \n  addPolygons(\n    fillColor = ~pal(TFR), weight =  2, opacity = 1, color = \"white\", \n    dashArray = \"3\", fillOpacity = 0.6,\n    highlightOptions = highlightOptions(\n      weight = 5, color = \"#666\", dashArray = \"\", \n      fillOpacity = 0.6, bringToFront = TRUE\n    ),\n    label = labels,\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"), \n      textsize = \"15px\", direction = \"auto\"\n    )\n  ) |&gt; \n  addLegend(\n    pal = pal, values = ~TFR, opacity = 0.6, title = NULL, position = \"bottomright\"\n  )\n\n\n\n\n\n\n\n\nlibrary(tmap)\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\nsigungu_data &lt;- sigungu_data |&gt; mutate(index = as.numeric(index))\ntmap_mode(mode = \"view\")\nmy_tmap &lt;- tm_shape(sigungu_data) + \n  tm_polygons(\n    fill = \"index\", fill_alpha = 0.6, col_alpha = 0.5,\n    popup.vars = c(\"지역소멸위험지수: \" = \"index\"), \n    popup.format = list(index = list(digits = 3)), \n    id = \"SGG1_FNM\", \n    fill.scale = tm_scale_intervals(\n      values = class_color, breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n      labels = c(\"&lt; 0.2\", \"0.2~0.5\", \"0.5~1.0\", \"1.0~1.5\", \"&gt;= 1.5\")\n    ),\n    fill.legend = tm_legend(title = \"Classes\")\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 2)\nmy_tmap\n\n\n\n\nclass_color &lt;- c(\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\")\nsigungu_data &lt;- sigungu_data |&gt; mutate(index = as.numeric(index))\ntmap_mode(mode = \"view\")\nmy_tmap &lt;- tm_shape(sigungu_data) + \n  tm_polygons(\n    fill = \"index\", fill_alpha = 0.6, col_alpha = 0.5,\n    popup.vars = c(\"지역소멸위험지수: \" = \"index\"), \n    popup.format = list(index = list(digits = 3)), \n    id = \"SGG1_FNM\", \n    fill.scale = tm_scale_intervals(\n      values = class_color, breaks = c(0, 0.2, 0.5, 1.0, 1.5, Inf), \n      labels = c(\"&lt; 0.2\", \"0.2~0.5\", \"0.5~1.0\", \"1.0~1.5\", \"&gt;= 1.5\")\n    ),\n    fill.legend = tm_legend(title = \"Classes\")\n  ) +\n  tm_shape(sido_shp) + tm_borders(lwd = 2)\nmy_tmap",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#llm-개념",
    "href": "R_lec_10_2025.html#llm-개념",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "LLM: 개념",
    "text": "LLM: 개념\n\nLarge Language Model (거대 언어 모델)\n\n\n\n\nhttps://www.geeksforgeeks.org/artificial-intelligence/large-language-model-llm/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#llm-개념-1",
    "href": "R_lec_10_2025.html#llm-개념-1",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "LLM: 개념",
    "text": "LLM: 개념\n\n\n\nhttps://x.com/samuraipreneur/status/1888530105280168421",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#llm-api-프로그래밍적-접근",
    "href": "R_lec_10_2025.html#llm-api-프로그래밍적-접근",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "LLM API: 프로그래밍적 접근",
    "text": "LLM API: 프로그래밍적 접근\n\nLLM을 웹 인터페이스에서 사용하는 것이 아니라, 코드로 직접 제어하고 자동화하는 방식\nAPI(Application Programming Interface, 응용프로그램 프로그래밍 인터페이스)\n\n응용프로그램(예: 웹 앱)이 프로그래밍을 통해 다른 프로그램이나 서비스(예: ChatGPT)와 상호작용하도록 해 주는 접점\nHTTP 요청(POST) + JSON 구조로 메시지 전달\n모델 이름, 메시지, 파라미터를 코드로 지정\n응답은 JSON 형태의 텍스트/토큰\n\n대량 처리, 반복 처리, 자동화, 소프트웨어 통합",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#llm-api-기본-구조",
    "href": "R_lec_10_2025.html#llm-api-기본-구조",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "LLM API: 기본 구조",
    "text": "LLM API: 기본 구조\n\n요청(request) 구성 요소\n\nBase URL: 모델 서버의 접속 주소, https://api.openai.com/v1\n모델 이름: gpt-5.1\nAPI Key (인증): 사용자 신원 증명 토큰\n메시지: 모델에 보낼 내용, JSON 배열로 구성\n\n응답(response) 구성 요소\n\n모델 출력 텍스트: 모델이 생성한 실제 답변\n토큰 사용량: 과금 및 모델 내부 처리량 계산에 사용\n메시지 구조(JSON)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#사례-google-gemini",
    "href": "R_lec_10_2025.html#사례-google-gemini",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "사례: Google Gemini",
    "text": "사례: Google Gemini\n\nGoogle AI Studio(https://aistudio.google.com/app/) 접속\n\n구글 계정 로그인 필요\n\n왼쪽 하단에서 Get API Key 클릭\n오른쪽 상단에서 API 키 만들기 클릭\n새 키 만들기 창\n\n키 이름 지정: 이름 지정\n가져온 프로젝트 선택: 프로젝트 가져오기 혹은 프로젝트 만들기\n\n오른쪽 아이콘 중 Copy API key 선택",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#사례-google-gemini-1",
    "href": "R_lec_10_2025.html#사례-google-gemini-1",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "사례: Google Gemini",
    "text": "사례: Google Gemini\n\n콘솔: usethis::edit_r_environ() 실행\n.Renviron 파일\n\nGEMINI_API_KEY=your_key_here\n저장\n\nSession &gt; Restart R 실행",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#ellmer-패키지",
    "href": "R_lec_10_2025.html#ellmer-패키지",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "ellmer 패키지",
    "text": "ellmer 패키지\n\n\n\nhttps://ellmer.tidyverse.org/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#ellmer-패키지-1",
    "href": "R_lec_10_2025.html#ellmer-패키지-1",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "ellmer 패키지",
    "text": "ellmer 패키지\n\n코드결과\n\n\n\nlibrary(ellmer)\nchat &lt;- chat_google_gemini(\n  base_url = \"https://generativelanguage.googleapis.com/v1beta/\",\n  api_key = Sys.getenv(\"GEMINI_API_KEY\"),\n  model = \"gemini-2.5-flash\",\n  system_prompt = \"\"\n)\nchat$chat(\"서울대학교 AI융합교육학과를 소개해주세요.\")\n\n\n\n\nlibrary(ellmer)\nchat &lt;- chat_google_gemini(\n  base_url = \"https://generativelanguage.googleapis.com/v1beta/\",\n  api_key = Sys.getenv(\"GEMINI_API_KEY\"),\n  model = \"gemini-2.5-flash\",\n  system_prompt = \"\"\n)\nchat$chat(\"서울대학교 AI융합교육학과를 소개해주세요.\")\n\n서울대학교 AI융합교육학과는 AI 기술과 교육학의 전문성을 결합하여 AI 시대의 교육 혁신을 이끌어갈 인재를 양성하기 위해 설립된 혁신적인 \n학과입니다. 단순히 AI 기술자를 양성하는 것을 넘어, 교육 현장에 AI를 효과적으로 적용하고, AI 시대에 필요한 새로운 교육 패러다임을 \n제시하는 데 중점을 둡니다.\n\n**주요 특징 및 목표:**\n\n1.  **AI와 교육학의 융합:**\n    *   인공지능(AI)의 핵심 원리 및 기술(머신러닝, 딥러닝, 데이터 분석 등)에 대한 깊이 있는 이해를 바탕으로 합니다.\n    *   동시에 교육학 이론, 교수학습 방법론, 교육공학, 교육심리 등 교육학적 통찰력을 결합하여 AI를 교육적으로 활용할 수 있는 \n역량을 키웁니다.\n    *   AI 기반 교수학습 시스템 개발, 지능형 튜터링 시스템 설계, 교육 데이터 분석 및 활용, AI 교육 콘텐츠 기획 및 제작 등을\n다룹니다.\n\n2.  **미래 교육 혁신 선도:**\n    *   AI 기술이 교육에 미치는 긍정적 영향뿐만 아니라 윤리적, 사회적 문제에 대한 이해를 바탕으로 AI 시대에 적합한 교육 방향을 \n모색합니다.\n    *   개별 학습자 맞춤형 교육, 협력 학습 환경 조성, 평가 방식 혁신 등 AI 기반 교육 혁신 모델을 연구하고 구현하는 데 \n주력합니다.\n\n3.  **실천적 문제 해결 능력 함양:**\n    *   이론 학습을 넘어 실제 교육 현장의 문제를 AI 기술로 해결하는 프로젝트 기반 학습을 강조합니다.\n    *   교육 현장과 연계된 실습, 인턴십 등을 통해 실무 역량을 강화합니다.\n\n4.  **다학제적 접근:**\n    *   컴퓨터 과학, 데이터 과학, 인지 과학, 교육학 등 다양한 학문 분야의 지식을 통합적으로 학습하여 융합적 사고 능력을 키웁니다.\n\n**교육과정 (예시, 실제 커리큘럼은 변경될 수 있음):**\n\n*   **AI 기초:** 인공지능 개론, 프로그래밍, 자료구조, 알고리즘, 머신러닝 기초, 딥러닝 기초 등\n*   **교육학 심화:** 교육학 개론, 교육심리학, 교육철학, 교수학습이론, 교육공학, 교육과정 및 평가 등\n*   **AI융합 교육 특화:** AI와 교육, 지능형 학습 시스템 설계, 교육 데이터 분석 및 시각화, AI 기반 교육 콘텐츠 개발, \n에듀테크 스타트업 실무, AI 윤리와 교육, 미래 교육과 기술 등\n\n**졸업 후 진로:**\n\nAI융합교육학과 졸업생들은 AI 기술과 교육학적 전문성을 동시에 갖춘 융합 인재로서 다양한 분야에서 활약할 수 있습니다.\n\n*   **에듀테크 기업:** AI 기반 교육 콘텐츠 개발자, 교육 솔루션 기획자, 데이터 분석가, 서비스 운영자 등\n*   **정부 및 공공기관:** AI 교육 정책 전문가, 교육 시스템 개발 및 관리자, 교육 연구원 등\n*   **학교 및 교육기관:** AI 활용 교육 전문가, 미래 교육 과정 기획자, 교수학습 지원 전문가 등\n*   **일반 기업:** 기업 교육 및 HRD 부서의 AI 기반 인재 개발 전문가\n*   **연구기관:** AI 교육 분야 전문 연구원\n*   **창업:** 에듀테크 스타트업 창업\n*   **대학원 진학:** AI, 교육공학, 컴퓨터 과학 등 관련 분야 심화 학습\n\n서울대학교 AI융합교육학과는 AI 시대의 교육 혁신을 주도하며 새로운 지평을 열어갈 핵심 인재 양성의 요람이 될 것입니다. AI 기술에 대한 \n흥미와 교육 분야에 대한 열정을 가진 학생들에게 매우 적합한 학과입니다.",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#로컬-llm-ollama",
    "href": "R_lec_10_2025.html#로컬-llm-ollama",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "로컬 LLM: Ollama",
    "text": "로컬 LLM: Ollama\n\nOllama 홈페이지 접속: https://ollama.com/\nDownload 클릭\n\nWindows / macOS / Linux 중 하나를 선택\n\n모델 다운로드: Windows PowerShell 실행\n\nollama pull gemma3:4b\n\n실행",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#로컬-llm-ollama-1",
    "href": "R_lec_10_2025.html#로컬-llm-ollama-1",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "로컬 LLM: Ollama",
    "text": "로컬 LLM: Ollama\n\n코드결과\n\n\n\nlibrary(ellmer)\nchat &lt;- chat_ollama(\n  base_url = \"http://localhost:11434\",\n  model = \"gemma3:4b\",\n  system_prompt = \"\"\n)\nchat$chat(\"서울대학교 AI융합교육학과를 소개해주세요.\")\n\n\n\n\nlibrary(ellmer)\nchat &lt;- chat_ollama(\n  base_url = \"http://localhost:11434\",\n  model = \"gemma3:4b\",\n  system_prompt = \"\"\n)\nchat$chat(\"서울대학교 AI융합교육학과를 소개해주세요.\")\n\n서울대학교 AI융합교육학과(이하 AI융합학과)는 인공지능(AI) 기술이 빠르게 발전하면서 교육 분야에 미치는 영향에 주목하여, AI 기술과 \n교육을 융합적으로 이해하고 활용하는 인재를 양성하기 위해 설립된 학과입니다. 2023년 신설되었으며, AI 기술을 교육 분야에 적용하는 방법을\n연구하고 교육하는 데 집중하고 있습니다.\n\n**학과 특징 및 목표:**\n\n*   **AI와 교육의 융합:** AI 기술을 단순히 활용하는 것을 넘어, 교육 과정 설계, 학습 방법, 평가 방법 등 교육의 전반에 걸쳐 \nAI 기술이 어떻게 혁신을 가져올 수 있는지 탐구합니다.\n*   **융합적 사고 능력:** 교육학, 컴퓨터 과학, 인지과학, 심리학 등 다양한 분야의 지식을 융합하여 교육 문제를 해결하고 새로운 교육\n모델을 개발하는 능력을 키웁니다.\n*   **실용적인 AI 교육 콘텐츠 개발:** AI 기술을 활용한 교육 솔루션, 학습 콘텐츠, 평가 시스템 등을 개발하고 적용하는 실무 \n능력을 배양합니다.\n*   **미래 교육을 선도하는 인재 양성:** AI 기술 발전에 발맞춰 미래 교육 환경을 예측하고, 새로운 교육 패러다임을 제시하는 리더를 \n육성합니다.\n\n**주요 교육 내용:**\n\n*   **기초 교양:** 교육학 원론, 인지심리학, 통계학 등 교육 및 AI 분야의 기초 지식을 다룹니다.\n*   **핵전공:**\n    *   AI 기초 (머신러닝, 딥러닝, 자연어 처리 등)\n    *   교육용 AI 시스템 개발\n    *   AI 기반 학습 콘텐츠 설계 및 개발\n    *   AI 윤리 및 교육\n*   **교양:** AI, 빅데이터, 데이터 분석 등의 최신 기술 동향을 학습합니다.\n*   **선택 과목:** 교육 평가, 교육 심리, 교육 공학 등 다양한 분야의 선택 과목을 통해 전문성을 심화합니다.\n\n**졸업 목표:**\n\nAI 기술을 활용하여 교육 혁신을 주도하고, 미래 교육 환경을 선도할 수 있는 인재를 목표로 합니다. 구체적으로 다음과 같은 역량을 갖추게 \n됩니다.\n\n*   AI 기술을 교육 현장에 적용하는 비즈니스 모델을 설계하고 개발할 수 있습니다.\n*   AI 기반의 맞춤형 학습 시스템을 구축하고 운영할 수 있습니다.\n*   AI 윤리 문제를 고려하여 교육용 AI 시스템을 개발하고 사용할 수 있습니다.\n*   교육 분야의 새로운 트렌드를 분석하고, 미래 교육을 위한 전략을 제시할 수 있습니다.\n\n**더 자세한 정보는 다음 링크에서 확인하실 수 있습니다.**\n\n*   **서울대학교 AI융합교육학과 홈페이지:** \n[https://www.snu.ac.kr/ai_edu/](https://www.snu.ac.kr/ai_edu/)\n*   **학과 소개 영상:** \n[https://www.youtube.com/watch?v=lFp-N0qQ93I](https://www.youtube.com/watch?v=lFp-N0qQ93I)\n\n궁금한 점이 있으시면 언제든지 다시 질문해주세요.",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_10_2025.html#llm과-웹-앱",
    "href": "R_lec_10_2025.html#llm과-웹-앱",
    "title": "R Lecture 10\n웹 앱 개발: 심화",
    "section": "LLM과 웹 앱",
    "text": "LLM과 웹 앱\n\nshiny: 서버형 웹 앱 개발 프레임워크\nshinychat: LLM shiny 웹 앱 개발 도우미 패키지\n\nellmer 패키지와 결합\n\n예시: https://sangillee.shinyapps.io/KosisChat/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 10]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 심화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html",
    "href": "R_lec_08_2025.html",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "",
    "text": "https://r4ds.hadley.nz/import.html\n\n\n\n\n\n\n웹스크레이핑(webscraping)\n오픈 API의 활용",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#데이터사이언스-프로세스",
    "href": "R_lec_08_2025.html#데이터사이언스-프로세스",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "",
    "text": "https://r4ds.hadley.nz/import.html",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#데이터-수집-방법",
    "href": "R_lec_08_2025.html#데이터-수집-방법",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "",
    "text": "웹스크레이핑(webscraping)\n오픈 API의 활용",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#웹스크레이핑의-정의",
    "href": "R_lec_08_2025.html#웹스크레이핑의-정의",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "웹스크레이핑의 정의",
    "text": "웹스크레이핑의 정의\n\n웹페이지로부터 데이터를 추출하는 것, 데이터 긁어 오기\n데이터 크롤링(crawling)과 유사, 박박 기면서 수집하기\n해킹(hacking)과의 경계가 모호\n\n허가 없이 정보 시스템에 침투하여 데이터를 취득하는 행위\n\n최근들어 점점 회피하는 추세",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#html의-정의",
    "href": "R_lec_08_2025.html#html의-정의",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "HTML의 정의",
    "text": "HTML의 정의\n\nHyperText Markup Language, 하이퍼텍스터 마크업 언어\n\n웹 브라우저를 통해 표출되는 사항(무엇이 어떻게)을 프로그래밍하는 마크업(markup) 언어 혹은 웹 다큐먼트를 작성하는 마크업 언어\n\n마크업 언어: 다큐먼트의 구조와 포맷을 관장하는 텍스트-엔코딩 시스템\n\n\n마크다운(markdown) 언어\n\n사용자의 편이성이 강화된 마크업 언어\nQuarto: 비주얼 에디터",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#html의-기초",
    "href": "R_lec_08_2025.html#html의-기초",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "HTML의 기초",
    "text": "HTML의 기초\n\n웹페이지는 다양한 태그(tag)로 구성\n\n각 태그는 시작 태그와 종료 태그로 구성되며, 둘 사이에 해당 콘텐츠가 위치\n\n태그의 종류는 다양하며, 크게 세 가지로 구분\n\n최상위인 html 태그\n웹페이지의 전반적인 구조를 결정하는 블록(block) 태그\n\n예: h1, section, p, ol 태그 등\n\n블록 태그 내부의 특정 부분에만 적용되는 인라인(inline) 태그\n\n예: b, i, a 태그 등",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#html의-기초-1",
    "href": "R_lec_08_2025.html#html의-기초-1",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "HTML의 기초",
    "text": "HTML의 기초\n\n태그들은 복잡한 다단계 구조를 이룸\n태그는 속성(attribute)를 가질 수 있음\n\n특별히 중요한 속성: 클래스(class), 아이디(id)\np나 div 태그와 같은 블록 태그: height, width, margin, padding\nimg 태그: src, alt, width, height\na 태그: href",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#section",
    "href": "R_lec_08_2025.html#section",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "",
    "text": "https://odinuv.cz/articles/html/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#html-엘리먼트의-선택",
    "href": "R_lec_08_2025.html#html-엘리먼트의-선택",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "HTML 엘리먼트의 선택",
    "text": "HTML 엘리먼트의 선택\n\nHTML 엘리먼트\n\n태그와 속성으로 구성된 HTML의 한 단위 혹은 특정 부분\n웹스크레이핑의 타깃의 주소\n\nHTML 엘리먼트의 선택: CSS 선택자(casading style sheet selector)\n\n\n\n\n\n\n\n\n\n\n선택 대상\nCSS 선택자\n결과\n\n\n\n\n태그(tag)\ntag1\n“tag1”이라는 이름의 모든 tag\n\n\n클래스(class)\n.class1\n“class1”이라는 class 속성을 갖는 모든 요소\n\n\n아이디(id)\n#id1\n“id1”이라는 id 속성을 갖는 모든 요소\n\n\ntag와 class의 결합\ntag1.class1\n“tag1”이라는 tag의 “class1”이라는 class 속성을 갖는 모든 요소\n\n\nclass1과 class2의 결합\n.class1.class2\n“class1”이라는 이름의 class 속성과 “class2”라는 이름의 class 속성을 동시에 갖는 모든 요소",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#html-엘리먼트의-선택-1",
    "href": "R_lec_08_2025.html#html-엘리먼트의-선택-1",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "HTML 엘리먼트의 선택",
    "text": "HTML 엘리먼트의 선택\n\n정확한 CSS 선택자의 확인\n\n웹페이지에서 오른쪽 마우스 버튼을 눌러 “검사” 선택한 뒤, 탐색\n브라우저 확장 프로그램의 활용: SelectGadget",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#rvest-패키지",
    "href": "R_lec_08_2025.html#rvest-패키지",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "rvest 패키지",
    "text": "rvest 패키지\n\n\n\nhttps://rvest.tidyverse.org/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#rvest-패키지를-활용한-웹스크레이핑-절차",
    "href": "R_lec_08_2025.html#rvest-패키지를-활용한-웹스크레이핑-절차",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "rvest 패키지를 활용한 웹스크레이핑 절차",
    "text": "rvest 패키지를 활용한 웹스크레이핑 절차\n\n1단계: 웹페이지 읽기\n\n웹스크레이핑의 대상이 되는 웹페이지의 URL 읽기\n\n2단계: HTML 엘리먼트 선택\n\n필요한 정보를 포함하고 있는 엘리먼트의 지정\n\n3단계: 하위 엘리먼트 선택\n\n필요한 정보를 포함하고 있는 하위 엘리먼트의 지정\n\n4단계: 엘리먼트로부터 데이터 추출\n\n데이블 데이터, 텍스트 등을 추출",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#사례-1-스타워즈",
    "href": "R_lec_08_2025.html#사례-1-스타워즈",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "사례 1: 스타워즈",
    "text": "사례 1: 스타워즈\nvignette(“starwars”)\n\n&lt;section&gt;\n  &lt;h2 data-id=\"1\"&gt;The Phantom Menace&lt;/h2&gt;\n  &lt;p&gt;Released: 1999-05-19&lt;/p&gt;\n  &lt;p&gt;Director: &lt;span class=\"director\"&gt;George Lucas&lt;/span&gt;&lt;/p&gt;\n  \n  &lt;div class=\"crawl\"&gt;\n    &lt;p&gt;...&lt;/p&gt;\n    &lt;p&gt;...&lt;/p&gt;\n    &lt;p&gt;...&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/section&gt;",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#사례-1-스타워즈-1",
    "href": "R_lec_08_2025.html#사례-1-스타워즈-1",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "사례 1: 스타워즈",
    "text": "사례 1: 스타워즈\n\nCode 1Result 1Code 2Result 2\n\n\n\nlibrary(tidyverse)\nlibrary(rvest)\nurl &lt;- \"https://rvest.tidyverse.org/articles/starwars.html\"\nread_html(url) |&gt; \n  html_elements(\"section\") |&gt; \n  html_element(\"h2\") |&gt; \n  html_text2()\n\n\n\n\nlibrary(tidyverse)\nlibrary(rvest)\nurl &lt;- \"https://rvest.tidyverse.org/articles/starwars.html\"\nread_html(url) |&gt; \n  html_elements(\"section\") |&gt; \n  html_element(\"h2\") |&gt; \n  html_text2()\n\n[1] \"The Phantom Menace\"      \"Attack of the Clones\"   \n[3] \"Revenge of the Sith\"     \"A New Hope\"             \n[5] \"The Empire Strikes Back\" \"Return of the Jedi\"     \n[7] \"The Force Awakens\"      \n\n\n\n\n\nsection &lt;- read_html(url) |&gt; \n  html_elements(\"section\")\ntibble(\n  title = section |&gt; \n    html_element(\"h2\") |&gt; \n    html_text2(),\n  released = section |&gt; \n    html_element(\"p\") |&gt; \n    html_text2() |&gt; \n    str_remove(\"Released: \") |&gt; \n    parse_date(),\n  director = section |&gt; \n    html_element(\".director\") |&gt; \n    html_text2(),\n  intro = section |&gt; \n    html_element(\".crawl\") |&gt; \n    html_text2()\n)\n\n\n\n\n\n# A tibble: 7 × 4\n  title                   released   director         intro                     \n  &lt;chr&gt;                   &lt;date&gt;     &lt;chr&gt;            &lt;chr&gt;                     \n1 The Phantom Menace      1999-05-19 George Lucas     \"Turmoil has engulfed the…\n2 Attack of the Clones    2002-05-16 George Lucas     \"There is unrest in the G…\n3 Revenge of the Sith     2005-05-19 George Lucas     \"War! The Republic is cru…\n4 A New Hope              1977-05-25 George Lucas     \"It is a period of civil …\n5 The Empire Strikes Back 1980-05-17 Irvin Kershner   \"It is a dark time for th…\n6 Return of the Jedi      1983-05-25 Richard Marquand \"Luke Skywalker has retur…\n7 The Force Awakens       2015-12-11 J. J. Abrams     \"Luke Skywalker has vanis…",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#사례-2-웹-상의-테이블",
    "href": "R_lec_08_2025.html#사례-2-웹-상의-테이블",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "사례 2: 웹 상의 테이블",
    "text": "사례 2: 웹 상의 테이블\n위키피디어: 전 세계 국가 관련 항목\n\nCode 1Result 1Code 2Result 2\n\n\n\nlibrary(tidyverse)\nlibrary(rvest)\nurl &lt;- \"https://en.wikipedia.org/wiki/List_of_countries_and_dependencies_by_population\"\nmy_table &lt;- url |&gt; \n  read_html() |&gt; \n  html_element(\"table\") |&gt; \n  html_table()\n\n\n\n\nmy_table\n\n# A tibble: 240 × 6\n   Location      Population    `% ofworld` Date     Source (official or …¹ Notes\n   &lt;chr&gt;         &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;                  &lt;chr&gt;\n 1 World         8,232,000,000 100%        13 Jun … UN projection[1][3]    \"\"   \n 2 India         1,417,492,000 17.2%       1 Jul 2… Official projection[4] \"[b]\"\n 3 China         1,408,280,000 17.1%       31 Dec … Official estimate[5]   \"[c]\"\n 4 United States 340,110,988   4.1%        1 Jul 2… Official estimate[6]   \"[d]\"\n 5 Indonesia     284,438,782   3.5%        30 Jun … National annual proje… \"\"   \n 6 Pakistan      241,499,431   2.9%        1 Mar 2… 2023 census result[8]  \"[e]\"\n 7 Nigeria       223,800,000   2.7%        1 Jul 2… Official projection[9] \"\"   \n 8 Brazil        213,421,037   2.6%        1 Jul 2… Official estimate[10]  \"\"   \n 9 Bangladesh    169,828,911   2.1%        14 Jun … 2022 census result[11] \"[f]\"\n10 Russia        146,028,325   1.8%        1 Jan 2… Official estimate[13]  \"[g]\"\n# ℹ 230 more rows\n# ℹ abbreviated name: ¹​`Source (official or fromthe United Nations)`\n\n\n\n\n\nmy_table_new &lt;- my_table |&gt; \n  select(-Notes) |&gt; \n  rename(\n    location = \"Location\",\n    population = \"Population\",\n    pop_pct = \"% ofworld\",\n    date = \"Date\",\n    source = \"Source (official or fromthe United Nations)\"\n  ) |&gt; \n  mutate(\n    population = parse_number(population, \",\"),\n    population = as.numeric(population),\n    pop_pct = str_remove_all(pop_pct, \"%\"),\n    pop_pct = as.numeric(pop_pct),\n    date = dmy(date)\n  )\n\n\n\n\nmy_table_new \n\n# A tibble: 240 × 5\n   location      population pop_pct date       source                       \n   &lt;chr&gt;              &lt;dbl&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;                        \n 1 World         8232000000   100   2025-06-13 UN projection[1][3]          \n 2 India         1417492000    17.2 2025-07-01 Official projection[4]       \n 3 China         1408280000    17.1 2024-12-31 Official estimate[5]         \n 4 United States  340110988     4.1 2024-07-01 Official estimate[6]         \n 5 Indonesia      284438782     3.5 2025-06-30 National annual projection[7]\n 6 Pakistan       241499431     2.9 2023-03-01 2023 census result[8]        \n 7 Nigeria        223800000     2.7 2023-07-01 Official projection[9]       \n 8 Brazil         213421037     2.6 2025-07-01 Official estimate[10]        \n 9 Bangladesh     169828911     2.1 2022-06-14 2022 census result[11]       \n10 Russia         146028325     1.8 2025-01-01 Official estimate[13]        \n# ℹ 230 more rows",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#api의-정의",
    "href": "R_lec_08_2025.html#api의-정의",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "API의 정의",
    "text": "API의 정의\n\nAPI(application programming interface)는 일종의 통신 규약(protocol)\n\n복수의 프로그램들이 서로 상호작용하는 방법을 정의하는 일련의 규칙\n한 애플리케이션이 다른 애플리케이션의 기능들을 불러 사용할 수 있게 해주는 통로\n오픈 API: API 키(key)\n\n데이터 API\n\n데이터를 보유하고 있는 공적 기관이 데이터의 사용 권한을 사용자들에게 부여함으로써 데이터에 대한 접근성을 높여주는 일련의 방식",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#api-활용의-다양성",
    "href": "R_lec_08_2025.html#api-활용의-다양성",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "API 활용의 다양성",
    "text": "API 활용의 다양성\n\n정형 수치 데이터의 수집\n\nKOSIS의 API를 활용한 센서스 데이터 수집\n공공데이터포털 API를 활용한 전국 초중등학교 위치 데이터 수집\nInternational Database(IDB)의 API를 활용한 세계 인구 데이터 수집\n\n정형 텍스트 데이터 수집\n\n공공데이터포털 API를 활용한 학위 논문의 수집\n\n비정형 텍스트 데이터 수집: 텍스트 마이닝(text mining)으로 연결\n\n네이버 검색 API를 활용한 뉴스 데이터 수집\n유튜브 API를 활용한 댓글 데이터 수집",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#api-활용의-다양성-1",
    "href": "R_lec_08_2025.html#api-활용의-다양성-1",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "API 활용의 다양성",
    "text": "API 활용의 다양성\n\nGoogle Maps Platform (https://mapsplatform.google.com/)\n7 종류의 API\n\nGoogle Direction API\nGoogle Distance API\nGoogle Elevation API\nGoogle Timezone API\nGoogle Geocode API\nGoogle Reverse Geocode API\nGoogle Places API\n\nR 래퍼(rapper) 패키지: googleway",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#httr2-패키지",
    "href": "R_lec_08_2025.html#httr2-패키지",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "httr2 패키지",
    "text": "httr2 패키지\n\n\n\nhttps://httr.r-lib.org/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#사례-공공데이터포털",
    "href": "R_lec_08_2025.html#사례-공공데이터포털",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "사례: 공공데이터포털",
    "text": "사례: 공공데이터포털\n\nhttps://www.data.go.kr/\n회원가입\n데이터 검색: “전국 초중등학교 위치”\nOpen API, 인증키\n\nBase URL: api.odcloud.kr/api\n일반 인증키(Decoding)\n데이터 API: /15099519/v1/uddi:e83bc47a-f235-4b44-96d8-a9d0686435a5",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#사례-공공데이터포털-1",
    "href": "R_lec_08_2025.html#사례-공공데이터포털-1",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "사례: 공공데이터포털",
    "text": "사례: 공공데이터포털\n\nCode 1Result 1Code 2Result 2\n\n\n\nlibrary(httr2)\nbase_url &lt;- \"https://api.odcloud.kr/api/15099519/v1/uddi:e83bc47a-f235-4b44-96d8-a9d0686435a5\" \nrequest(base_url) |&gt;\n  req_url_query(\n    serviceKey = your_api_key,\n    page = 1,\n    perPage = 1000\n  ) |&gt;\n  req_perform() |&gt; \n  resp_body_json() |&gt; \n  _[[\"data\"]] |&gt; bind_rows() |&gt; as_tibble() |&gt; slice_head(n = 5)\n\n\n\n\n\n# A tibble: 5 × 18\n  경도          교육지원청명 교육지원청코드 데이터기준일자 변경일자 본교분교구분\n  &lt;chr&gt;         &lt;chr&gt;                 &lt;int&gt; &lt;chr&gt;          &lt;chr&gt;    &lt;chr&gt;       \n1 126.83075160… 전북특별자치도정읍교육…        8362000 2025-09-22     2025-07… 본교        \n2 126.62621220… 인천광역시서부교육지원…        7361000 2025-09-22     2025-07… 본교        \n3 127.61483550… 전북특별자치도장수교육…        8422000 2025-09-22     2025-07… 본교        \n4 129.39651960… 경상북도포항교육지원청…        8761000 2025-09-22     2025-07… 본교        \n5 129.07938730… 부산광역시동래교육지원…        7191000 2025-09-22     2025-07… 본교        \n# ℹ 12 more variables: 생성일자 &lt;chr&gt;, 설립일자 &lt;chr&gt;, 설립형태 &lt;chr&gt;,\n#   소재지도로명주소 &lt;chr&gt;, 소재지지번주소 &lt;chr&gt;, 시도교육청명 &lt;chr&gt;,\n#   시도교육청코드 &lt;int&gt;, 운영상태 &lt;chr&gt;, 위도 &lt;chr&gt;, 학교ID &lt;chr&gt;,\n#   학교급구분 &lt;chr&gt;, 학교명 &lt;chr&gt;\n\n\n\n\n\nfinal_data &lt;- map_dfr(1:12, function(p) {\n  request(base_url) |&gt;\n    req_url_query(\n      serviceKey = your_api_key, \n      page = p, \n      perPage = 1000) |&gt;\n    req_perform() |&gt;\n    resp_body_json() |&gt;\n    _[[\"data\"]] |&gt; bind_rows() |&gt; as_tibble()\n})\n\n\n\n\nfinal_data\n\n# A tibble: 12,000 × 18\n   경도         교육지원청명 교육지원청코드 데이터기준일자 변경일자 본교분교구분\n   &lt;chr&gt;        &lt;chr&gt;                 &lt;int&gt; &lt;chr&gt;          &lt;chr&gt;    &lt;chr&gt;       \n 1 126.8307516… 전북특별자치도정읍교육…        8362000 2025-09-22     2025-07… 본교        \n 2 126.6262122… 인천광역시서부교육지원…        7361000 2025-09-22     2025-07… 본교        \n 3 127.6148355… 전북특별자치도장수교육…        8422000 2025-09-22     2025-07… 본교        \n 4 129.3965196… 경상북도포항교육지원청…        8761000 2025-09-22     2025-07… 본교        \n 5 129.0793873… 부산광역시동래교육지원…        7191000 2025-09-22     2025-07… 본교        \n 6 128.8886173… 경상남도김해교육지원청…        9091000 2025-09-22     2025-07… 본교        \n 7 128.0643803… 경상남도사천교육지원청…        9081000 2025-09-22     2025-07… 본교        \n 8 126.4853077… 전라남도무안교육지원청…        8661000 2025-09-22     2025-07… 본교        \n 9 126.7792304… 경기도파주교육지원청……        7681000 2025-09-22     2025-07… 본교        \n10 128.5672852… 대구광역시서부교육지원…        7261000 2025-09-22     2025-07… 본교        \n# ℹ 11,990 more rows\n# ℹ 12 more variables: 생성일자 &lt;chr&gt;, 설립일자 &lt;chr&gt;, 설립형태 &lt;chr&gt;,\n#   소재지도로명주소 &lt;chr&gt;, 소재지지번주소 &lt;chr&gt;, 시도교육청명 &lt;chr&gt;,\n#   시도교육청코드 &lt;int&gt;, 운영상태 &lt;chr&gt;, 위도 &lt;chr&gt;, 학교ID &lt;chr&gt;,\n#   학교급구분 &lt;chr&gt;, 학교명 &lt;chr&gt;",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#사례-kosis",
    "href": "R_lec_08_2025.html#사례-kosis",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "사례: KOSIS",
    "text": "사례: KOSIS\n\nKOSIS 공유서비스 웹페이지(https://kosis.kr/openapi/) 접속\n상단의 [활용신청] 탭 클릭\n\n통계청의 ONE-ID로 통합로그인(없으면 회원가입 필수)\n\n활용신청하여 사용자 인증키 획득\n\n사용자 인증키는 마이페이지에서 언제든 확인 가능\n\nkosis 패키지: 주석훈",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#사례-kosis-1",
    "href": "R_lec_08_2025.html#사례-kosis-1",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "사례: KOSIS",
    "text": "사례: KOSIS\n\nhttps://sangillee.snu.ac.kr/dashboard_popgeo/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#사례-네이버-뉴스",
    "href": "R_lec_08_2025.html#사례-네이버-뉴스",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "사례: 네이버 뉴스",
    "text": "사례: 네이버 뉴스\n\nNAVER Developer (https://developers.naver.com/main/)\n[Products]-[서비스 API]-[검색] (https://developers.naver.com/products/service-api/search/search.md)\n\n오픈 API 이용 신청 절차\nClientID와 Client Secret 개념\n요청 URL: https://openapi.naver.com/v1/search/news.json\n파라미터: query, display, start, sort\n\n오픈 API 이용 신청\n\n애플리케이션 이름: 아무 이름이나 입력\n사용 API: ’검색’이 선택된 상태를 유지\n비로그인 오픈 API 서비스 환경: ‘WEB’ 설정\n웹 서비스 URL (최대 10개): ’http://localhost’를 입력",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#사례-네이버-뉴스-1",
    "href": "R_lec_08_2025.html#사례-네이버-뉴스-1",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "사례: 네이버 뉴스",
    "text": "사례: 네이버 뉴스\n\nCode 1Result 1Code 2Result 2\n\n\n\nlibrary(httr2)\nsearch &lt;- \"지역소멸\"\nbase_url &lt;- \"https://openapi.naver.com/v1/search/news.json\"\nresult_naver &lt;- base_url |&gt; \n  request() |&gt; \n  req_headers(\n    \"X-Naver-Client-ID\" = your_ClientID,\n    \"X-Naver-Client-Secret\" = your_Client_Secret\n  ) |&gt; \n  req_url_query(\n    query = search,\n    display = 100,\n    start = 1,\n    sort = \"date\"\n  ) |&gt; \n  req_perform() |&gt; \n  resp_body_json(check_type = FALSE) |&gt; \n  pluck(\"items\") |&gt; bind_rows()\n\n\n\n\nresult_naver |&gt; slice_head(n = 5)\n\n# A tibble: 5 × 5\n  title                                   originallink link  description pubDate\n  &lt;chr&gt;                                   &lt;chr&gt;        &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;  \n1 담양군 한국대나무박물관, '박구환 작가 특별 초대전' 열어…… http://www.… http… \"박구환 작가는 1… Fri, 0…\n2 순창발효관광재단, 주민참여형 축제로 도지사 표창…… https://www… http… \"전북 순창발효관광… Fri, 0…\n3 의령곤충생태학습관, 2025년 관람객 개관 이후 최다…… https://www… http… \"&lt;b&gt;지역&lt;/b&gt;… Fri, 0…\n4 담양군 한국대나무박물관, 박구환 작가 특별 초대전 개최…… https://www… http… \"박구환 작가는 1… Fri, 0…\n5 심민 임실군수 민생지원금 20만원 빠르게 추진 당부…… http://www.… http… \"사용기간이 지나면… Fri, 0…\n\n\n\n\n\nnaver_extractor &lt;- function(base_url, search_item, n_start = 1, n_display = 100){\n  news &lt;- request(base_url) |&gt; \n  req_headers(\n    \"X-Naver-Client-ID\" = your_ClientID,\n    \"X-Naver-Client-Secret\" = your_Client_Secret\n  ) |&gt; \n  req_url_query(\n    query = search_item,\n    display = n_display,\n    start = n_start,\n    sort = \"date\"\n  ) |&gt; \n  req_perform() |&gt; \n  resp_body_json() |&gt; pluck(\"items\") |&gt; bind_rows()\n}\n\nsearch &lt;- \"지역소멸\"\nrep &lt;- 10\nresult_naver &lt;- map_dfr(\n  start_idx &lt;- (0:(rep-1)) * 100 + 1,\n  \\(x) naver_extractor(\n    a_url       = your_url,\n    search_item = search,\n    n_start     = x,\n    n_display = 100\n  )\n)\n\n\n\n\nresult_naver |&gt; slice_head(n = 5)\n\n# A tibble: 5 × 5\n  title                                   originallink link  description pubDate\n  &lt;chr&gt;                                   &lt;chr&gt;        &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;  \n1 담양군 한국대나무박물관, '박구환 작가 특별 초대전' 열어…… http://www.… http… \"박구환 작가는 1… Fri, 0…\n2 순창발효관광재단, 주민참여형 축제로 도지사 표창…… https://www… http… \"전북 순창발효관광… Fri, 0…\n3 의령곤충생태학습관, 2025년 관람객 개관 이후 최다…… https://www… http… \"&lt;b&gt;지역&lt;/b&gt;… Fri, 0…\n4 담양군 한국대나무박물관, 박구환 작가 특별 초대전 개최…… https://www… http… \"박구환 작가는 1… Fri, 0…\n5 심민 임실군수 민생지원금 20만원 빠르게 추진 당부…… http://www.… http… \"사용기간이 지나면… Fri, 0…",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#텍스트-마이닝과-자연어처리",
    "href": "R_lec_08_2025.html#텍스트-마이닝과-자연어처리",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "텍스트 마이닝과 자연어처리",
    "text": "텍스트 마이닝과 자연어처리\n\n텍스트 마이닝\n\n비정형 텍스트 데이터로부터 패턴 또는 관계를 추출하여 의미 있는 정보를 찾아내는 기법\n기본 과정: 텍스트 전처리, 토큰화하기, 단어 빈도 분석하기\n고급 분석: 비교 분석, 감정 분석, 의미망 분석, 토픽 모델링 등\n\n자연어처리(NLP; natural language processing)\n\nKoNLP(Korean Natural Language Processing)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_08_2025.html#mall-패키지",
    "href": "R_lec_08_2025.html#mall-패키지",
    "title": "R Lecture 8\n데이터 수집하기",
    "section": "mall 패키지",
    "text": "mall 패키지\n\n\n\nhttps://mlverse.github.io/mall/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 8]{style=\"color:coral;font-size:0.6em\"}\n| [데이터 수집하기]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html",
    "href": "R_lec_01_2025.html",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://www.mdpi.com/2075-1729/12/5/648\n\n\n\n\nhttps://en.wikipedia.org/wiki/Bell_Labs\n\n\n\n\n\n\n\nhttps://knihobot.cz/g/485637\n\n\n\n\n\nhttps://link.springer.com/book/10.1007/978-1-4615-7826-0\n\n\n\n\n\n\n\n\n\n\n조지 로스 이하카 George Ross Ihaka\n\n\n\n\n\n오클랜드 대학 University of Auckland\n\n\n\n\n\n로버트 젠틀맨 Robert C. Gentleman\n\n\n\n\n\n\n\nhttps://www.r-consortium.org/blog/2023/02/28/happy-23rd-birthday-r\n\n\n\n\n\n\n\nhttps://ggplot2.tidyverse.org/\n\n\n\n \n\n\n\n\n해들리 위컴(Hadley Wickham), posit\n\n\n\n\n\n\n\nhttps://posit.co/download/rstudio-desktop/\n\n\n\n\n\n\n\n\n\n\nhttps://shiny.posit.co/\n\n\n\n\n\n\n\n\n\n\nhttps://www.tidyverse.org/\n\n\n\n \n\n\n\n\nhttps://www.tidyverse.org/\n\n\n\n\n\n\n\nhttps://posit.co/\n\n\n\n\n\n\n\nhttps://quarto.org/\n\n\n\n\n\nhttps://rstudio.github.io/cheatsheets/html/quarto.html",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#주요-사건들",
    "href": "R_lec_01_2025.html#주요-사건들",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://www.mdpi.com/2075-1729/12/5/648",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#bell-labs-in-1975",
    "href": "R_lec_01_2025.html#bell-labs-in-1975",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://en.wikipedia.org/wiki/Bell_Labs",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#s-plus-1997",
    "href": "R_lec_01_2025.html#s-plus-1997",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://knihobot.cz/g/485637\n\n\n\n\n\nhttps://link.springer.com/book/10.1007/978-1-4615-7826-0",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#fathers-of-r-1993",
    "href": "R_lec_01_2025.html#fathers-of-r-1993",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "조지 로스 이하카 George Ross Ihaka\n\n\n\n\n\n오클랜드 대학 University of Auckland\n\n\n\n\n\n로버트 젠틀맨 Robert C. Gentleman",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#official-birth",
    "href": "R_lec_01_2025.html#official-birth",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://www.r-consortium.org/blog/2023/02/28/happy-23rd-birthday-r",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#ggplot2-2007",
    "href": "R_lec_01_2025.html#ggplot2-2007",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://ggplot2.tidyverse.org/\n\n\n\n \n\n\n\n\n해들리 위컴(Hadley Wickham), posit",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#rstudio-2011",
    "href": "R_lec_01_2025.html#rstudio-2011",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://posit.co/download/rstudio-desktop/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#shiny-2012",
    "href": "R_lec_01_2025.html#shiny-2012",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://shiny.posit.co/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#tidyverse-2016",
    "href": "R_lec_01_2025.html#tidyverse-2016",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://www.tidyverse.org/\n\n\n\n \n\n\n\n\nhttps://www.tidyverse.org/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#posit-2022",
    "href": "R_lec_01_2025.html#posit-2022",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://posit.co/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#quarto-2022",
    "href": "R_lec_01_2025.html#quarto-2022",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "",
    "text": "https://quarto.org/\n\n\n\n\n\nhttps://rstudio.github.io/cheatsheets/html/quarto.html",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#ide",
    "href": "R_lec_01_2025.html#ide",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "IDE",
    "text": "IDE\nIDE(integrated development environment, 통합개발환경)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#ide-1",
    "href": "R_lec_01_2025.html#ide-1",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "IDE",
    "text": "IDE\n\n\nhttps://moderndive.com/1-getting-started.html#r-rstudio",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#ide-2",
    "href": "R_lec_01_2025.html#ide-2",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "IDE",
    "text": "IDE\n\n\nhttps://djangostars.com/blog/python-ide/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#ide-3",
    "href": "R_lec_01_2025.html#ide-3",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "IDE",
    "text": "IDE\n\n\nhttps://posit.co/blog/positron-product-announcement-aug-2025/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#개의-창",
    "href": "R_lec_01_2025.html#개의-창",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "4개의 창",
    "text": "4개의 창",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#r-project",
    "href": "R_lec_01_2025.html#r-project",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "R Project",
    "text": "R Project",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#r-project-1",
    "href": "R_lec_01_2025.html#r-project-1",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "R Project",
    "text": "R Project\n\n\nhttps://allisonhorst.com/allison-horst",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#rstudio-가이드",
    "href": "R_lec_01_2025.html#rstudio-가이드",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "RStudio 가이드",
    "text": "RStudio 가이드\n\nRStudio IDE User Guide\nPosit Cheatsheets",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#프로그래밍의-기본-개념",
    "href": "R_lec_01_2025.html#프로그래밍의-기본-개념",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "프로그래밍의 기본 개념",
    "text": "프로그래밍의 기본 개념\n\n\n객체(object): R 환경 안에 존재하는, 식별가능하고 조작 가능한 모든 엔터티\n\n데이터 객체: 숫자/문자/논리값, 벡터, 데이터 프레임\n비데이터 객체: 함수, 플롯, 모형 등\n\n\n\n할당(assignment): 데이터와 이름을 연결해 R 환경에 객체를 저장하는 프로그래밍 언어적 동작\n\n특정한 할당 연산자 사용: &lt;- 또는 =\n\n\n\n연산자(operator): 하나 이상의 객체(피연산자)에 적용되어, 객체의 상태를 바꾸거나 새로운 값을 만드는 프로그래밍 언어의 기본 요소\n함수(function): 특정 동작을 수행하는 코드 블록. 인풋을 함수에 적용하면 함수의 고유한 동작을 통해 아웃풋이 산출",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#연산자-operators",
    "href": "R_lec_01_2025.html#연산자-operators",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "연산자 Operators",
    "text": "연산자 Operators\n\n\nhttps://learnetutorials.com/r-programming/operators-and-types",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#할당-연산자",
    "href": "R_lec_01_2025.html#할당-연산자",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "할당 연산자",
    "text": "할당 연산자",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#산술-연산자",
    "href": "R_lec_01_2025.html#산술-연산자",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "산술 연산자",
    "text": "산술 연산자\n\n\nOperator\nDescription\nExample\n\n\n\n+\naddition\n5+5=10\n\n\n-\nsubtraction\n5-5=0\n\n\n*\nmultiplication\n2*8=16\n\n\n/\ndivision\n100/10=10\n\n\n\n^ (or **)\nexponent/power\n5^2=25\n\n\n%%\nmodulo\n100%%15=10\n\n\n%/%\ninteger division\n100%/%15=6",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#관계-논리-기타-연산자",
    "href": "R_lec_01_2025.html#관계-논리-기타-연산자",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "관계, 논리, 기타 연산자",
    "text": "관계, 논리, 기타 연산자\n\n\nType\nOperator\nCondition\n\n\n\n관계 Relational\nx &lt; y\nWhere x less than y\n\n\n\n\nx &gt; y\nWhere x greater than y\n\n\n\n\nx &lt;= y\nWhere x less than or equal to y\n\n\n\n\nx &gt;= y\nWhere x greater than or equal to y\n\n\n\n\nx == y\nWhere x (exactly) equals y\n\n\n\n\nx != y\nWhere x is not equal to y\n\n\n\n논리 Logical\n!\nNegation\n\n\n\n&\nLogical “and” (x &gt;= 20 & x &lt; 35)\n\n\n\n|\nLogical “or (x == 20 | x &gt; 45)\n\n\n\nxor\nLogical “exclusive or” (xor(x == 20, x == 50)\n\n\n기타 Miscellaneous\nx %in% y\nWhere x is in y\n\n\n\n\n!x %in% y\nWhere x is not in y",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#webr-연습",
    "href": "R_lec_01_2025.html#webr-연습",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "webr 연습",
    "text": "webr 연습\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#함수-functions",
    "href": "R_lec_01_2025.html#함수-functions",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "함수 functions",
    "text": "함수 functions\n\nseq(from = 2, to = 100, by = 2)\n\n\n\nhttps://www.r4epi.com/speaking-rs-language",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#주요-산술-함수",
    "href": "R_lec_01_2025.html#주요-산술-함수",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "주요 산술 함수",
    "text": "주요 산술 함수\n\n\n분류\n함수\n\n\n\n절대값/부호\n\nabs(), sign()\n\n\n\n제곱근/지수\n\nsqrt(), exp()\n\n\n\n로그\n\nlog(), log10(), log2()\n\n\n\n삼각함수\n\nsin(), cos(), tan(), asin()\n\n\n\n반올림\n\nround(), floor(), ceiling(), trunc()\n\n\n\n요약\n\nsum(), mean(), median(), var(), sd(), min(), max(), range(), summary()",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#그-외-많이-쓰이는-함수",
    "href": "R_lec_01_2025.html#그-외-많이-쓰이는-함수",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "그 외 많이 쓰이는 함수",
    "text": "그 외 많이 쓰이는 함수\n\n\n\n\n\n\n분류\n함수\n\n\n\n논리형 판별\n\nis.na(), is.numeric(), is.character(), is.null()\n\n\n\n수열/반복\n\nseq(), rep()\n\n\n\n난수/표본 생성\n\nsample(), rnorm()\n\n\n\n유형 변환\n\nas.numeric(), as.character()\n\n\n\n표준화\nscale()\n\n\n길이\nlength()\n\n\n정렬\n\nsort(), order()\n\n\n\n중복 처리\n\nunique(), duplicated()",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#데이터-객체-데이터-유형",
    "href": "R_lec_01_2025.html#데이터-객체-데이터-유형",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "데이터 객체: 데이터 유형",
    "text": "데이터 객체: 데이터 유형",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#벡터와-데이터-프레임",
    "href": "R_lec_01_2025.html#벡터와-데이터-프레임",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "벡터와 데이터 프레임",
    "text": "벡터와 데이터 프레임\n\n\nR 코드\nwebr 연습\n\n\n\n\na &lt;- c(58, 26, 24, 19)\nb &lt;- c(58L, 26L, 24L, 32L)\nc &lt;- c(TRUE, TRUE, FALSE, FALSE)\nd &lt;- c(\"이상일\", \"김우형\", \"박서우\", \"이하은\")\ndf &lt;- data.frame(a, b, c, d)\ndf\n\n   a  b     c      d\n1 58 58  TRUE 이상일\n2 26 26  TRUE 김우형\n3 24 24 FALSE 박서우\n4 19 32 FALSE 이하은\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#differences",
    "href": "R_lec_01_2025.html#differences",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "Differences",
    "text": "Differences",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#differences-1",
    "href": "R_lec_01_2025.html#differences-1",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "Differences",
    "text": "Differences",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#r-for-open-science",
    "href": "R_lec_01_2025.html#r-for-open-science",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "R for Open Science",
    "text": "R for Open Science",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#r-for-reproducible-research",
    "href": "R_lec_01_2025.html#r-for-reproducible-research",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "R for Reproducible Research",
    "text": "R for Reproducible Research",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#r-communities",
    "href": "R_lec_01_2025.html#r-communities",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "R Communities",
    "text": "R Communities",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#r-communities-1",
    "href": "R_lec_01_2025.html#r-communities-1",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "R Communities",
    "text": "R Communities",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_01_2025.html#r-and-python-in-harmony",
    "href": "R_lec_01_2025.html#r-and-python-in-harmony",
    "title": "\nR Lecture 1R과 RStudio\n",
    "section": "R and Python in Harmony",
    "text": "R and Python in Harmony",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 1]{style=\"color:coral;font-size:0.6em\"}\n| [R과 RStudio]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html",
    "href": "R_lec_09_2025.html",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "",
    "text": "역동성과 상호작용성이 부가된 시각화\n구현 방식\n\n임베딩(embedding): 외부 콘텐츠 삽입\n동적ㆍ반응형 내용 요소의 직접 제작\n\n\n\n\n\n\n개념\n\n외부 웹 사이트/앱의 콘텐츠를 현재 웹 사이트/앱 안에 삽입하여 보여주는 기법\nHTML의 iframe 태그 활용\n별도의 페이지 전환 없이 다른 서비스나 시각화 결과를 한 웹 앱에 통합\n일부 사이트는 임베딩 불가능\n\n대상\n\n동적ㆍ반응형 시각화 웹 사이트/앱\n상호작용형 교육ㆍ협업 도구: Padlet, Mentimeter, Google Forms 등\n동영상: YouTube\n\n\n\n\n\n\nR 패키지 활용\n\n동적ㆍ반응형 내용 요소 제작을 지원하는 R 자체 패키지\ngganimate, ggiraph\n\nR 래퍼 패키지 활용\n\nJS 라이브러리와의 가교\nDT, plotly\n\n결합\n\nR 패키지로 제작한 정적 콘텐츠를 R 래퍼 패키지를 통해 동적ㆍ반응형 콘텐츠로 전환\nggplot2 + plotly",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#동적ㆍ반응형-시각화의-구현",
    "href": "R_lec_09_2025.html#동적ㆍ반응형-시각화의-구현",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "",
    "text": "역동성과 상호작용성이 부가된 시각화\n구현 방식\n\n임베딩(embedding): 외부 콘텐츠 삽입\n동적ㆍ반응형 내용 요소의 직접 제작",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#임베딩",
    "href": "R_lec_09_2025.html#임베딩",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "",
    "text": "개념\n\n외부 웹 사이트/앱의 콘텐츠를 현재 웹 사이트/앱 안에 삽입하여 보여주는 기법\nHTML의 iframe 태그 활용\n별도의 페이지 전환 없이 다른 서비스나 시각화 결과를 한 웹 앱에 통합\n일부 사이트는 임베딩 불가능\n\n대상\n\n동적ㆍ반응형 시각화 웹 사이트/앱\n상호작용형 교육ㆍ협업 도구: Padlet, Mentimeter, Google Forms 등\n동영상: YouTube",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#직접-제작",
    "href": "R_lec_09_2025.html#직접-제작",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "",
    "text": "R 패키지 활용\n\n동적ㆍ반응형 내용 요소 제작을 지원하는 R 자체 패키지\ngganimate, ggiraph\n\nR 래퍼 패키지 활용\n\nJS 라이브러리와의 가교\nDT, plotly\n\n결합\n\nR 패키지로 제작한 정적 콘텐츠를 R 래퍼 패키지를 통해 동적ㆍ반응형 콘텐츠로 전환\nggplot2 + plotly",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#사례-1",
    "href": "R_lec_09_2025.html#사례-1",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "사례 1",
    "text": "사례 1\n\n통계놀이터(https://kosis.kr/edu/)\n\n\nCodeResult\n\n\n&lt;iframe src=\"https://kosis.kr/edu/share.do?shareID=S0500_16\" \nloading=\"lazy\" style=\"width: 100%; height: 600px; border: \n0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#사례-2",
    "href": "R_lec_09_2025.html#사례-2",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "사례 2",
    "text": "사례 2\n\nOur World in Data(https://ourworldindata.org/)\n\n\nCodeResult\n\n\n&lt;iframe src=\"https://ourworldindata.org/explorers/population-and-demography?indicator=Fertility+rate&Sex=Both+sexes&Age=Total&Projection+scenario=Medium&country=Asia+%28UN%29~Europe+%28UN%29~Africa+%28UN%29~Oceania+%28UN%29~Northern+America+%28UN%29~Latin+America+and+the+Caribbean+%28UN%29~OWID_WRL~KOR&tab=chart&hideControls=true\" loading=\"lazy\" style=\"width: 70%; height: 600px; border: 0px none;\" allow=\"web-share; clipboard-write\"&gt;&lt;/iframe&gt;",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#개요",
    "href": "R_lec_09_2025.html#개요",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "개요",
    "text": "개요\n\n테이블 역시 시각화의 일부\n\n데이터 변형 및 요약을 거친 정적 테이블\n시각성이 가미된 정적 테이블\n인터랙티브 테이블\n\n테이블 디자인 원칙(핸즈온 데이터 시각화, 2022)\n\n열 제목을 데이터 상단에 눈에 띄게 만들어라.\n밝은 음영을 사용해 열이나 행을 구분하라.\n읽기 쉽도록 텍스트는 왼쪽 정렬하고 숫자는 오른쪽 정렬하라.\n레이블을 첫 번째 행에만 배치하여 중복을 피하라.\n테이터를 그룹화 및 정렬하여 의미 있는 패턴을 강조하라.",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#도구의-분류",
    "href": "R_lec_09_2025.html#도구의-분류",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "도구의 분류",
    "text": "도구의 분류\n\n\n\nhttps://r-graph-gallery.com/table.html",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#gt-패키지",
    "href": "R_lec_09_2025.html#gt-패키지",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "gt 패키지",
    "text": "gt 패키지\n\n\n\nhttps://gt.rstudio.com/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#gt-패키지-1",
    "href": "R_lec_09_2025.html#gt-패키지-1",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "gt 패키지",
    "text": "gt 패키지\n\n\n\nhttps://gt.rstudio.com/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#gt-패키지-2",
    "href": "R_lec_09_2025.html#gt-패키지-2",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "gt 패키지",
    "text": "gt 패키지\n\n\n\nhttps://towardsdatascience.com/exploring-the-gt-grammar-of-tables-package-in-r-7fff9d0b40cd",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#flextable패키지",
    "href": "R_lec_09_2025.html#flextable패키지",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "flextable패키지",
    "text": "flextable패키지\n\n웹북(https://ardata-fr.github.io/flextable-book/)\n\n\n\n\nhttps://twitter.com/DavidGohel/status/1376892794627883016/photo/1",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#인터랙티브-테이블",
    "href": "R_lec_09_2025.html#인터랙티브-테이블",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "인터랙티브 테이블",
    "text": "인터랙티브 테이블\n\n\n\n자바스크립트 라이브러리\nR 래퍼 패키지\n\n\n\n\nDataTables\nDT\n\n\nTanstack Table\nreactable",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#래퍼-패키지-dt",
    "href": "R_lec_09_2025.html#래퍼-패키지-dt",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "래퍼 패키지: DT",
    "text": "래퍼 패키지: DT\n\nDataTables: 자바스크립트 라이브러리\nR 래퍼 패키지: DT\n\n웹북: D3 for R Users\n\n\n\n\n\nhttps://datatables.net/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#래퍼-패키지-dt-1",
    "href": "R_lec_09_2025.html#래퍼-패키지-dt-1",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "래퍼 패키지: DT",
    "text": "래퍼 패키지: DT\n\nPagination: 페이지 이동 기능\nInstant search: 즉각적 검색 기능(Search에 타이핑하기 시작하면 즉각적으로 검색 결과 보여줌)\nOrdering/sorging: 컬럼 정렬 기능\nMulti-column ordering: 다중 컬럼 정렬 기능(컬럼 하나를 선택한 후 ctrl을 누른 상태에서 다른 컬럼을 선택)\nFiltering: 값 추림 기능\nEditable: 셀 값 수정 기능\nButtons: 셀 숨기기 기능, CSV, PDF, XLSX 등의 확장자로 내보내기 등을 수행하는 버튼 생성 기능",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#래퍼-패키지-dt-2",
    "href": "R_lec_09_2025.html#래퍼-패키지-dt-2",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "래퍼 패키지: DT",
    "text": "래퍼 패키지: DT\n\nCodeResult\n\n\n\ngapminder |&gt; \n  datatable(\n    filter = \"top\",\n    extensions = \"Buttons\",\n    options = list(\n      pageLength = 5,\n      autoWidth = TRUE,\n      dom = \"Bfrtip\",\n      buttons = c(\"copy\", \"excel\", \"pdf\", \"print\")\n    )\n  )\n\n\n\n\nlibrary(DT)\nlibrary(gapminder)\ngapminder |&gt; \n  datatable(\n    filter = \"top\",\n    extensions = \"Buttons\",\n    options = list(\n      pageLength = 5,\n      autoWidth = TRUE,\n      dom = \"Bftip\",\n      buttons = c(\"copy\", \"excel\", \"pdf\", \"print\")\n    )\n  )",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#r-패키지-gganimate",
    "href": "R_lec_09_2025.html#r-패키지-gganimate",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "R 패키지: gganimate",
    "text": "R 패키지: gganimate\n\nCodeResult\n\n\n\nlibrary(gganimate)\nP &lt;- gapminder |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp, size = pop, color = continent)) +\n  geom_point(show.legend = FALSE, alpha = 0.7) +\n  scale_x_log10() +\n  scale_size(range = c(2, 12))\nP + transition_time(year) +\n  labs(title = \"Year: {frame_time}\")",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#r-패키지-ggiraph-패키지",
    "href": "R_lec_09_2025.html#r-패키지-ggiraph-패키지",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "R 패키지: ggiraph 패키지",
    "text": "R 패키지: ggiraph 패키지\n\nggplot2 패키지의 확장\n상호작용형 기하객체(geometry): geom_*_interactive\n\ngeom_point(): geom_point_interactive()\ngeom_sf(): geom_sf_interactive()\n…\n\n상호작용형 시각속성(aethetics)\n\ntoolitp\nonclick\ndata_id\n\n웹북: ggiraph-book",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#r-패키지-ggiraph-패키지-1",
    "href": "R_lec_09_2025.html#r-패키지-ggiraph-패키지-1",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "R 패키지: ggiraph 패키지",
    "text": "R 패키지: ggiraph 패키지\n\nCodeResult\n\n\n\nlibrary(tidyverse)\nlibrary(ggiraph)\ndata &lt;- mtcars\ndata &lt;- data |&gt; rownames_to_column(var = \"carname\")\ngg_point = ggplot(data = data) +\n  geom_point_interactive(\n    aes(x = wt, y = qsec, color = disp, \n        tooltip = carname, data_id = carname)\n  ) + \n  theme_minimal()\ngirafe(ggobj = gg_point)\n\n\n\n\nlibrary(tidyverse)\nlibrary(ggiraph)\ndata &lt;- mtcars\ndata &lt;- data |&gt; rownames_to_column(var = \"carname\")\ngg_point = ggplot(data = data) +\n  geom_point_interactive(\n    aes(x = wt, y = qsec, color = disp, \n        tooltip = carname, data_id = carname)\n  ) + \n  theme_minimal()\ngirafe(ggobj = gg_point)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#래퍼-패키지-활용",
    "href": "R_lec_09_2025.html#래퍼-패키지-활용",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "래퍼 패키지 활용",
    "text": "래퍼 패키지 활용\n\n\n\n\n\n\n\n자바스크립트 라이브러리\nR 래퍼 패키지\n\n\n\n\nPlotly\nplotly\n\n\nD3\nr2d3\n\n\nHighcharts\nhighcharter\n\n\nECharts\necharts4r, echarty\n\n\ndygraphs\ndygraphs\n\n\nGoogle Charts\ngoogleVis\n\n\nChart.js\nchartjs\n\n\nthree.js\nr3js",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#래퍼-패키지-plotly-패키지",
    "href": "R_lec_09_2025.html#래퍼-패키지-plotly-패키지",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "래퍼 패키지: plotly 패키지",
    "text": "래퍼 패키지: plotly 패키지\n\nPlotly: 자바스크립트 라이브러리\nR 래퍼 패키지: plotly package\n\nggplotly() 함수\n\n\n\n\n\nhttps://plotly.com/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#래퍼-패키지-plotly-패키지-1",
    "href": "R_lec_09_2025.html#래퍼-패키지-plotly-패키지-1",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "래퍼 패키지: plotly 패키지",
    "text": "래퍼 패키지: plotly 패키지\n\nCodeResult\n\n\n\nlibrary(plotly)\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  plot_ly(\n    x = ~gdpPercap, \n    y = ~lifeExp, \n    color = ~continent,\n    text = ~paste(\n      \"Country: \", country, \n      \"&lt;br&gt;GDP per capita: \", gdpPercap, \n      \"$&lt;br&gt;Life Expectancy at Birth:\", lifeExp\n    )\n  )\n\n\n\n\nlibrary(plotly)\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  plot_ly(\n    x = ~gdpPercap, \n    y = ~lifeExp, \n    color = ~continent,\n    text = ~paste(\n      \"Country: \", country, \n      \"&lt;br&gt;GDP per capita: \", gdpPercap, \n      \"$&lt;br&gt;Life Expectancy at Birth:\", lifeExp\n    )\n  )",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#래퍼-패키지-plotly-패키지-2",
    "href": "R_lec_09_2025.html#래퍼-패키지-plotly-패키지-2",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "래퍼 패키지: plotly 패키지",
    "text": "래퍼 패키지: plotly 패키지\n\nCodeResult\n\n\n\ngapminder |&gt; \n  plot_ly(\n    x = ~log10(gdpPercap), y = ~lifeExp,\n    text = ~paste(\n      \"Country:\", country, \n      \"&lt;/br&gt;Continent:\", continent, \n      \"&lt;/br&gt;lifeExp:\", lifeExp\n    )\n  ) |&gt; \n  add_markers(\n    color = ~continent, \n    size = ~pop, \n    frame = ~year, \n    marker = list(sizeref = 0.2, sizemode = \"area\")\n  )\n\n\n\n\ngapminder |&gt; \n  plot_ly(\n    x = ~log10(gdpPercap), y = ~lifeExp,\n    text = ~paste(\n      \"Country:\", country, \n      \"&lt;/br&gt;Continent:\", continent, \n      \"&lt;/br&gt;lifeExp:\", lifeExp\n    )\n  ) |&gt; \n  add_markers(\n    color = ~continent, \n    size = ~pop, \n    frame = ~year, \n    marker = list(sizeref = 0.2, sizemode = \"area\")\n  )",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#래퍼-패키지-plotly-패키지의-ggplotly-함수",
    "href": "R_lec_09_2025.html#래퍼-패키지-plotly-패키지의-ggplotly-함수",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "래퍼 패키지: plotly 패키지의 ggplotly() 함수",
    "text": "래퍼 패키지: plotly 패키지의 ggplotly() 함수\n\nCodeResult\n\n\n\nP &lt;- gapminder |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() + \n  scale_color_brewer(palette = \"Set2\") +\n  theme_minimal()\nggplotly(P)",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_09_2025.html#래퍼-패키지-echarts4r-패키지",
    "href": "R_lec_09_2025.html#래퍼-패키지-echarts4r-패키지",
    "title": "R Lecture 9\n웹 앱 개발: 인터랙티브 시각화",
    "section": "래퍼 패키지: echarts4r 패키지",
    "text": "래퍼 패키지: echarts4r 패키지\n\nCodeResult\n\n\n\nlibrary(tidyverse)\nlibrary(echarts4r)\nlibrary(RColorBrewer)\nmy.data &lt;- read_rds(\"D:/My R/Population Geography/wpp_2024.rds\")\ndata.sel &lt;- my.data |&gt; \n  filter(\n    type == \"Subregion\" | region_name == \"Northern America\",\n    year == 2025\n  )\ncustom_colors &lt;- brewer.pal(n = 6, name = \"Set2\")\ndata.sel |&gt; \n  arrange(median_age) |&gt; \n  mutate(\n    median_age = round(median_age, digits = 1)\n  ) |&gt; \n  group_by(Region_NM) |&gt; \n  e_charts(region_name, width = \"100%\", height = \"800px\") |&gt; \n  e_bar(serie = median_age, stack = \"grp\") |&gt; \n  e_color(custom_colors) |&gt; \n  e_flip_coords() |&gt; \n  e_x_axis(name = \"Median Age\") |&gt; \n  e_tooltip() |&gt; \n  e_legend()",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 9]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: 인터랙티브 시각화]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html",
    "href": "R_lec_11_2025.html",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "",
    "text": "https://shiny.posit.co/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#shiny-서버-기반-웹-앱-개발-프레임워크",
    "href": "R_lec_11_2025.html#shiny-서버-기반-웹-앱-개발-프레임워크",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "",
    "text": "https://shiny.posit.co/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#리소스-shiny-홈페이지",
    "href": "R_lec_11_2025.html#리소스-shiny-홈페이지",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "리소스: Shiny 홈페이지",
    "text": "리소스: Shiny 홈페이지\n\nhttps://shiny.posit.co/\n\nShiny for R(https://shiny.posit.co/r/)\nShiny for Python(https://shiny.posit.co/py/)\n\n11개 예시\n\n예시의 이름 검색: runExample()\n\n“01_hello”, “02_text”, “03_reactivity”, “04_mpg”, “05_sliders”, “06_tabsets”, “07_widgets”, “08_html”, “09_upload”, “10_download”, “11_timer”\n\n예시의 웹 앱 및 코드 보기: runExample(\"01_hello\", display = \"showcase\")",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#리소스-웹북",
    "href": "R_lec_11_2025.html#리소스-웹북",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "리소스: 웹북",
    "text": "리소스: 웹북\n\nMastering Shiny by Hadley Wickham\nOutstanding User Interfaces with Shiny\nEngineering Production-Grade Shiny Apps\nInteractive Web-Based Data Visualization with R, plotly, and shiny\nR Shiny Applications in Finance, Medicine Pharma and Education Industry\nIntroduction to Data Science: 25 Shiny Applications\n데이터 사이언스를 위한 R 프로그래밍: 14 shiny",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#기본-구조",
    "href": "R_lec_11_2025.html#기본-구조",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "기본 구조",
    "text": "기본 구조\n\nui 부분: 프론트엔드(front-end) 부분\n\n입력을 받고 출력을 보여주는 부분\n\nserver 부분: 백엔드(back-end) 부분\n\n받은 입력으로 출력을 산출하는 부분\n\n결합: shinyApp(ui = ui, server = server)\n\n\n\n\nhttps://bookdown.org/hneth/i2ds/shiny.html",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#기본-구조-ui-부분",
    "href": "R_lec_11_2025.html#기본-구조-ui-부분",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "기본 구조: ui 부분",
    "text": "기본 구조: ui 부분\n\n입력(input)\n\n‘입력 함수’: 사용자로부터 입력을 받아 ’입력 객체’를 만드는 함수\n위젯(widget): ui를 위한 기본 시각 요소로, 미리 만들어져 있는 것\n\n버튼, 스크롤 바, 텍스트 상자, 체크박스, 라디오 버튼 등\n\n입력의 종류에 따라 다양: *Input()\n\nsliderInput(inputID = \"\")\n\n\n출력(output)\n\n‘출력 함수’: 서버로부터 ’출력 객체’를 받아 디스플레이하는 함수\n출력의 종류에 따라 다양: *Output()\n\nplotOutput(outputID = \"\")",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#기본-구조-ui-부분-1",
    "href": "R_lec_11_2025.html#기본-구조-ui-부분-1",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "기본 구조: ui 부분",
    "text": "기본 구조: ui 부분\n\n입력 함수(위젯): https://shiny.posit.co/r/components/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#기본-구조-ui-부분-2",
    "href": "R_lec_11_2025.html#기본-구조-ui-부분-2",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "기본 구조: ui 부분",
    "text": "기본 구조: ui 부분\n\n출력 함수: https://shiny.posit.co/r/components/\n주요 함수: *Output(outputID = \"\")\n\n플롯: plotOutput(outputID = \"\")\n테이블: tableOutput(outputID = \"\")\n일반 텍스트: textOutput(outputID = \"\")\n사전 포맷된 텍스트: verbatimeTextOutput(outputID = \"\")\n이미지: imageOutput(outputID = \"\")",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#기본-구조-server-부분",
    "href": "R_lec_11_2025.html#기본-구조-server-부분",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "기본 구조: server 부분",
    "text": "기본 구조: server 부분\n\n입력 객체를 받아 특정한 출력 객체를 생성\n\n입력 객체: input$inputID\n\n출력 객체 생성 함수(렌더링 함수): render*({})\n\nrenderPlot({})\n출력 객체: output$outputID\n\n주요 함수: render*()\n\n플롯: renderPlot()\n테이블: renderTable()\n일반 텍스트: renderText()\n사전 포맷된 텍스트: renderPrint()\n이미지: renderImage()",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#기본-구조-ui-server-연계",
    "href": "R_lec_11_2025.html#기본-구조-ui-server-연계",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "기본 구조: ui-server 연계",
    "text": "기본 구조: ui-server 연계\n\n출력 생성(렌더링) 함수와 출력 함수: https://shiny.posit.co/r/components/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#기본-구조-ui-server-연계-1",
    "href": "R_lec_11_2025.html#기본-구조-ui-server-연계-1",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "기본 구조: ui-server 연계",
    "text": "기본 구조: ui-server 연계\n\n주요 패키지별 출력 생성(렌더링) 함수 및 출력 함수\n\n\n\n\n주요 패키지\n출력 생성(렌더링) 함수\n출력 함수\n\n\n\n\nDT\nrenderDT({})\nDTOutput(outputID = \"\")\n\n\nreactable\nrenderReactable({})\nreactableOutput(outputID = \"\")\n\n\nplotly\nrenderPlotyl({})\nplotlyOutput(outputID = \"\")\n\n\necharts4r\nrenderEcharts4r({})\necharts4rOutput(outputID = \"\")\n\n\nleaflet\nrenderLeaflet({})\nleafletOutput(outputID = \"\")\n\n\ntmap\nrenderTmap({})\ntmapOutput(outputID = \"\")",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#반응성-함수-reactive",
    "href": "R_lec_11_2025.html#반응성-함수-reactive",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "반응성 함수 reactive({})",
    "text": "반응성 함수 reactive({})\n\nrender*() 함수는 이미 반응성 함수\n\n사용자의 선택이 바뀔 때마다 갱신\n\n반응성 함수 reactive({})\n\n입력 객체를 받아 ‘반응성 표현식(reactive expression)’ 생성\n반응성 표현식: 단순히 최종 산출물(값이나 객체)만을 의미하지 않고, 그 산출물을 관리하는 메커니즘(종속성 추적, 지연 실행, 캐싱 등) 포함하는 동적인 객체\n\n반드시 함수 형태로 표기\n\n하나의 ’입력 객체’가 다양한 ’출력 객체(출력 생성 함수)’와 결부되는 경우\n\n동일한 입력 객체의 중복 사용 회피 목적\n해당 입력 객체를 반응성 표현식으로 전환\n다수의 출력 생성 함수에 입력 객체로 투입",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  },
  {
    "objectID": "R_lec_11_2025.html#확장-bslib-패키지",
    "href": "R_lec_11_2025.html#확장-bslib-패키지",
    "title": "R Lecture 11\n웹 앱 개발: Shiny 1",
    "section": "확장: bslib 패키지",
    "text": "확장: bslib 패키지\n\n\n\nhttps://rstudio.github.io/bslib/",
    "crumbs": [
      "R 프레젠테이션: 2025/2",
      "| [R Lecture 11]{style=\"color:coral;font-size:0.6em\"}\n| [웹 앱 개발: Shiny 1]{style=\"font-size:1em\"}"
    ]
  }
]